<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>怀德维宁</title>
  
  <subtitle>大邦维屏，大宗维翰。怀德维宁，宗子维城。</subtitle>
  <link href="https://bbbccvbvv.github.io/atom.xml" rel="self"/>
  
  <link href="https://bbbccvbvv.github.io/"/>
  <updated>2025-01-24T09:59:10.778Z</updated>
  <id>https://bbbccvbvv.github.io/</id>
  
  <author>
    <name>杨维宁</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>virtio-win-gt修改Tcp323opts</title>
    <link href="https://bbbccvbvv.github.io/2025/01/24/20250124-windows_virtio_mdify_tcp1323opts/"/>
    <id>https://bbbccvbvv.github.io/2025/01/24/20250124-windows_virtio_mdify_tcp1323opts/</id>
    <published>2025-01-24T10:02:10.000Z</published>
    <updated>2025-01-24T09:59:10.778Z</updated>
    
    <content type="html"><![CDATA[<p>在之前处理的一个问题中，发现HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters路径下的Tcp323opts参数对于网络具有很大影响。虽然最后问题定位于网络驱动版本落后问题，但是在该过程中发现windows的网络相关设置与系统默认设置不一致。</p><span id="more"></span><p>按照微软官方文档的说法：默认情况下启用时间戳和窗口缩放，即默认情况下对应数值为3<br><a href="https://learn.microsoft.com/zh-cn/troubleshoot/windows-server/networking/description-tcp-features">https://learn.microsoft.com/zh-cn/troubleshoot/windows-server/networking/description-tcp-features</a></p><p>在ali的对应系统上，发现整体行为符合微软的文档中的说明：即注册表中不存在对应表项，因此使用了默认策略，启用时间戳和窗口缩放。</p><p>但是在出问题的windows系统上，却发现Tcp1323opts被设置为了0，整体表现与预期不符，结合相关资料，可以认为存在相关程序对该键值进行了修改。</p><p>最后定位在了virtio-win-gt程序上，安装virtio驱动是使用virtio-win-gt-x64.msi进行安装。</p><p>因此在ali的虚拟机上使用virtio-win-gt-x64.msi安装virtio，并结合日志对比安装前后注册表变化，发现virtio-win-gt-x64安装过程中对注册表进行了修改，在日志中发现其修改了两个注册表键值。</p><p>（1）将\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\Tcp1323Opts设置为0；</p><p>（2）将\Software\VirtIO-FS\FileSystemName设置为NTFS；</p><p>详细日志记录如下：</p><pre><code>MSI (s) (74:70) [21:10:41:755]: Executing op: RegOpenKey(Root=-2147483646,Key=SYSTEM\CurrentControlSet\Services\Tcpip\Parameters,,BinaryType=1,,)MSI (s) (74:70) [21:10:41:755]: Executing op: RegAddValue(Name=Tcp1323Opts,Value=#0,)1: \SYSTEM\CurrentControlSet\Services\Tcpip\Parameters 2: Tcp1323Opts 3: #0 MSI (s) (74:70) [21:10:41:755]: Executing op: RegOpenKey(Root=-2147483646,Key=Software\VirtIO-FS,,BinaryType=1,,)MSI (s) (74:70) [21:10:41:755]: Executing op: RegAddValue(Name=FileSystemName,Value=NTFS,)1: \Software\VirtIO-FS 2: FileSystemName 3: NTFS </code></pre><script src="https://utteranc.es/client.js" repo="bbbccvbvv/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;在之前处理的一个问题中，发现HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters路径下的Tcp323opts参数对于网络具有很大影响。虽然最后问题定位于网络驱动版本落后问题，但是在该过程中发现windows的网络相关设置与系统默认设置不一致。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="Windows" scheme="https://bbbccvbvv.github.io/tags/Windows/"/>
    
    <category term="network" scheme="https://bbbccvbvv.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>windows内存限制研究</title>
    <link href="https://bbbccvbvv.github.io/2024/12/24/20241224-windows_physical_memory_limit/"/>
    <id>https://bbbccvbvv.github.io/2024/12/24/20241224-windows_physical_memory_limit/</id>
    <published>2024-12-24T13:26:10.000Z</published>
    <updated>2024-12-24T13:24:37.486Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到了一个windows可识别内存只显示2g，其他内存显示为硬件预留的问题，查找相关资料，发现多数认为原因为系统未激活，甚至微软官方的文档也有这个说法。但是当笔者在测试环境进行测试时，发现这个问题不是必现的，笔者的未激活windows系统识别到了完整的内存，远大于2g。因此收集相关资料，尝试研究影响windows可识别内存的相关因素。</p><span id="more"></span><h1 id="windows物理内存限制"><a href="#windows物理内存限制" class="headerlink" title="windows物理内存限制"></a>windows物理内存限制</h1><p>该部分内容主要参考《Windows Internals》第六版第10章《Memory Management》中《Physical Memory Limits》章节。</p><p>Windows对物理内存的支持受硬件限制、激活证书、操作系统数据结构和驱动程序兼容性的影响。下表列出了不同版本的Windows目前支持的物理内存容量及其限制因素。</p><table><thead><tr><th align="center">版本</th><th align="center">32位系统限制</th><th align="center">64位系统限制</th><th align="center">限制因素</th></tr></thead><tbody><tr><td align="center">旗舰版、企业版、专业版</td><td align="center">4GB</td><td align="center">192GB</td><td align="center">64位系统的激活证书；32位系统的激活证书、硬件支持及驱动程序兼容性</td></tr><tr><td align="center">家庭高级版</td><td align="center">4GB</td><td align="center">16GB</td><td align="center">64位系统的激活证书；32位系统的激活证书、硬件支持及驱动程序兼容性</td></tr><tr><td align="center">家庭普通版</td><td align="center">4GB</td><td align="center">8GB</td><td align="center">64位系统的激活证书；32位系统的激活证书、硬件支持及驱动程序兼容性</td></tr><tr><td align="center">入门版</td><td align="center">2GB</td><td align="center">2GB</td><td align="center">激活证书</td></tr><tr><td align="center">数据中心版、企业版、基于Itanium版</td><td align="center">N&#x2F;A</td><td align="center">2TB</td><td align="center">测试和可用系统</td></tr><tr><td align="center">基础版</td><td align="center">N&#x2F;A</td><td align="center">8GB</td><td align="center">激活证书</td></tr><tr><td align="center">标准版和网页服务器版</td><td align="center">N&#x2F;A</td><td align="center">32GB</td><td align="center">激活证书</td></tr><tr><td align="center">服务器HPC版本</td><td align="center">N&#x2F;A</td><td align="center">128GB</td><td align="center">激活证书</td></tr></tbody></table><p>因此如果客户为系统配置的内存大于系统支持的最大物理内存，则多出的部分系统无法识别，就会造成系统识别到的内存远低于真实物理内存。</p><h1 id="windows注册表文件限制"><a href="#windows注册表文件限制" class="headerlink" title="windows注册表文件限制"></a>windows注册表文件限制</h1><p>windows启动过程中会读取注册表来解析Kernel-WindowsMaxMemAllowedx64的值，如果解析失败就只能使用2GB的内存，对应的注册表路径如下：</p><pre><code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\ProductOptions\ProductPolicy</code></pre><p><img src="/images/windows_memory_limit/1.png"></p><p>对应的注册表键值是大量的16进制数据，无法直观获取，可以使用如下的powershell指令获取具体数值：</p><pre><code>(Get-ItemProperty HKLM:\SYSTEM\CurrentControlSet\Control\ProductOptions\).ProductPolicy.count</code></pre><p>正常的参数值应该是万级别，低于这个数量级就需要考虑注册表损坏的因素了。</p><p>该参数会在系统激活时被重置，因此可以通过激活系统的方法重新设置相关参数。</p><h1 id="系统配置最大内存限制"><a href="#系统配置最大内存限制" class="headerlink" title="系统配置最大内存限制"></a>系统配置最大内存限制</h1><p>在Windows系统配置-引导-高级选项中存在最大内存配置项，默认未勾选，即系统自动识别与设置最大内存。</p><p><img src="/images/windows_memory_limit/2.png"></p><p>如果用户勾选了对应选项，并手动设置了相关参数，可能就会造成系统识别到的内存异常。因此出现类似问题时，建议检查该配置项设置是否符合预期。</p><h1 id="图形卡和其他设备影响内存限制"><a href="#图形卡和其他设备影响内存限制" class="headerlink" title="图形卡和其他设备影响内存限制"></a>图形卡和其他设备影响内存限制</h1><p>设备必须将其内存映射到低于4GB才能与非PAE感知Windows版本兼容。因此，如果系统具有4GB的RAM，则其中一些RAM被BIOS禁用或重新映射在4GB以上如果重新映射内存，X64 Windows可以使用此内存。X86客户端版本的Windows不支持超过4GB标记的物理内存，因此它们无法访问这些重新映射的区域。任何X64 Windows或X86 Server版本都可以。</p><p>启用了PAE的X86客户端版本具有37位可用 (128 GB) 物理地址空间。这些版本施加的限制是允许的最高物理RAM地址，而不是IO空间的大小。这意味着PAE感知驱动程序实际上可以使用超过4GB的物理空间（如果需要）。例如，驱动程序可以映射位4GB以上的“丢失”内存区域，并将此内存公开为RAM磁盘。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>（1）<a href="https://learn.microsoft.com/zh-cn/troubleshoot/azure/virtual-machines/windows/windows-virtual-machine-activation-faq%EF%BC%9B">https://learn.microsoft.com/zh-cn/troubleshoot/azure/virtual-machines/windows/windows-virtual-machine-activation-faq；</a></p><p>（2）<a href="https://cloud.tencent.com/developer/article/1930066%EF%BC%9B">https://cloud.tencent.com/developer/article/1930066；</a></p><p>（3）<a href="https://help.aliyun.com/zh/ecs/the-physical-memory-of-a-windows-instance-is-abnormal%EF%BC%9B">https://help.aliyun.com/zh/ecs/the-physical-memory-of-a-windows-instance-is-abnormal；</a></p><p>（4）<a href="https://learn.microsoft.com/zh-cn/windows/win32/memory/memory-limits-for-windows-releases%EF%BC%9B">https://learn.microsoft.com/zh-cn/windows/win32/memory/memory-limits-for-windows-releases；</a></p><script src="https://utteranc.es/client.js" repo="bbbccvbvv/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近遇到了一个windows可识别内存只显示2g，其他内存显示为硬件预留的问题，查找相关资料，发现多数认为原因为系统未激活，甚至微软官方的文档也有这个说法。但是当笔者在测试环境进行测试时，发现这个问题不是必现的，笔者的未激活windows系统识别到了完整的内存，远大于2g。因此收集相关资料，尝试研究影响windows可识别内存的相关因素。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="内存" scheme="https://bbbccvbvv.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
    <category term="Windows" scheme="https://bbbccvbvv.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>windows常见启动问题</title>
    <link href="https://bbbccvbvv.github.io/2024/12/24/20241224-windows_common_boot_problems/"/>
    <id>https://bbbccvbvv.github.io/2024/12/24/20241224-windows_common_boot_problems/</id>
    <published>2024-12-24T05:26:10.000Z</published>
    <updated>2024-12-24T08:24:45.105Z</updated>
    
    <content type="html"><![CDATA[<p>windows常见的启动问题包含以下类型：</p><span id="more"></span><h1 id="主引导记录损坏（mbr-corruption）"><a href="#主引导记录损坏（mbr-corruption）" class="headerlink" title="主引导记录损坏（mbr corruption）"></a>主引导记录损坏（mbr corruption）</h1><p>现象：主引导记录损坏的系统会在bios上电自检（post）阶段显示黑屏，并展示bios版本信息和oem品牌标识，之后系统卡住（hang）。根据mbr损坏的类型的不同，用户可能会看到系列的信息：“无效的分区表（Invalid partition table）”、“加载操作系统异常（Error loading operating system）”或者“操作系统缺失（Missing operating system）”。</p><p><img src="/images/windows_common_boot_problems/1.png"></p><p>成因：硬盘异常、windows运行时由于驱动bug造成的磁盘损坏或者病毒的蓄意破坏都会造成主引导记录损坏。</p><p>修复：开机进入windows恢复环境（windows recovery environment），选择“命令提示符（Command Prompt）”选项，之后运行“bootrec &#x2F;fixmbr”命令。该命令会替换主引导记录中的运行代码。</p><h1 id="引导扇区损坏（Boot-Sector-Corruption）"><a href="#引导扇区损坏（Boot-Sector-Corruption）" class="headerlink" title="引导扇区损坏（Boot Sector Corruption）"></a>引导扇区损坏（Boot Sector Corruption）</h1><p>现象：引导扇区损坏的现象与主引导记录损坏相似，在bios上电自检后，系统卡在黑屏状态，此时可能在屏幕上显示“磁盘读取异常（A disk read error occurred）”、“bootmgr文件缺失（BOOTMGR is missing）”或“bootmgr文件被压缩（BOOTMGR is compressed）”等异常信息。</p><p><img src="/images/windows_common_boot_problems/2.png"></p><p>成因：硬盘异常、windows运行时由于驱动bug造成的磁盘损坏或者病毒的蓄意破坏都会造成引导扇区损坏。</p><p>修复：开机进入windows恢复环境（windows recovery environment），选择“命令提示符（Command Prompt）”选项，之后运行“bootrec &#x2F;fixboot”命令。该命令会重写用户指定的卷的引导扇区。如果系统卷和引导卷不一致，那就需要在两个卷上都运行这个命令。</p><h1 id="bcd配置错误（BCD-Misconfiguration）"><a href="#bcd配置错误（BCD-Misconfiguration）" class="headerlink" title="bcd配置错误（BCD Misconfiguration）"></a>bcd配置错误（BCD Misconfiguration）</h1><p>现象：在bios上电自检后，用户可能会看到如下的错误信息“windows因为计算机磁盘硬件配置问题无法启动（Windows could not start because of a computer disk hardware configuration problem）”、“无法从选定的引导磁盘上读取文件（Could not read from selected boot disk）”或“检查引导路径和磁盘硬件（Check boot path and disk hardware）”</p><p><img src="/images/windows_common_boot_problems/3.png"></p><p>成因：bcd被删除、bcd损坏或着由于分区的卷名称的改变造成不再指向引导卷都会造成该问题。</p><p>修复：开机进入windows恢复环境（windows recovery environment），选择“命令提示符（Command Prompt）”选项，之后运行“bootrec &#x2F;scanos”和“bootrec &#x2F;rebuildbcd”命令。这些命令会扫描每一个卷查找windows安装文件。如果发现了安装文件，就会询问用户是否将其作为引导配置项加入到bcd中，是否在引导菜单中展示对应的安装程序名称。对于其他的bcd相关的损坏情况，用户也可以使用Bcdedit.exe工具进行构建新的bcd或者复制现有的良好bcd文件的操作。</p><h1 id="系统文件损坏（System-File-Corruption）"><a href="#系统文件损坏（System-File-Corruption）" class="headerlink" title="系统文件损坏（System File Corruption）"></a>系统文件损坏（System File Corruption）</h1><p>现象：系统文件损坏包含多种方式，例如可执行文件损坏、驱动损坏或dll损坏等。一种方式是在bios上电自检后，黑屏上会显示如下的信息“windows无法启动因为下列文件缺失或损坏（Windows could not start because the following file is missing or corrupt）”，后续会跟着对应文件的名称，并请求重新安装对应文件。另一种方式是引导阶段产生一个蓝屏崩溃，并伴随着如下的文本信息“停止码：0xC0000135（无法定位组件）”（STOP: 0xC0000135 {Unable to Locate Component}）。</p><p><img src="/images/windows_common_boot_problems/4.png"></p><p>成因：系统文件所在的卷损坏、系统文件被删除或损坏都会造成该问题。</p><p>修复：开机进入windows恢复环境（windows recovery environment），选择“命令提示符（Command Prompt）”选项，之后运行“chkdsk”命令。chkdsk程序会尝试修复卷损坏。如果chkdsk程序没有报告任何问题，请获取有问题的系统文件的备份。可以检查%SystemRoot%\winsxs\Backup目录。windows会把windows资源保护访问的许多系统文件的备份纺织在这里。如果无法在该路径下找到对应的系统文件备份，可以尝试从互联网上获取对应的文件。注意备份文件必须与正在替换的文件来自同一系统版本或补丁程序。<br>在某些情况下，多个系统文件被删除或损坏，因此修复进程在用户逐个修复系统文件时需要进行多次重启和启动失败。如果用户认为系统文件损坏范围较大，建议从系统的备份中进行系统恢复，例如从windows备份程序产生或来自于一个系统恢复点的系统备份文件。<br>当用户运行备份与恢复（backup and restore）程序（位于开始菜单的维护文件夹中）时，会产生一个系统镜像恢复镜像，该镜像包含系统卷和引导卷中的全部文件，并伴随着一个存储了系统磁盘和卷信息的软盘。为了从这样一个镜像中恢复系统，从windows安装媒介中引导启动并在出现提示时选择对应的选项（或者使用更早之前展示的winre）。<br>如果没有可以用来进行恢复的备份镜像，最后的手段就是运行windows修复安装：从windows安装媒介中引导启动，按照向导如同进行新系统安装一样操作。向导会向使用者询问时进行系统修复还是重新安装系统。选择进行系统修复，安装程序将会重安装全部的系统文件，保留用户的应用程序数据和注册表设置。</p><h1 id="系统注册表文件损坏（System-Hive-Corruption）"><a href="#系统注册表文件损坏（System-Hive-Corruption）" class="headerlink" title="系统注册表文件损坏（System Hive Corruption）"></a>系统注册表文件损坏（System Hive Corruption）</h1><p>现象：如果系统注册表文件缺失或损坏，系统会在bios上电自检后显示黑屏，winload会在屏幕上显示如下信息“windows因为下列文件缺失或损坏而无法启动：\WINDOWS\SYSTEM32\CONFIG\­SYSTEM”（Windows could not start because the following file is missing or corrupt: \WINDOWS\SYSTEM32\CONFIG\­SYSTEM）。</p><p><img src="/images/windows_common_boot_problems/5.png"></p><p>成因：包含系统引导启动所需的配置文件的注册表文件损坏或被删除。</p><p>修复：开机进入windows恢复环境（windows recovery environment），选择“命令提示符（Command Prompt）”选项，之后运行“chkdsk”命令。如果问题未被修复，就去获取系统注册表文件的备份。windows每隔12小时会把系统注册表文件备份到%SystemRoot%\System32\Config\RegBack路径下（先前的备份文件会被重命名，带有一个.old的扩展后缀名称），因此就可以复制该路径下的文件到%SystemRoot%\System32\Config文件夹中覆盖异常的注册表文件。<br>如果启用了系统恢复功能，用户可以从恢复点获取一个时间上更加接近当前时间的注册表备份文件，该文件包含system注册表文件。</p><h1 id="启动后崩溃或卡顿（Post–Splash-Screen-Crash-or-Hang）"><a href="#启动后崩溃或卡顿（Post–Splash-Screen-Crash-or-Hang）" class="headerlink" title="启动后崩溃或卡顿（Post–Splash Screen Crash or Hang）"></a>启动后崩溃或卡顿（Post–Splash Screen Crash or Hang）</h1><p>现象：windows启动界面展示，桌面出现或者用户成功登录后发生了异常，出现了蓝屏崩溃或卡顿，整个系统被冻结或者鼠标光标可以移动但是系统没有任何反应。</p><p>成因：这个问题通常是由设备驱动程序的异常引发，但是有时也可能是系统注册表文件（不是system注册表文件）的损坏引起。</p><p>修复：用户可以使用多种方法尝试修复该问题。首先可以尝试使用最后已知正确的配置文件。最后已知正确（LKG：Last known good）就是指最后一次成功引导启动系统的注册表控制集。因为控制集包含了核心系统配置、设备驱动程序和服务注册表数据库，因此使用该版本将不会受到新增系统更改或新安装的驱动或服务的影响，避免因这些问题产生的异常。用户也可以在引导启动过程中按下f8按键访问之前进入安全引导模式的相同菜单中，在这里选择使用最后已知正确的配置文件进行系统启动。</p><p>如果使用LKG配置文件启动系统，系统会保存用户拒绝的控制集，并为其添加失败（failed）控制集的标签。在使用后LKG配置文件成功启动系统后，用户也可以将成功启动的控制集与失败的控制集配置导出到.reg文件中，并进行比较以确定系统启动失败的原因。用户可以通过使用regedit的导出功能实现这一操作，可以参考如下的文件菜单操作：</p><p>（1）运行regedit打开注册表，选择HKLM\SYSTEM\CurrentControlSet路径；</p><p>（2）在file菜单中选择export，将控制集保存在一个自命名的good.reg后缀的文件中；</p><p>（3）打开HKLM\SYSTEM\Select路径，读取failed的值xxx，选择名称为HKLM\SYSTEM\Controlxxx的子健；</p><p>（4）将控制集配置导出到名为bad.reg的文件中；</p><p>（5）使用WordPad程序把good.reg中的全部CurrentControlSet实例全局替换为ControlSet；</p><p>（6）使用WordPad程序把bad.reg中的全部Controlxxx实例全局替换为ControlSet；</p><p>（7）运行支持工具Windiff比较两个文件；</p><p>failed控制集和正常控制集可能会存在多处不同，因此用户需要把检查集中在control子键、驱动的parameters子键和services子键中注册的服务上。忽略控制集的services分支中的驱动注册表的enum子键的更改。</p><p>如果问题是上次成功启动前就已存在的驱动程序或服务造成的，那么lkg也无法成功启动系统。与之类似，如果控制集外存在异常配置设置或者在上次成功启动前问题就已存在，那么lkg也不会起作用。在这种情况下，下一步就是尝试安全模式启动。如果系统成功在安全模式下启动，就可以确认是特定的驱动程序造成了系统启动失败，用户可以通过使用设备管理器禁用设备驱动程序。可以通过选择异常驱动并从action菜单选择disable操作实现。如果用户最近更新了驱动程序，可以认为是更新引入了异常，用户可以在设备管理器中将对应的驱动程序回滚到先前版本。双击对应设备打开起属性对话框，点击驱动标签页中的“Roll Back Driver”即可实现驱动回滚。</p><p>在启用了系统还原（System Restore）功能的系统中，如果lkg无法启动系统，可以将系统回滚到先前的时间点。安全模式会检查恢复点是否存在，如果存在就会询问用户是否登录到安装文件中进行人工检查或修复，或者直接加载系统还原（System Restore）向导程序。如果用户知道问题成因并想要自动修复，或者用户不知道问题成因但不想浪费过多时间调查原因，那使用系统还原（System Restore）使得系统恢复正常是十分有吸引力的。</p><p>如果系统还原不可用或者用户以安全模式成功启动系统后想要明确系统崩溃的成因，可以在不成功的开机启动时通过f8进入特殊的引导菜单并选择引导记录（boot logging）选项获取引导日志记录。会话管理器（%SystemRoot%\System32\Smss.exe）会把记录引导启动过程中系统加载与不加载的设备驱动程序的相关记录信息保存到%SystemRoot%\ntbtlog.txt文件中，因此会话管理器初始化完成后，如果发生了系统崩溃或卡顿，用户就可以获得对应的引导日志。当用户重启进入安全模式后，系统就会把新条目添加到现有的引导日志中。摘录指向异常开机与安全模式开机的相关信息，并保存在不同的文件中。删除那些包含“未加载驱动”（Did not load driver）的文本行，之后使用例如windiff之类的文本比较工具进行比较。逐一禁用那些正常启动中加载但是安全模式启动中未加载的驱动程序，直到系统可以成功开机启动。（之后重启启用那些与问题无关的驱动程序。）</p><p>如果用户无法获得正常开机时的引导日志（例如系统在会话管理器初始化前就崩溃）、如果系统在安全模式也发生崩溃或者正常模式和安全模式的启动日志对比未显示任何明显不同（例如造成启动异常的驱动程序在会话管理器初始化完成后才被加载启动），下一个工具就是驱动验证器与崩溃转储文件分析同时进行。</p><h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><p>（1）上述描述主要来自于对于《Windows Internals》第六版第13章《stratup and Shutdown》中《Solving Common Boot Problems》章节的翻译，读者可以查询对应的原文获取原版的相关描述；</p><p>（2）上述方法在当前虚拟化背景下有些不可用，最主要的就是云厂商在云环境下使用了特定驱动（例如virtio）的存储器，而winre中不包含对应的驱动文件，因此在引导开机异常进入winre后，winre因为驱动问题无法识别系统磁盘，自然也无法进行相关的修复动作；</p><p>（3）可以通过向winre中打入对应的驱动文件解决该问题（详细方法可以在网上搜索），但是云厂商驱动不一，且更新频率无法保证，而且会有修改系统原始文件的风险，基于这一点，可能很多用户不会选择修改winre原始文件的方法；</p><p>（4）其次就可以选择常见的winpe修复方法，制作专用的winpe，在其中可以添加所需的驱动程序，再使用winpe进行系统修复，winpe的制作方法网络上有很多资源，这里也不再赘述；</p><script src="https://utteranc.es/client.js" repo="bbbccvbvv/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;windows常见的启动问题包含以下类型：&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="Windows" scheme="https://bbbccvbvv.github.io/tags/Windows/"/>
    
    <category term="boot" scheme="https://bbbccvbvv.github.io/tags/boot/"/>
    
  </entry>
  
  <entry>
    <title>windows服务配置ErrorControl致使系统不断重启</title>
    <link href="https://bbbccvbvv.github.io/2024/12/12/20241212-windows_restart_by_service_errorcontrol/"/>
    <id>https://bbbccvbvv.github.io/2024/12/12/20241212-windows_restart_by_service_errorcontrol/</id>
    <published>2024-12-12T05:30:10.000Z</published>
    <updated>2024-12-12T07:16:59.706Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到了一个windows系统不断重启的问题，感到有些不知所措。后来其他同事发现了类似的问题，成功解决了异常的windows重启。现在就使用自己编写的程序尝试复现问题。</p><span id="more"></span><p>异常现象比较简单，启动windows系统后，系统处于设备准备或显示出登录界面后会不断重启。起初以为是文件系统损坏或注册表异常，但是挂载救援模式进行文件系统修复和使用备份注册表覆盖当前使用的注册表后仍然无法修复。后来参考网络资料，才知道是windows服务的ErrorControl配置异常产生的问题。详情可参考：<a href="https://cloud.tencent.com/developer/article/1853792%E3%80%82">https://cloud.tencent.com/developer/article/1853792。</a></p><p>从相关文档中可知，服务的ErrorControl设置为3后，在服务启动过程中如果出现异常造成服务启动失败，那么系统就会重启，然后使用上次的成功配置继续尝试启动。</p><p>这里首先生成一个异常的exe，该exe会触发除0异常，模拟服务启动过程中启动失败的场景。</p><pre><code>#include &lt;stdio.h&gt;int selfDivide(int val) &#123;    return 100 / val;&#125;int main() &#123;    for (int i = 10; i &gt; -1; --i) &#123;        printf(&quot;Result is %d.\n&quot;, selfDivide(i));    &#125;    return 0;&#125;</code></pre><p>然后在系统中将该exe注册为服务，并设置为开机自动启动。</p><pre><code>sc create testservice binpath= C:\divide_zero_error.exe type= own start= auto displayname= testservice</code></pre><p>可以看到在上述的创建服务代码中，并没有显式指定ErrorControl的配置值，该值在未显式指定的条件下被系统默认设置为了1。</p><p><img src="/images/windows_restart_by_service_errorcontrol/1.png"></p><p>此时如果不对其进行更改，直接重启系统，并不会发生不断重启的异常，只是可以在系统日志中看到，与testservice服务相关的异常记录项。</p><p><img src="/images/windows_restart_by_service_errorcontrol/2.png"></p><p>更改testservice服务的ErrorControl的配置值，将其改为3，再次重启系统。</p><p><img src="/images/windows_restart_by_service_errorcontrol/3.png"></p><p>这时就会触发不断重启的异常，挂载救援模式，查看系统日志，其内容如下：</p><p><img src="/images/windows_restart_by_service_errorcontrol/4.png"></p><p>在该日志中无法看到不断重启时的相关事件记录，但能看到异常发生前的系统异常事件记录。</p><p><img src="/images/windows_restart_by_service_errorcontrol/5.png"></p><p>此时加载注册表进行查看，看到注册表中存在controlset1和controlset2两个控制集，当前默认选择的控制集是1.</p><p><img src="/images/windows_restart_by_service_errorcontrol/6.png"></p><p>将当前的控制集改为2，解除救援模式，系统可以正常启动。</p><p><img src="/images/windows_restart_by_service_errorcontrol/7.png"></p><p>此时正常进入系统，查看currentcontrolset中testservice服务的ErrorControl的配置值，如果是3（不是则改为3），重启系统会再次发生不断重启事件。</p><p><img src="/images/windows_restart_by_service_errorcontrol/8.png"></p><p>再次挂载救援模式，查看注册表相关配置。可以看到增加了currentcontrolset3，currentcontrolset1消失，这个也可以作为该问题的一个佐证。</p><p><img src="/images/windows_restart_by_service_errorcontrol/9.png"></p><p>因此在遇到相同问题时，可以从正常启动时服务启动失败的相关系统日志中查看对应的服务项，并修改ErrorControl配置项进行修复。</p><p>备注：服务启动类型改为禁用存在被其他程序拉起的可能性，因此直接修改ErrorControl配置项较好。</p><script src="https://utteranc.es/client.js" repo="bbbccvbvv/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近遇到了一个windows系统不断重启的问题，感到有些不知所措。后来其他同事发现了类似的问题，成功解决了异常的windows重启。现在就使用自己编写的程序尝试复现问题。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="Windows" scheme="https://bbbccvbvv.github.io/tags/Windows/"/>
    
    <category term="service" scheme="https://bbbccvbvv.github.io/tags/service/"/>
    
    <category term="ErrorControl" scheme="https://bbbccvbvv.github.io/tags/ErrorControl/"/>
    
  </entry>
  
  <entry>
    <title>获取windows多签名文件的签名信息</title>
    <link href="https://bbbccvbvv.github.io/2024/11/22/20241122-windows_get_file_multi_sign/"/>
    <id>https://bbbccvbvv.github.io/2024/11/22/20241122-windows_get_file_multi_sign/</id>
    <published>2024-11-22T10:46:10.000Z</published>
    <updated>2024-11-22T08:24:13.733Z</updated>
    
    <content type="html"><![CDATA[<p>在windows系统下进行开发工作时，往往会遇到文件的检验操作，需要检查文件是否合法。这时通过检查文件的签名是一个有效的方法，但是也会遇到文件包含多个签名信息，这时使用通常的powershell就会遇到难题，因为powershell上相关指令只能显示出一个签名信息，多余的签名无法显示，本文针对这一问题进行阐述。</p><span id="more"></span><p>以阿里的云服务器的网络驱动netkvm为例，从驱动的属性信息来看，可以得知该驱动包含3个签名信息，分别为：</p><p>表1</p><table><thead><tr><th align="center">index</th><th align="center">subject</th><th align="center">serial</th><th align="center">thumbprint</th><th align="center">digestAlgorithm</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">Alibaba Cloud Computing Co., Ltd.</td><td align="center">09c730c35c9f41a1018acf4c8906d490</td><td align="center">4484ba511350dfa6adb00cc720496e54877f6042</td><td align="center">sha1</td></tr><tr><td align="center">2</td><td align="center">Microsoft Windows Hardware Compatibility Publisher</td><td align="center">3300000062f45cf99e58a96a89000000000062</td><td align="center">fac666005546d6be881a31c1267717879401a950</td><td align="center">sha256</td></tr><tr><td align="center">3</td><td align="center">Alibaba Cloud Computing Co., Ltd.</td><td align="center">09c730c35c9f41a1018acf4c8906d490</td><td align="center">4484ba511350dfa6adb00cc720496e54877f6042</td><td align="center">sha256</td></tr></tbody></table><p><img src="/images/windows_get_file_multi_sign/1.png"></p><p>查看windows文件签名最简单的办法就是直接使用powershell的Get-AuthenticodeSignature指令，但是使用该指令查看基于上述多签名的netkvm文件签名信息，只得到了一个序列号为“3300000062F45CF99E58A96A89000000000062”的签名信息，即表1中的第2条信息，并没有找到其他两条签名的信息，与预期不符。</p><p><img src="/images/windows_get_file_multi_sign/2.png"></p><p>后续继续查找资料，发现了一个开源项目（<a href="https://github.com/leeqwind/PESignAnalyzer%EF%BC%89%E6%94%AF%E6%8C%81%E8%AF%A5%E5%8A%9F%E8%83%BD%EF%BC%8C%E5%88%A9%E7%94%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E8%87%AA%E5%B8%A6%E7%9A%84%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E7%AD%BE%E5%90%8D%E6%9F%A5%E6%89%BE%EF%BC%8C%E5%BE%97%E5%88%B0%E4%BA%86%E4%B8%A4%E6%9D%A1%E7%AD%BE%E5%90%8D%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%88%86%E5%88%AB%E5%AF%B9%E5%BA%94%E8%A1%A81%E4%B8%AD%E7%9A%84%E7%AC%AC1%E6%9D%A1%E5%92%8C%E7%AC%AC2%E6%9D%A1%E7%AD%BE%E5%90%8D%E4%BF%A1%E6%81%AF%E3%80%82">https://github.com/leeqwind/PESignAnalyzer）支持该功能，利用项目中自带的文件进行签名查找，得到了两条签名信息，分别对应表1中的第1条和第2条签名信息。</a></p><p><img src="/images/windows_get_file_multi_sign/3.png"></p><p><img src="/images/windows_get_file_multi_sign/4.png"></p><p>该项目使用CryptQueryObject函数对文件的签名信息进行查询，关于该函数的详情可以参考微软官方链接：<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/wincrypt/nf-wincrypt-cryptqueryobject%E3%80%82">https://learn.microsoft.com/zh-cn/windows/win32/api/wincrypt/nf-wincrypt-cryptqueryobject。</a></p><p>但是该工具显示的信息仍然不全，3个签名只显示了两个，继续查找方法，发现了微软提供的签名工具signtool（<a href="https://learn.microsoft.com/zh-cn/dotnet/framework/tools/signtool-exe%EF%BC%89%E3%80%82%E8%AF%A5%E5%B7%A5%E5%85%B7%E6%97%A2%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E7%AD%BE%E5%90%8D%E6%96%87%E4%BB%B6%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E6%9F%A5%E8%AF%A2%E5%B9%B6%E6%A0%A1%E9%AA%8C%E6%96%87%E4%BB%B6%E7%9A%84%E7%AD%BE%E5%90%8D%E4%BF%A1%E6%81%AF%E3%80%82">https://learn.microsoft.com/zh-cn/dotnet/framework/tools/signtool-exe）。该工具既可以用来签名文件，也可以用来查询并校验文件的签名信息。</a></p><p><img src="/images/windows_get_file_multi_sign/5.png"></p><p><img src="/images/windows_get_file_multi_sign/6.png"></p><p><img src="/images/windows_get_file_multi_sign/7.png"></p><script src="https://utteranc.es/client.js" repo="bbbccvbvv/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;在windows系统下进行开发工作时，往往会遇到文件的检验操作，需要检查文件是否合法。这时通过检查文件的签名是一个有效的方法，但是也会遇到文件包含多个签名信息，这时使用通常的powershell就会遇到难题，因为powershell上相关指令只能显示出一个签名信息，多余的签名无法显示，本文针对这一问题进行阐述。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="Windows" scheme="https://bbbccvbvv.github.io/tags/Windows/"/>
    
    <category term="multi-signed" scheme="https://bbbccvbvv.github.io/tags/multi-signed/"/>
    
  </entry>
  
  <entry>
    <title>因磁盘空间变化引发的windows虚拟内存机制分析验证</title>
    <link href="https://bbbccvbvv.github.io/2024/11/04/20241104-windows_virtual_memory_experiment/"/>
    <id>https://bbbccvbvv.github.io/2024/11/04/20241104-windows_virtual_memory_experiment/</id>
    <published>2024-11-04T12:56:10.000Z</published>
    <updated>2024-11-07T07:57:49.732Z</updated>
    
    <content type="html"><![CDATA[<p>在工单处理过程中，遇到了一起异常事件，客户在虚拟机重启后发现业务文件丢失（对应文件夹内仅保留了一个dll文件，其他文件被删除），而且重启后系统的磁盘空间增加，因此客户怀疑windows系统或者存储存在问题。后经过分析，发现客户的虚拟机在重启前存在很高的内存压力，在系统日志中可以发现虚拟内存不足的警告事件，因此认为：</p><span id="more"></span><p>（1）业务文件丢失应为被删除的原因，怀疑是使用者操作时误删，dll因为被使用所以无法删除被保留，其他的文件被删除，而由于所需的其他文件已经被加载到内存，系统业务仍然正常运行；</p><p>（2）windows重启后磁盘可用空间增加是windows虚拟机内存机制，在内存负载较高时主动占用多余的磁盘空间供内存使用，重启后对应磁盘空间被释放，因此造成重启后磁盘可用空间增加；</p><p>现在针对第二点进行windows虚拟内存机制的验证。</p><h1 id="验证流程"><a href="#验证流程" class="headerlink" title="验证流程"></a>验证流程</h1><h2 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h2><p>初始状态下，D盘保存有分页文件（大小为17G），虚拟机的总计可提交内存为33G（符合预期，物理内存16G+分页文件17G）。</p><p>此时已提交内存大小为8.2g，可提交内存大小为33g，d盘的可用空间为187.1g，分页文件大小为17G</p><p><img src="/images/windows_virtual_memory_experiment/1.png"></p><p><img src="/images/windows_virtual_memory_experiment/2.png"></p><h2 id="申请大量内存"><a href="#申请大量内存" class="headerlink" title="申请大量内存"></a>申请大量内存</h2><p>进行内存压测，申请40G的内存</p><p>此时已提交内存大小为47g，可提交内存大小为53g，d盘的可用空间为166.27g，分页文件大小为36G</p><p>备注：进程进行内存申请时，一般使用malloc相关函数，申请后虽然可以看到已提交内存增大，但是实际上系统并未在此时实际分配，只有在业务使用memset等函数对内存进行写入时，内存才会被真正分配，在测试时需要注意这一点。</p><p><img src="/images/windows_virtual_memory_experiment/3.png"></p><p><img src="/images/windows_virtual_memory_experiment/4.png"></p><h2 id="释放申请内存"><a href="#释放申请内存" class="headerlink" title="释放申请内存"></a>释放申请内存</h2><p>将申请的40g内存释放</p><p>此时已提交内存大小为6.7g，可提交内存大小为38.2g，d盘的可用空间为181.87g，分页文件大小为22.2G</p><p>备注：everything的文件大小显示异常，分页文件实际大小可通过文件属性页获得。</p><p><img src="/images/windows_virtual_memory_experiment/5.png"></p><p><img src="/images/windows_virtual_memory_experiment/6.png"></p><h1 id="验证结论"><a href="#验证结论" class="headerlink" title="验证结论"></a>验证结论</h1><table><thead><tr><th>时间</th><th>已提交内存</th><th>可提交内存</th><th>分页文件大小</th><th>分页文件磁盘分区可用容量</th></tr></thead><tbody><tr><td>初始</td><td>8.2（0）</td><td>33（0）</td><td>17（0）</td><td>187.1（0）</td></tr><tr><td>申请40g内存</td><td>47（+38.8）</td><td>53（+20）</td><td>36（+19）</td><td>166.27（-20.83）</td></tr><tr><td>释放40g内存</td><td>6.7（-1.5）</td><td>38.2（+5.2）</td><td>22.2（+5.2）</td><td>181.87（-5.23）</td></tr></tbody></table><p>根据上述测试可知：</p><p>（1）在用户使用内存超过windows的可提交内存后，如果情况允许（分页文件所处的磁盘中存在可用空间），那么windows系统会对分页文件进行扩容进而增大windows的可提交内存（示例中的可提交内存总量从33g增加到了53g），而与此同时d盘的可用空间减小了20g左右，其数值与windows可用内存的增加值正好符合。因此可以认为windows在适当的情况下（内存负载过高可提交内存不足、分页文件设置允许进行扩容、分页文件所处磁盘分区存在剩余空间可供扩容使用），会自动使用磁盘空间作为虚拟机内存以供程序使用，直观表现为可提交内存与分页文件增加，磁盘分区可用空间减小，增加与减小的容量大致相同；</p><p>（2）在内存使用高峰过去后，windows会对之前的分页文件进行缩容操作，释放之前分配的过多磁盘空间，但是不一定会完全恢复到初始状态；</p><p>（3）windows基于分页文件的虚拟内存机制看起来比其他系统的固定大小的交互分区更为灵活，因此非专业人士不建议手动修改分页文件的相关设置，使用windows的默认配置策略即可；</p><p>（4）因为windows基于分页文件的虚拟内存机制，因此如果想在不增加物理内存的情况下改善系统内存使用情况，建议可以将分页文件设置在存储性能较高的磁盘上（例如选择ssd而非hhd磁盘分区存储分页文件），并在对应的磁盘分区上保留足够的磁盘空间，使得系统可以在内存负载较高时使用磁盘空间满足业务需求；</p><script src="https://utteranc.es/client.js" repo="bbbccvbvv/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;在工单处理过程中，遇到了一起异常事件，客户在虚拟机重启后发现业务文件丢失（对应文件夹内仅保留了一个dll文件，其他文件被删除），而且重启后系统的磁盘空间增加，因此客户怀疑windows系统或者存储存在问题。后经过分析，发现客户的虚拟机在重启前存在很高的内存压力，在系统日志中可以发现虚拟内存不足的警告事件，因此认为：&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="windows" scheme="https://bbbccvbvv.github.io/tags/windows/"/>
    
    <category term="虚拟内存" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
    <category term="分页文件" scheme="https://bbbccvbvv.github.io/tags/%E5%88%86%E9%A1%B5%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>windows系统内存参数分析</title>
    <link href="https://bbbccvbvv.github.io/2024/11/01/20241101-windows_memory_para_analyze/"/>
    <id>https://bbbccvbvv.github.io/2024/11/01/20241101-windows_memory_para_analyze/</id>
    <published>2024-11-01T10:56:10.000Z</published>
    <updated>2024-11-07T07:57:40.445Z</updated>
    
    <content type="html"><![CDATA[<p>现代操作系统普遍采用了虚拟机内存机制以扩展用户或程序可使用的最大内存值，但是不同的系统有不同的内存管理机制，因此适用于某一系统的术语在另一系统上可能并不是同一概念。本文旨在对于windows系统中内存相关的参数进行解析，使得使用者可以对于windows的内存相关参数有一个清晰的理解。</p><span id="more"></span><p>在windows系统中，内存的相关数据可以通过以下四种方法查看：</p><p>（1）任务管理器；</p><p>（2）资源监视器；</p><p>（3）systeminfo；</p><p>（4）procexp；</p><p>下面分别介绍在这四种方法中看到的内存各项参数的具体含义：</p><h1 id="任务管理器内存参数"><a href="#任务管理器内存参数" class="headerlink" title="任务管理器内存参数"></a>任务管理器内存参数</h1><p>一般对windows系统当前运行情况进行查看时，任务管理器都是第一选择。在任务管理器的性能界面上，可以选择内存进行系统内存信息的查看。</p><p><img src="/images/windows_memory_para_analyze/1.png"></p><p>自上而下对相关参数进行介绍：</p><p>（1）内存：16GB</p><p>实际的物理内存，在真实物理机中，就是主板上内存插槽中全部内存条的总容量，在虚拟机中，就是创建虚拟机时配置的内存大小。在系统运行过程中，该参数一般不会发生改变。但是虚拟机具有动态调整内存的功能，因此实际上虚拟机中的该参数是会发生变化的。</p><p>（2）使用中（已压缩）：7.5GB（470MB）</p><p>当前正在被操作系统和正在运行的程序使用的物理内存。包括已分配但是未必正在活跃使用的内存。<br>出现的”已压缩”字样，它指的是操作系统对内存页进行了压缩。这是一种操作系统级别的优化技术，旨在减少内存使用量并提高系统性能。<br>内存压缩通常在系统资源紧张时才会被启用，并且操作系统会根据系统负载和内存需求来自动调整内存压缩的程度。在正常情况下，内存压缩对大多数用户和应用程序不会产生明显的性能下降。然而，在某些情况下，例如对于特定的高性能应用程序或需要大量内存带宽的工作负载，可能会出现轻微的性能影响。</p><pre><code>#关闭内存压缩，重启生效Disable-MMAgent -mc#开启内存压缩，重启生效Enable-MMAgent -mc#查看当前内存压缩状态Get-mmagent </code></pre><p>（3）可用：8.4GB</p><p>表示当前操作系统可用于分配给新进程或应用程序的物理内存，可用内存是系统当前未被使用的内存。<br>初次看到这个参数，可能有的用户会产生一种错觉：只要可用内存不为0，则计算机当前运行情况良好。这种观点是不正确的，windows系统内存的占用关键是看已提交内存的使用率，而可用内存仅代表内存当前未被使用，不代表内存未被分配出去。而这部分内存可被其他进程使用的前提是可以被置换到磁盘上的分页文件中，如果分页文件已满，则这些内存也无法被其他进程使用。</p><p>（4）为硬件保留的内存：0.5MB</p><p>表示由硬件设备保留的物理内存，通常由系统BIOS或UEFI分配。<br>物理内存&#x3D;使用中内存 + 可用内存 + 为硬件保留的内存；</p><p>（5）已提交：9.8&#x2F;33.0GB</p><p>表示已分配的物理内存和虚拟内存的总和，已提交的内存包括当前正在使用的内存和保留的内存空间。<br>左边（9.8G）：当前运行的所有程序总共已经向操作系统申请的内存空间<br>右边（33G）：当前运行的所有程序总共可以向操作系统申请的内存空间</p><p>（6）已缓存：8.4GB</p><p>显示文件系统缓存占用的物理内存。文件系统缓存有助于提高文件访问速度，缓存最近访问过的文件。</p><p>（7）分页缓冲池：770MB</p><p>内核使用的内存池，存储可以交换到磁盘的数据。</p><p>（8）非分页缓冲池：810MB</p><p>内核使用的内存池，存储不可以交换到磁盘的数据。</p><h1 id="资源监视器内存参数"><a href="#资源监视器内存参数" class="headerlink" title="资源监视器内存参数"></a>资源监视器内存参数</h1><p><img src="/images/windows_memory_para_analyze/2.png"></p><h2 id="进程内存参数"><a href="#进程内存参数" class="headerlink" title="进程内存参数"></a>进程内存参数</h2><p>（1）提交：表示已经被分配给进程和系统使用的虚拟内存大小。已提交内存包括物理内存（RAM）和交换文件（Pagefile）中的空间，用于存储进程的代码、数据以及操作系统的内核数据。</p><p>（2）工作集：进程所占用的总物理内存。但是这个值是由两部分组成, 即 专用工作集 （即专用内存）+ 共享工作集（即可共享内存）；</p><p>（3）可共享：该进程和别的进程共享的内存量；</p><p>（4）专用：进程独占的物理内存；</p><pre><code>（1）工作集，即在物理内存中的数据的集合；（2）工作集 = 专用内存 + 共享内存；（3）将所有的 &quot;工作集&quot; 相加后的值会大于任务管理器中内存占用的百分比，因为百分比对共享内存进行排重了，即共享内存会在不同进程中被重复计算；（4）&quot;提交大小&quot; 和 &quot;工作集&quot; 是两个层面的概念，大部分活跃进程的 &quot;工作集&quot; 会大于 &quot;提交大小&quot;，而大部分非活跃的进程 &quot;工作集&quot; 会小于 &quot;提交大小&quot;，但是两者没有绝对关系；</code></pre><h2 id="物理内存参数"><a href="#物理内存参数" class="headerlink" title="物理内存参数"></a>物理内存参数</h2><p>物理内存大小为16G，内部分为了以下几个部分：</p><p>（1）为硬件保留的内存（1MB）：专门为硬件（如显卡、BIOS等）保留的内存，通常在系统启动时由硬件设备直接占用，用户无法访问。</p><p>（2）正在使用（7732MB）：当前正在被操作系统和正在运行的程序使用的物理内存；</p><p>（3）已修改（20MB）：被修改的内存页，但是修改并未写回到磁盘，写回操作完成后这部分内存才能用于其他用途；</p><p>（4）备用（8614MB）：包含未使用的缓存数据和代码的内存；</p><p>（5）可用（17MB）：不包含任何有价值数据，以及当进程、驱动程序、操作系统需要更多的内存时优先使用的内存；</p><p>实际上的可用内存（8631MB）&#x3D; 备用内存（8614MB）+ 可用内存（17MB），而当系统内存负载过高时，也可以看到可用内存急剧减少。</p><p>缓存：当文件被打开时，系统会把文件保存在缓存中，方便下次迅速读写。Windows 2008 R2及以后版本，对这个缓存的使用也做了限制，有一部分物理内存不会被缓存使用，保证系统即使在缓存过大的时候，也有可用物理内存，满足程序使用需求。</p><h1 id="systeminfo内存参数"><a href="#systeminfo内存参数" class="headerlink" title="systeminfo内存参数"></a>systeminfo内存参数</h1><p><img src="/images/windows_memory_para_analyze/3.png"></p><p>（1）Total Physical Memory：16383MB</p><p>对应任务管理器中的总物理内存，即实际的物理内存。在真实物理机中，就是主板上内存插槽中全部内存条的总容量。</p><p>（2）Available Physical Memory：8634MB</p><p>对应任务管理器中的可用内存，表示当前操作系统可用于分配给新进程或应用程序的物理内存，可用内存是系统当前未被使用的内存。</p><p>（3）Virtual Memory：Max Size：33791MB</p><p>对应任务管理器中的可提交内存，表示已分配的物理内存和虚拟内存的总和。</p><p>（4）Virtual Memory：Available：23778MB</p><p>可提交内存与已提交内存之差，表示当前运行的所有程序还可以向操作系统申请的内存空间。</p><p>（5）Virtual Memory：In Use：10013MB</p><p>对应任务管理器中的已提交内存，表示当前运行的所有程序总共已经向操作系统申请的内存空间。</p><p>（6）Page File Location</p><p>分页文件的位置，windows通过分页文件机制提供了远超物理内存大小的虚拟机内存。<br>如下图所示，在windows系统的高级设置-性能选项中可以修改分页文件的设置（文件位置及文件大小）。名称虚拟内存是一个不太准确的标题，忽略即可。</p><p><img src="/images/windows_memory_para_analyze/4.png"></p><h1 id="procexp内存参数"><a href="#procexp内存参数" class="headerlink" title="procexp内存参数"></a>procexp内存参数</h1><p><img src="/images/windows_memory_para_analyze/5.png"></p><p>procexp显示相比较上述的途径更加全面，主要包含提交内存、物理内存、内核内存（分页缓冲池和非分页缓冲池），相关参数都已经在前面有过介绍，这里不再赘述。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>（1）决定windows系统当前真实内存负载的参数是任务管理器界面的已提交内存，该数值越大，代表系统内部当前各项进程申请的内存资源越多，如果已提交内存远大于真实物理内存，代表一大部分文件被置换到了分页文件中，进行进程切换时可能会有卡断发生；</p><p>（2）资源监视器的物理内存参数真实反应了系统当前物理内存的分配使用情况，该界面的可用内存（备用+可用）越小，代表此时系统的内存压力越大；</p><p>（3）反应进程真实物理内存使用的是其工作集，尤其是工作集中的专用内存，这部分内存表示该进程独占的物理内存，在系统内存压力过大时，可以手动关闭专用内存占用较多的进程；</p><p>（4）驱动有时也会发生内存泄漏，但是相关信息无法通过上述的工具看到，这时可以使用微软提供的poolmon工具进行分析，使用方法可在网络进行搜索；</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://learn.microsoft.com/zh-cn/troubleshoot/windows-client/performance/introduction-to-the-page-file">https://learn.microsoft.com/zh-cn/troubleshoot/windows-client/performance/introduction-to-the-page-file</a><br><a href="https://answers.microsoft.com/zh-hans/windows/forum/all/windows/e1a6c144-26e1-4c1a-af27-c5c90fd60308?page=2">https://answers.microsoft.com/zh-hans/windows/forum/all/windows/e1a6c144-26e1-4c1a-af27-c5c90fd60308?page=2</a><br><a href="https://blog.51cto.com/markwin/91907">https://blog.51cto.com/markwin/91907</a><br><a href="https://cloud.tencent.com/developer/article/1924864">https://cloud.tencent.com/developer/article/1924864</a><br><a href="https://www.pcoic.com/system/windows/4785.html">https://www.pcoic.com/system/windows/4785.html</a><br><a href="https://docs.freebsd.org/en/articles/vm-design/#allen-briggs-qa">https://docs.freebsd.org/en/articles/vm-design/#allen-briggs-qa</a><br><a href="https://www.itprotoday.com/cloud-computing/the-memory-optimization-hoax">https://www.itprotoday.com/cloud-computing/the-memory-optimization-hoax</a><br><a href="https://www.zhihu.com/question/43714216/answer/1164044678">https://www.zhihu.com/question/43714216/answer/1164044678</a><br><a href="https://github.com/cw1997/memory-allocation-test">https://github.com/cw1997/memory-allocation-test</a><br><a href="https://www.cnblogs.com/oboth-zl/p/17168468.html">https://www.cnblogs.com/oboth-zl/p/17168468.html</a></p><script src="https://utteranc.es/client.js" repo="bbbccvbvv/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;现代操作系统普遍采用了虚拟机内存机制以扩展用户或程序可使用的最大内存值，但是不同的系统有不同的内存管理机制，因此适用于某一系统的术语在另一系统上可能并不是同一概念。本文旨在对于windows系统中内存相关的参数进行解析，使得使用者可以对于windows的内存相关参数有一个清晰的理解。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="windows" scheme="https://bbbccvbvv.github.io/tags/windows/"/>
    
    <category term="内存" scheme="https://bbbccvbvv.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>windows救援模式下设置完全内存转储</title>
    <link href="https://bbbccvbvv.github.io/2024/10/23/20241023-windows_set_full_memory_dump_in_rescue/"/>
    <id>https://bbbccvbvv.github.io/2024/10/23/20241023-windows_set_full_memory_dump_in_rescue/</id>
    <published>2024-10-23T10:56:10.000Z</published>
    <updated>2024-11-07T07:57:26.590Z</updated>
    
    <content type="html"><![CDATA[<p>在windows系统遇到异常时，往往会触发自带的异常转储机制，将问题现场进行保存，方便事后使用对应的dmp文件进行分析。但是系统默认的设置为核心内存转储，即只转储问题时刻的部分关键内存信息，但是系统的判断并不总是正确的，因此很可能便会造成dmp因为部分关键内存信息没有被保存而无法精确定位问题。</p><span id="more"></span><p>尤其是在遇到开机相关的异常问题时，由于无法正常进入系统，因此只能依靠dmp进行分析。但是如果系统没有进行转储设置或者设置的不是完全内存转储，就会造成没有合适的dmp用来分析定位问题。这时如果能够修改为完全内存转储，再通过外部注入中断（例如kvm环境下的inject-nmi）主动触发转储机制，就可以获得比较完整的异常现场信息，以便进行问题定位分析。下面就介绍如何在救援模式下进行windows转储设置的相关修改：</p><p>（0）进入救援模式中，将问题windows的磁盘挂载到救援机上，异常机的系统盘会被分配一个盘符（根据救援机和异常机的磁盘挂载情况不同发生变化，在本次演示中，异常机的系统盘盘符为E）；</p><p>（1）打开windows注册表（regedit），选择HKEY_LOCAL_MACHINE条目（dump相关信息保存在该条目下，因此选择将异常机的注册表也挂载在该条目下）：</p><p><img src="/images/windows_set_full_memory_dump_in_rescue/1.png"></p><p>（2）点击文件（file），选择加载配置单元（load hive）；</p><p><img src="/images/windows_set_full_memory_dump_in_rescue/2.png"></p><p>（3）选择异常机的system注册表配置单元（异常机系统盘的windows\System32\config\SYSTEM文件，在本文中具体路径是E:\windows\System32\config\SYSTEM）；</p><p><img src="/images/windows_set_full_memory_dump_in_rescue/3.png"></p><p>（4）为加载的注册表配置单元起一个名称与其他注册表项进行区分（在本文中命名为aaa）；</p><p><img src="/images/windows_set_full_memory_dump_in_rescue/4.png"></p><p><img src="/images/windows_set_full_memory_dump_in_rescue/5.png"></p><p>（5）在虚拟机内可能存在多个controlset，因此需要在注册表中查找虚拟机启动时真实加载的controlset，查看aaa下的select注册表项（在本文中可以看到default默认值为1，代表系统启动时加载的是controlset001，因此修改controlset001，也可以对全部的controlset进行相同的改动）；</p><p><img src="/images/windows_set_full_memory_dump_in_rescue/6.png"></p><p><img src="/images/windows_set_full_memory_dump_in_rescue/7.png"></p><p>（6）修改aaa\ControlSet001\Control\CrashControl路径下的CrashControl，将其值改为1；</p><p><img src="/images/windows_set_full_memory_dump_in_rescue/8.png"></p><p>（7）修改aaa\ControlSet001\Control\SESSION MANAGER\MEMORY路径下的PagingFiles，将其值改为”C:\pagefile.sys 8600 8600”（配置的分页文件大小需要比内存大小要大，否则会转储失败，因为异常机的内存为8g，因此配置了8600，一般4g配置4300即可）（另外需保证异常机的系统盘可用空间不小于配置的分页文件大小，不然内存转储也会失败）；</p><p><img src="/images/windows_set_full_memory_dump_in_rescue/9.png"></p><p>这样配置修改就完成了，后续就可以通过主动触发中断的方式获取完全内存转储的dmp文件了。</p><script src="https://utteranc.es/client.js" repo="bbbccvbvv/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;在windows系统遇到异常时，往往会触发自带的异常转储机制，将问题现场进行保存，方便事后使用对应的dmp文件进行分析。但是系统默认的设置为核心内存转储，即只转储问题时刻的部分关键内存信息，但是系统的判断并不总是正确的，因此很可能便会造成dmp因为部分关键内存信息没有被保存而无法精确定位问题。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="windows" scheme="https://bbbccvbvv.github.io/tags/windows/"/>
    
    <category term="转储设置" scheme="https://bbbccvbvv.github.io/tags/%E8%BD%AC%E5%82%A8%E8%AE%BE%E7%BD%AE/"/>
    
    <category term="救援模式" scheme="https://bbbccvbvv.github.io/tags/%E6%95%91%E6%8F%B4%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>windbg手动添加非官方pdb文件进行调试</title>
    <link href="https://bbbccvbvv.github.io/2024/07/25/windbg_add_pdb_file_manually/"/>
    <id>https://bbbccvbvv.github.io/2024/07/25/windbg_add_pdb_file_manually/</id>
    <published>2024-07-25T13:33:20.000Z</published>
    <updated>2024-10-14T12:10:18.588Z</updated>
    
    <content type="html"><![CDATA[<p>在使用windbg分析windows产生的dmp异常转储文件时，常常需要使用到相关应用的pdb文件，否则就只能看到粗略的模块，却不能看到具体的函数执行内容。而微软的官方pdb服务器可以下载到windows相关的pdb文件，对于非官方的程序或驱动，就需要调试者自己去查找并进行设置。本文就如何在使用windbg调试dmp时，如何手动添加非官方的pdb文件进行描述，希望能够帮助遇到该问题的开发者。</p><span id="more"></span><p>笔者最近在分析一个dmp文件，从其stack中可以看到，异常发生时涉及到了一个第三方程序netkvm，查询资料发现这是一个开源的第三方网络驱动，主要用于虚拟机。由于初始时只有微软的相关pdb文件，因此在stack中只能看到netkvm的模块名称，却无法准确判断具体的异常函数。</p><p><img src="/images/windbg_add_pdb_file_manually/1.png"></p><p>因为netkvm是开源的驱动文件，因此很容易在社区中找到了所需的sys和pdb文件，但是直接将对应的文件放入到笔者设置的本地symbol路径下，并重新reload并没有效果，那么问题应该是文件路径不对，windbg没有识别相关的文件，因此需要获取windbg加载pdb的详细路径。</p><p>使用“.reload &#x2F;f netkvm.sys”指令尝试加载相关的模块，可以看到windbg异常输出如下：</p><p><img src="/images/windbg_add_pdb_file_manually/2.png"></p><p>从上述报错信息可以看到，windbg尝试从“d:\symbols\netkvm.sys\61A8F2E22e000”路径加载netkvm.sys文件，从“d:\symbols\netkvm.pdb\E2CD669467F24AFB9856B5AF63BB298B2”路径加载netkvm.pdb文件。因此解决方法也很简单，创建指定的文件目录，并把所需的文件放入到指定的路径下，并使用“.reload”指令重新加载pdb文件.</p><p><img src="/images/windbg_add_pdb_file_manually/3.png"></p><p>后查看stack，可以看到netkvm显示了具体的调用函数信息。</p><p><img src="/images/windbg_add_pdb_file_manually/4.png"></p><script src="https://utteranc.es/client.js" repo="bbbccvbvv/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;在使用windbg分析windows产生的dmp异常转储文件时，常常需要使用到相关应用的pdb文件，否则就只能看到粗略的模块，却不能看到具体的函数执行内容。而微软的官方pdb服务器可以下载到windows相关的pdb文件，对于非官方的程序或驱动，就需要调试者自己去查找并进行设置。本文就如何在使用windbg调试dmp时，如何手动添加非官方的pdb文件进行描述，希望能够帮助遇到该问题的开发者。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="windbg" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/windbg/"/>
    
    
    <category term="windows" scheme="https://bbbccvbvv.github.io/tags/windows/"/>
    
    <category term="windbg" scheme="https://bbbccvbvv.github.io/tags/windbg/"/>
    
    <category term="非官方pdb" scheme="https://bbbccvbvv.github.io/tags/%E9%9D%9E%E5%AE%98%E6%96%B9pdb/"/>
    
  </entry>
  
  <entry>
    <title>关于南宋权相现象的一些思考</title>
    <link href="https://bbbccvbvv.github.io/2024/02/27/south_song_leader-20240227/"/>
    <id>https://bbbccvbvv.github.io/2024/02/27/south_song_leader-20240227/</id>
    <published>2024-02-27T11:56:10.000Z</published>
    <updated>2024-02-27T11:57:02.946Z</updated>
    
    <content type="html"><![CDATA[<p>秦朝奠定了三公九卿制度，但先是西汉时，汉武帝建立内朝，剥夺了丞相的定策权利，转而以尚书主管负责内朝的实际运转。</p><span id="more"></span><p>再是东汉时以三公取代丞相的职权，甚至于不再设置丞相，将相权拆分为多份，而实际处理政务、发号施令的机构是尚书台，因此两汉权臣的标配是录尚书事。</p><p>三国时，蜀国丞相只有诸葛亮一人，后面的蒋费二人都没有获得丞相的官职，主要是以大将军身份处理朝政。而东吴的丞相一直存在，但是大多数情况下只是朝局发展的背景板。魏国则在尚书台机构之外，设立了中书监机构，剥夺了尚书的部分职权。</p><p>西晋大体维持了中书尚书和三公的权力架构，但是东晋迫于北方的严峻军事压力又设立了丞相一职，后来的南朝又新增了门下机构用以制衡中书机构。</p><p>隋唐一统天下，最终以三省六部取代三公九卿，完成了制度的又一变革，但是唐末的节度使制度崩坏，而文官的官职分离则是行政制度发展的又一趋势。</p><p>北宋统一了中原及南方后，对制度进行了修正，形成了东西府制度，即代表文官的中书门下和代表武官的枢密院，两院的首长都可以成为宰相。</p><p>由宋神宗和王安石推动的变法运动不仅是致力于政策的实施，同时修正了官制，使得官职分离的现象得到改善。而到了南宋，则出现了北宋从没有出现过的权相，这一现象的产生必然有其深刻的社会历史原因。</p><p>纵观之前的制度建设情况，丞相代表的是以官僚为主的行政权，而皇帝大部分情况下的皇权实质是军权，即皇帝代表的暴力机构与官僚的对抗是政治制度发展变化的主要原因。而之前对于相权的拆分与削弱也可以认为是皇帝代表的军权的衰弱，皇权弱了，如果不削弱对应的相权，那么可能又会出一个王莽了。这个制度在承平年代还能撑得住，换言之，大部分人无所谓其好与不好，只是没有新的出路，凑活着过罢了。但是这个制度一旦面临外部冲击，其自身是十分脆弱的，因为制度改革把大部分情况下不足以更新体制本身，只是隔靴搔痒罢了，更何况皇帝的个人素质大部分情况下连中人之姿都没有，维持一个强力的相权，难道不怕喧宾夺主吗？所以皇权和相权大部分情况下都是臭棋篓子下棋，越下越臭，两者一同衰弱。</p><p>衰弱的封建制度遇到了有活力的社会团体的冲击，自然要先被打个七零八落的。但是官僚制度既然存在必然有其存在的理由，秦皇汉武、唐宗宋祖都是在这个体制的支撑下才成就其事业的。外部冲击下，直观的表现就是战争失利，面临生死存亡的危机，皇帝与官僚也不得不放弃对于武将的压制，因此军队就首先在外部冲击之下变得高效起来，而军队的维持需要消耗物资，越高效的军队对于物资的消耗量也越大，这就要求有一个与之配套的组织生产的机构，即行政官僚。因此中国的历史大致就可以看作是，承平日久，军队和官僚一起摆烂，毕竟军队都烂了，官僚也没必要再保持那么高的行政效率。突遇危机，军队不得不高效，因此行政制度也随之高效运转，一些以前不能突破的禁区突破了，不敢动的规则变更了，整个社会在先军的目标下运行效率逐渐提升。</p><p>因此南宋的权相产生原因便是源于自北宋末年而来的来自于北方的强大军事压力，在这种情况下，往往会有一个所谓的中兴之主，重新驾驭高效的军事及行政机构，完成复兴，并再次衰落。但是很可惜，完颜构不是这样的人（有人辩解九妹比南明强多了，那我就说你都和南明比了，就顺从你吧）。即军事及行政机构复兴后，皇帝没有能力或不愿驾驭相关权力，但是权力天然就会集中，因此作为文官之首的丞相是驾驭这一权力的天然顺位继承人，这就是南宋出现这些权相的原因。</p><p>只是权相可以驾驭这些权力，但是却不具有大义的名分。因此看似权力虽大，但是始终无法突破体制的桎梏，在初期的辉煌之后只能落寞，在体制内缝缝补补。幸而北方的金朝也同步衰落，让其续命若干年，但是面临更加高效的蒙古体制的冲击，必然败下阵来。</p><p>有人说元朝的民族歧视政策，但是九妹的南宋也是有归正人与北人的说法的。纵观历史，宋朝军队只要皇帝不姓赵，其战斗力都是极为强大的，每思至此，免不得一声长叹。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;秦朝奠定了三公九卿制度，但先是西汉时，汉武帝建立内朝，剥夺了丞相的定策权利，转而以尚书主管负责内朝的实际运转。&lt;/p&gt;</summary>
    
    
    
    <category term="历史" scheme="https://bbbccvbvv.github.io/categories/%E5%8E%86%E5%8F%B2/"/>
    
    
    <category term="南宋权相" scheme="https://bbbccvbvv.github.io/tags/%E5%8D%97%E5%AE%8B%E6%9D%83%E7%9B%B8/"/>
    
    <category term="丞相制度" scheme="https://bbbccvbvv.github.io/tags/%E4%B8%9E%E7%9B%B8%E5%88%B6%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】windbg调试0xef异常（1）</title>
    <link href="https://bbbccvbvv.github.io/2024/02/05/windbg_0xef_debug_1/"/>
    <id>https://bbbccvbvv.github.io/2024/02/05/windbg_0xef_debug_1/</id>
    <published>2024-02-05T13:17:00.000Z</published>
    <updated>2024-02-05T13:23:21.938Z</updated>
    
    <content type="html"><![CDATA[<p>停止码0xEF出现的可能原因如下：</p><span id="more"></span>​<p>（1）硬件故障，尤其是内存和磁盘；</p><p>（2）安全软件例如杀毒软件；</p><p>（3）windows自身原因；</p><p>第一个原因是以上三个原因中最普遍的原因，尤其是加载到内存中的程序因为一些未处理的异常而中止自身运行是最典型的情况。之后造成操作系统突然panic并抛出0xEF停止码。另一方面，如果安全软件不信任二进制运行文件并中止其运行。如果对应的程序是critical关键进程（例如scvhost.exe），这会造成灾难性的后果。但是第二种情况较少出现。</p><p>然而，在这篇文章中，我将会将注意力集中到第三个原因上，当启动了影子栈shadow stack功能，并且监测到影子栈与调用栈间存在差异，windows系统会中止运行进程，并进而导致0xEF停止码被抛出。这也是我把windows自身作为0xEF异常产生原因的理由，尽管这种情况也有可能是因为异常的驱动程序或内存引起的。</p><p>如果启用了基于硬件的栈保护，处理器会保持两份调用栈的拷贝，第二份拷贝就是知名的影子栈。该栈旨在控制线程的运行流，如果任一栈的返回地址存在异常，则一个特殊的硬件异常被抛出进而造成进程被windows中止。</p><pre><code>CRITICAL_PROCESS_DIED (ef)        A critical system process diedArguments:Arg1: ffffaf08b56a90c0, Process object or thread objectArg2: 0000000000000000, If this is 0, a process died. If this is 1, a thread died.Arg3: 0000000000000000Arg4: 00000000000000003: kd&gt; knL# Child-SP          RetAddr               Call Site00 ffff8c0a`14b3ed38 fffff801`0ed0d122     nt!KeBugCheckEx01 ffff8c0a`14b3ed40 fffff801`0ec0c7a3     nt!PspCatchCriticalBreak+0x10e02 ffff8c0a`14b3ede0 fffff801`0ea99290     nt!PspTerminateAllThreads+0x17291703 ffff8c0a`14b3ee50 fffff801`0ea9908c     nt!PspTerminateProcess+0xe004 ffff8c0a`14b3ee90 fffff801`0e80f8f8     nt!NtTerminateProcess+0x9c &lt;&lt; Terminate our svchost.exe process which then bugchecks the system05 ffff8c0a`14b3ef00 fffff801`0e800ca0     nt!KiSystemServiceCopyEnd+0x2806 ffff8c0a`14b3f098 fffff801`0e860d9d     nt!KiServiceLinkage07 ffff8c0a`14b3f0a0 fffff801`0e8106a4     nt!KiDispatchException+0x17941d08 ffff8c0a`14b3f8e0 fffff801`0e80e03c     nt!KiFastFailDispatch+0xe409 ffff8c0a`14b3fac0 00007ffc`f18833c6     nt!KiControlProtectionFault+0x2fc &lt;&lt; Throws #CP (Control Protection) exception0a 0000002f`4637f820 000001b1`ae000340     ntdll!RtlpGetActivationContextData+0x520b 0000002f`4637f828 000001b1`ae002480     0x000001b1`ae0003400c 0000002f`4637f830 00000000`00000001     0x000001b1`ae0024800d 0000002f`4637f838 000001b1`000000f0     0x10e 0000002f`4637f840 00000000`00000002     0x000001b1`000000f00f 0000002f`4637f848 00000050`00000000     0x210 0000002f`4637f850 00000000`00000002     0x00000050`0000000011 0000002f`4637f858 00000000`000000f0     0x212 0000002f`4637f860 00000000`00000000     0xf0</code></pre><p>如果检查传递给nt!KiDispatchException函数的第一个参数，就可以看到抛出的异常类型信息。</p><pre><code>07 ffff8c0a14b3f0a0 fffff8010e8106a4 nt!KiDispatchException+17941d (perf)    Parameter[0] = ffff8c0a14b3fa18    Parameter[1] = 0000000000000000    Parameter[2] = ffffffffffffff80    Parameter[3] = 0000002f4637f8203: kd&gt; .exr ffff8c0a14b3fa18ExceptionAddress: 00007ffcf18833c6 (ntdll!RtlpGetActivationContextData+0x0000000000000052)ExceptionCode: c0000409 (Security check failure or stack buffer overrun)ExceptionFlags: 00000001NumberParameters: 1Parameter[0]: 0000000000000039Subcode: 0x39 FAST_FAIL_CONTROL_INVALID_RETURN_ADDRESS Shadow stack violation</code></pre><p>进一步检查异常，当启用了cet（Control-flow Enforcement Technology，控制流执行技术）时，运行调用指令，两个返回地址被压入栈：一个进入了调用栈，另一个进入影子栈。之后当返回指令运行时，会检查并比较两个返回地址，如果两个地址不匹配，则cp异常就会像之前提到的那样被抛出。但是cet仅在使用call调用指令时起作用，当使用压栈指令将地址压栈时，cet不起作用，因此影子栈中也不存在返回地址。考虑到这一点，推荐使用cfg保护的jmp跳转指令。cfg的行为与cet类似，如果发现了异常，则中止违规进程。如果进程是critical关键进程，抛出0xEF停止码。</p><p>参考链接：</p><p>1.<a href="https://techcommunity.microsoft.com/t5/windows-os-platform-blog/developer-guidance-for-hardware-enforced-stack-protection/ba-p/2163340%EF%BC%9B">https://techcommunity.microsoft.com/t5/windows-os-platform-blog/developer-guidance-for-hardware-enforced-stack-protection/ba-p/2163340；</a></p><p>2.<a href="https://learn.microsoft.com/en-us/windows/win32/secbp/control-flow-guard%EF%BC%9B">https://learn.microsoft.com/en-us/windows/win32/secbp/control-flow-guard；</a></p><p>原文链接：<a href="https://bsodtutorials.wordpress.com/2023/12/09/debugging-stop-0xef-critical_process_died/">https://bsodtutorials.wordpress.com/2023/12/09/debugging-stop-0xef-critical_process_died/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;停止码0xEF出现的可能原因如下：&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="windbg" scheme="https://bbbccvbvv.github.io/tags/windbg/"/>
    
    <category term="停止码0xEF" scheme="https://bbbccvbvv.github.io/tags/%E5%81%9C%E6%AD%A2%E7%A0%810xEF/"/>
    
    <category term="bsod" scheme="https://bbbccvbvv.github.io/tags/bsod/"/>
    
  </entry>
  
  <entry>
    <title>《矛盾论》与《实践论》读后感</title>
    <link href="https://bbbccvbvv.github.io/2024/01/23/on_contraction_on_practice/"/>
    <id>https://bbbccvbvv.github.io/2024/01/23/on_contraction_on_practice/</id>
    <published>2024-01-23T04:56:10.000Z</published>
    <updated>2024-01-23T08:09:06.282Z</updated>
    
    <content type="html"><![CDATA[<p>教员曾经说过：“上了大学，不想和工人划等号了，要作工人贵族。就是普通的工人农民每天也在进步。群众是真正的英雄，而我们却是幼稚可笑的，包括我。”。作为一个经历过大学教育的人，一时间竟不知道该如何自称，读书人或知识分子总感觉是臭老九之类的骂人的话，虽然想自称为劳动者，可是感觉又无法表现出来自己的一些特质（仔细想来除了大学好像也没有什么值得称道的特质了），看来自己还是比较虚伪的，还是需要自我检讨。</p><span id="more"></span><p>作为已经而立之年的90后，我这个人在家里人看来有些不省心，一没房，二没车，更不要说婚姻与家庭了，因此父母总是有些抱怨。本人在闲暇时间也是总在思考，自己当前的生活状态的原因是什么，推到自己的经历与性格肯定是主要原因，但是好像只讲自己的性格又有些片面。人是社会性的人，我自然与父母有不同的时代经历与三观，但是人要考虑自身，同时也需要来考虑其身处的时代。但是如果将一切都推给时代，又颇有些怨天尤人的无能狂怒，好像时代变化了就没有现在的这些问题了。这是有可能的，但是这又是不科学的，事物总在变化发展之中，旧的矛盾消失，新的矛盾出现，妄图通过某一项或多项的举动就能一劳永逸，这是不现实的。因此我就尝试从先哲的思想中学习相关的方法论，以期可以帮助分析自己现在遇到的问题，或者也可以说是逃到知识的海洋里以忘却现实的烦扰。但是需要记住，逃避只是一时，事情总会发展到你逃无可逃的地步，当你对自身有了一定的认知时，就需要结合理论进行实践，否则就只能是一个嘴强王者了。</p><p>选择《矛盾论》与《实践论》的主要原因是我很敬佩教员。90后的青年（貌似40还可以算作青年，我这也不算装嫩了）对于他的态度是不断变化的。就我个人而言，在我出生成长的年代，对于前三十年的否定是社会的主流意识形态，记得小时候看到的书及文章，有揭露cv黑暗的，有展示国军抗日功绩的，当时年少的我对于他的态度是很激烈的，37都不太认同，更是幻想要不是他，说不定提前30年就过上好日子了。仔细想来这种态度确实在我们那一代人里还是比较有市场的，具体问题具体分析、实事求是的态度很多成年人或大人物都无法做到，更何况我们这些小孩子呢。</p><p>孩子大多不具有辨别材料真伪的能力，因此社会的主流意识形态便会不自觉地占领孩子们的大脑，并在很长一段时间内产生影响。但是中国的教育又与其他国家存在区别，虽然中国的教育存在问题，但是像政治课这种统治阶级基础课却是义务教育阶段的必修课，这在其他国家还是很少见的。毕竟不是哪个统治阶级都乐意把血淋淋的现实呈现在人民面前，而人民也往往轻易的放弃了自己的权力，在青少年间普及政治教育更像是一项吃力不讨好的举动。对于统治阶级，人民中头脑清醒的人越多就越不好管，刁民就越多。而对于青少年，枯燥的知识远不如其他学科吸引人，更像是被灌输。可是有趣的是，青少年意识到自己被灌输，意识到自己被统治，这正是开设相关课程的目的所在。</p><p>对于我而言，初中时开设的政治课讲了一些阶级与国家的概念，印象最深的一句就是“国家是阶级统治的工具”，当时年少轻狂，觉得社会存在一些黑暗现象，因此这句话就十分符合个人胃口，可作为对于现实的控诉理由。当时学的阶级、国家、国家暴力机器等等观点，虽然是以灌输式的方法强行记下来的，但是这些观点却在以后的岁月里总是不断浮现，现实教育了自己这些观点的普遍性与泛用性。因此学生期间有多么厌恶思政，进入社会后就多么同意保留这些课程。</p><p>重读在这两篇文章后，突然发现其中的观点大部分都在大学的相关思政课上学过了，《矛盾论》的基本观点在教材上都有，而《实践论》则着重提了理性认识与感性认识，但是却缺失了社会实践的相关描述（也可能是我学的不好，忘记了）。我的学校是一所工科学校，我也是工科专业，本科生的思政课一直持续到了大三，当时的思政课老师我还有些印象，印象最深的自然是她给了我高分（虽然可能是我在之前的课堂活动上有些出风头，强辩而非专业辩论积累了一定的表现分），另外就是她说之前都是工科生治国，当时却有一个她的校友（我们学校隔壁）进入了长老团，因此这可能代表一些社会趋势的变化，但是现在看来变化也不是很大，不是每个文科生都能像教员那样的。</p><p>结合自身的一些经历，发现自己的社会实践主要是生产活动，其他的社会实践好像都没有参与，不知道写博客算不算是文学艺术创作，应该是不算的。而这个生产活动也只是雇佣劳动，并没有掌握生产资料，连高级打工仔都不算，就是底层的码农。7年的时间下来，对于资本主义雇佣劳动关系理解更深了，因此对于某些事物的态度也更为悲观了。不过脾气确实好了很多，也可以认为是被社会打平了棱角，但是总归来说都是自己的选择罢了。记得之前高中毕业时，曾经寄语：不要成为自己厌恶的那些人。可以说做到了，但是也没有成为自己想要成为的那些人，总归来说，还是一个不是那么坏的人，一个不给社会添麻烦的人。</p><p>现实不是文学创作，矛盾与知行的理论也不是教员首先提出，我记得道家就有过一句话：反者，道之动，与矛盾的变化发展观点就有着异曲同工之妙，而王阳明的知行合一也可以看作是认知与实践的一个很好的注解。但是正如后世的道家与心学无法深入贯彻先哲的学说，如今的我在读了教员的理论后，也不见得就可以立即拿来指导生活实践，但是我会努力朝着这个方向实践，分析自己，总结经验，争取成为一个真实的人，一个有用的人，一个热爱劳动的人，一个有益于人民的人。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;教员曾经说过：“上了大学，不想和工人划等号了，要作工人贵族。就是普通的工人农民每天也在进步。群众是真正的英雄，而我们却是幼稚可笑的，包括我。”。作为一个经历过大学教育的人，一时间竟不知道该如何自称，读书人或知识分子总感觉是臭老九之类的骂人的话，虽然想自称为劳动者，可是感觉又无法表现出来自己的一些特质（仔细想来除了大学好像也没有什么值得称道的特质了），看来自己还是比较虚伪的，还是需要自我检讨。&lt;/p&gt;</summary>
    
    
    
    <category term="哲学" scheme="https://bbbccvbvv.github.io/categories/%E5%93%B2%E5%AD%A6/"/>
    
    
    <category term="《矛盾论》" scheme="https://bbbccvbvv.github.io/tags/%E3%80%8A%E7%9F%9B%E7%9B%BE%E8%AE%BA%E3%80%8B/"/>
    
    <category term="《实践论》" scheme="https://bbbccvbvv.github.io/tags/%E3%80%8A%E5%AE%9E%E8%B7%B5%E8%AE%BA%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Windows系统tscon工具概述</title>
    <link href="https://bbbccvbvv.github.io/2023/12/22/windows_tool_tscon/"/>
    <id>https://bbbccvbvv.github.io/2023/12/22/windows_tool_tscon/</id>
    <published>2023-12-22T12:15:41.000Z</published>
    <updated>2024-01-02T13:04:15.607Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到了一个使用tscon工具解决windows远程链接断开后部分应用随之中断的案例，因此对tscon产生了一些好奇，这里就总结一下tscon工具的功能及使用方法。<br>在微软的官方文档上（<a href="https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/tscon">tscon</a>）可以看到该工具的一些描述，因此结合该文档对tscon工具进行描述。</p><span id="more"></span>​<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>该工具用来连接到远程桌面会话主机服务器上的另一个会话。<br>备注：必须拥有“完全控制”访问权限或“连接”特殊访问权限才能连接到另一个会话（即使用该工具的账号需具有较高的权限）</p><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p>Windows server服务器，即Windows Server 2022、Windows Server 2019、Windows Server 2016、Windows Server 2012 R2、Windows Server 2012。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><pre><code>tscon &#123;&lt;sessionID&gt; | &lt;sessionname&gt;&#125; [/dest:&lt;sessionname&gt;] [/password:&lt;pw&gt; | /password:*] [/v]</code></pre><p>参数详解如下：</p><ul><li><sessionID>：指定要连接到的会话的 ID。 如果你使用可选的 &#x2F;dest:<sessionname> 参数，则还可以指定当前会话的名称。</li><li><sessionname>：指定要连接到的会话的名称</li><li>&#x2F;dest:<sessionname>：指定当前会话的名称。 连接到新会话时，此会话将断开连接。 还可以使用此参数将其他用户的会话连接到一个不同的会话。</li><li>&#x2F;password:<pw>：指定拥有你要连接到的会话的用户的密码。 当进行连接的用户不拥有会话时，需要提供此密码。</li><li>&#x2F;password:*：提示输入拥有你要连接到的会话的用户的密码。</li><li>&#x2F;v：显示有关正在执行的操作的信息。</li><li>&#x2F;?：在命令提示符下显示帮助。</li></ul><p>备注：<br>（1）如果未在 &#x2F;password 参数中指定密码，并且目标会话属于当前用户以外的用户，则此命令将失败。<br>（2）你无法连接到控制台会话。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>（1）若要连接到当前远程桌面服务会话主机服务器上的会话 12，并断开当前会话的连接，请键入：</p><pre><code>tscon 12</code></pre><p>(2)若要使用密码 mypass 连接到当前远程桌面服务会话主机服务器上的会话 23，并断开当前会话的连接，请键入：</p><pre><code>tscon 23 /password:mypass</code></pre><p>（3）若要将名为 TERM03 的会话连接到名为 TERM05 的会话，然后断开会话 TERM05 的连接，请键入：</p><pre><code>tscon TERM03 /v /dest:TERM05</code></pre><h2 id="复杂脚本分析"><a href="#复杂脚本分析" class="headerlink" title="复杂脚本分析"></a>复杂脚本分析</h2><p>当使用远程桌面连接到远程计算机时，关闭远程桌面将会锁定计算机并显示登录界面，在锁定模式下，计算机不会有GUI图形界面，因此所有正在运行和即将调度的GUI任务都会失败。<br>为避免GUI任务失败，可以使用tscon组件实现从远程桌面断开连接，tscon会把控制权返还给远程计算机上的原始本地会话，这样就绕过了登录界面。远程计算机上的全部程序（包含GUI图形任务在内）都会继续正常运行。</p><pre><code>for /f &quot;skip=1 tokens=3&quot; %%s in (&#39;query user %USERNAME%&#39;) do (%windir%\System32\tscon.exe %%s /dest:console)</code></pre><p>该脚本的运行逻辑如下：<br>1.查询以用户名%USERNAME%登录的全部会话；<br>2.使用”skip&#x3D;1 tokens&#x3D;3”语法过滤掉查询结果的首行（标题行），并选取第3列（session ID）作为输出值；<br>3.遍历筛选过的全部会话id，使用tscon将会话的控制钱返还给计算机上的原始本地会话（console），依此实现断开连接，但是绕过登录界面，保持会话内的全部任务可以后续继续执行；</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>1.<a href="https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/tscon%EF%BC%9B">https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/tscon；</a><br>2.<a href="https://support.smartbear.com/testcomplete/docs/testing-with/running/via-rdp/keeping-computer-unlocked.html%EF%BC%9B">https://support.smartbear.com/testcomplete/docs/testing-with/running/via-rdp/keeping-computer-unlocked.html；</a><br>3.<a href="https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/for%EF%BC%9B">https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/for；</a><br>4.<a href="https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/query-user%EF%BC%9B">https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/query-user；</a><br>​</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近看到了一个使用tscon工具解决windows远程链接断开后部分应用随之中断的案例，因此对tscon产生了一些好奇，这里就总结一下tscon工具的功能及使用方法。&lt;br&gt;在微软的官方文档上（&lt;a href=&quot;https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/tscon&quot;&gt;tscon&lt;/a&gt;）可以看到该工具的一些描述，因此结合该文档对tscon工具进行描述。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="tscon" scheme="https://bbbccvbvv.github.io/tags/tscon/"/>
    
    <category term="windows会话" scheme="https://bbbccvbvv.github.io/tags/windows%E4%BC%9A%E8%AF%9D/"/>
    
    <category term="微软官方工具" scheme="https://bbbccvbvv.github.io/tags/%E5%BE%AE%E8%BD%AF%E5%AE%98%E6%96%B9%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>windbg标准调试技巧-读写内存（5）：将虚拟地址转换为物理地址</title>
    <link href="https://bbbccvbvv.github.io/2023/08/07/windbg_debug_technique_reading_and_writing_memory_5/"/>
    <id>https://bbbccvbvv.github.io/2023/08/07/windbg_debug_technique_reading_and_writing_memory_5/</id>
    <published>2023-08-07T10:30:00.000Z</published>
    <updated>2023-12-29T02:38:41.469Z</updated>
    
    <content type="html"><![CDATA[<p>大多数调试器命令都是用虚拟地址而非物理地址作为输出及输出参数。然而，也同时存在物理地址起作用的场景。</p><span id="more"></span><p>这里有两种方式将虚拟地址转换为物理地址：使用!vtop扩展或使用!pte扩展。</p><p>#1 使用!vtop进行地址转换</p><ol><li><p>确保在16禁止之下进行操作。如果必要的话，通过N 16指令设置当前环境为16进制；</p></li><li><p>确定地址的字节索引。该数字等同于虚拟地址的低12位。因此，虚拟地址0x0012f980的字节索引为0x980；</p></li><li><p>通过使用!process扩展确定地址的字典进制：</p><pre><code> kd&gt; !process 0 0 **** NT ACTIVE PROCESS DUMP **** .... PROCESS ff779190  SessionId: 0  Cid: 04fcPeb: 7ffdf000  ParentCid: 0394 DirBase: 098fd000  ObjectTable: e1646b30 TableSize:   8. Image: MyApp.exe</code></pre></li><li><p>决定目录基址的页框号。这只是没有三个尾随十六进制零的目录基址。在本例中，目录基址为0x098FD000，因此页框号为0x098FD。</p></li><li><p>使用!vtop扩展。该扩展的第一个参数是页框号。!vtop的第二个参数就是问题中的虚拟地址：</p><p> kd&gt; !vtop 98fd 12f980<br> Pdi 0 Pti 12f<br> 0012f980 09de9000 pfn(09de9)</p></li></ol><p>最后一行中展示的第二个数字是物理页的起始物理地址。</p><ol start="6"><li>在页的开始出加上地址的字节索引：0x09DE9000 + 0x980 &#x3D; 0x09DE9980。这就是目标物理地址。</li></ol><p>也可以通过显示每个地址的内存来验证此计算是否正确完成。!d*扩展显示指定物理地址处的内存：</p><pre><code>kd&gt; !dc 9de9980# 9de9980 6d206e49 726f6d65 00120079 0012f9f4 In memory.......# 9de9990 0012f9f8 77e57119 77e8e618 ffffffff .....q.w...w....# 9de99a0 77e727e0 77f6f13e 77f747e0 ffffffff .&#39;.w&gt;..w.G.w....# 9de99b0 .....</code></pre><p>d*（展示内存）质量使用虚拟地址作为其参数：</p><pre><code>kd&gt; dc 12f9800012f980  6d206e49 726f6d65 00120079 0012f9f4  In memory.......0012f990  0012f9f8 77e57119 77e8e618 ffffffff  .....q.w...w....0012f9a0  77e727e0 77f6f13e 77f747e0 ffffffff  .&#39;.w&gt;..w.G.w....0012f9b0  .....</code></pre><p>因为结果相同，这就表明物理地址0x09DE9980确实代表了虚拟地址0x0012F980。</p><p>#2 使用!pte进行地址转换</p><p>假设客户正在调查属于MyApp.exe进程的虚拟地址0x0012F980。在使用!pte扩展指令获取其对应的物理地址过程中，操作如下：</p><ol><li><p>确保子啊16进制下进行运算。如果有必要，通过N 16指令设置当前环境为16进制；</p></li><li><p>获取地址的字节索引。该数字等同于虚拟地址的低12位。因此，虚拟地址0x0012f980的字节索引为0x980；</p></li><li><p>将进程上下文环境设置到目标进程中：</p><pre><code> kd&gt; !process 0 0 **** NT ACTIVE PROCESS DUMP **** .... PROCESS ff779190  SessionId: 0  Cid: 04fcPeb: 7ffdf000  ParentCid: 0394 DirBase: 098fd000  ObjectTable: e1646b30  TableSize:   8. Image: MyApp.exe  kd&gt; .process /p ff779190 Implicit process is now ff779190 .cache forcedecodeuser done</code></pre></li><li><p>使用!pte指令时以虚拟地址作为参数。输出信息以两列形式展示出来。左边的一列描述了地址对应的页目录条目（page directory entry，pe），右边列展示了页表条目（page table entry，pte）：</p><pre><code> kd&gt; !pte 12f980    VA 0012f980 PDE at   C0300000PTE at C00004BC contains 0BA58067  contains 09DE9067 pfn ba58 ---DA--UWVpfn 9de9 ---DA--UWV</code></pre></li><li><p>查看右边列的最后一行。符号”pfn 9de9”出现了。pte的页框号（page frame number，pfn）是0x9de9.页框号乘以0x1000（例如，左移12位）。结果0x09DE9000就是内存也的起始物理地址；</p></li><li><p>在页的开始出加上地址的字节索引：0x09DE9000 + 0x980 &#x3D; 0x09DE9980。这就是目标物理地址；</p></li></ol><p>与之前的方法得到了相同的结果。</p><p>#3 手动进行地址转换</p><p>尽管!ptov和pte指令提供了将虚拟地址转换为物理地址的最快方式，但是也可以人工完成这一转换过程。对该过程的描述将阐明虚拟内存体系结构的一些细节。</p><p>内存结构因其处理器和硬件配置的不同而会在大小方面发生变化。例子来源于一个没有启用物理地址扩展（physical address extension，pae）功能的x86系统。</p><p>使用0x0012F980作为虚拟地址，首先需要将该地址转换为2进制，可以手动转换，也可以使用.formats（dhow number formats，展示数字格式）指令实现：</p><pre><code>kd&gt; .formats 12f980Evaluate expression:  Hex:     0012f980  Decimal: 1243520  Octal:   00004574600  Binary:  00000000 00010010 11111001 10000000  Chars:   ....  Time:    Thu Jan 15 01:25:20 1970  Float:   low 1.74254e-039 high 0  Double:  6.14381e-318</code></pre><p>虚拟地址有3个字段组成。第0位到第11位是字节索引。第12位到第21位是页表索引。第22位到第31位是页目录索引。将对应字段进行拆分，实现如下：</p><pre><code>0x0012F980  =  0y  00000000 00   010010 1111   1001 10000000</code></pre><p>导出虚拟地址的3个字段：</p><ul><li>页目录索引&#x3D;0y0000000000&#x3D;0x0</li><li>页表索引&#x3D;0y0100101111&#x3D;0x12F</li><li>字节索引&#x3D;0y100110000000&#x3D;0x980</li></ul><p>之后系统需要3个额外的信息：</p><ul><li>每一个pte的大小。在非pae x86系统中是4个字节。</li><li>页大小。是0x1000字节。</li><li>PTE_BASE虚拟地址。在非pae系统中，是0xC0000000.</li></ul><p>使用这些数据，可以计算pte自身的地址：</p><pre><code>PTE address   =   PTE_BASE                  + (page directory index) * PAGE_SIZE                + (page table index) * sizeof(MMPTE)    =   0xc0000000                + 0x0   * 0x1000                + 0x12F * 4              =   0xC00004BC</code></pre><p>这就是pte的地址。pte是一个32位的双字变量。其内容如下：</p><pre><code>kd&gt; dd 0xc00004bc L1c00004bc  09de9067</code></pre><p>pte数值是0x09DE9067。其由两个字段组成。</p><ul><li>pte的低12位是状态标志（status flags）。在这种情况下，这些标志位等于0x067–或者二进制的0y000001100111.对于状态标志位的解释，可以查看!pte指令参考页。</li><li>pte的高20位等于pte的页框号pfn。在这种情况下，pfn是0x09DE9.</li></ul><p>物理页上的第一个物理地址是pfn乘以0x1000（即左移12位）。字节索引就是页上的偏移。因此，查找的物理地址就是0x09DE9000+0x980&#x3D;0x09DE9980。与之前的计算方式获取的结果一致。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大多数调试器命令都是用虚拟地址而非物理地址作为输出及输出参数。然而，也同时存在物理地址起作用的场景。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="windbg官方文档翻译" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/windbg%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="windbg" scheme="https://bbbccvbvv.github.io/tags/windbg/"/>
    
    <category term="convert virtual address to physical address" scheme="https://bbbccvbvv.github.io/tags/convert-virtual-address-to-physical-address/"/>
    
  </entry>
  
  <entry>
    <title>windbg标准调试技巧-读写内存（4）：访问局部变量</title>
    <link href="https://bbbccvbvv.github.io/2023/08/07/windbg_debug_technique_reading_and_writing_memory_4/"/>
    <id>https://bbbccvbvv.github.io/2023/08/07/windbg_debug_technique_reading_and_writing_memory_4/</id>
    <published>2023-08-07T10:20:00.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>与全局变量相同，局部变量也存储于符号文件中。更加一致的是，调试器也将局部变量的名称解释为地址。可以安装与全局变量相同的方式进行读写操作。但是，如果需要向命令指定某个符号是本地符号，请在符号前面添加美元符号($)和感叹号(!)，例如$!var。</p><span id="more"></span><p>Visual Studio和WinDbg提供了使用者可以使用（附加到命令上）的用户接口元素查看和编辑全局变量。可以参考《在Visual Studio查看和编辑内存及寄存器》和《在WinDbg查看和编辑全局变量》两章。</p><p>除此之外，也可以使用如下的方式展示、修改及使用局部变量：</p><ul><li>dv（展示局部变量display local variable）命令展示了全部局部变量的名称和数值。</li><li>!for_each_local扩展使得使用者可以重复运行一条指令，每一个针对一个局部变量。</li></ul><p>然而，在局部变量与全局变量之间还存在着一个主要的不同之处。应用程序运行时，局部变量的含义依赖于程序计数器的位置，因为局部变量的作用于仅仅局限于被定义的函数内部。</p><p>调试器依据局部上下文（local context）环境解释局部变量。默认情况下，该上下文与程序计数器的位置相匹配。但是调试器也可以改变上下文。想获取更多与局部上下文相关的信息可以参考《局部上下文》章节。</p><p>当局部上下文环境改变后，局部窗口（local window）立即更新以反应局部变量的新集合。dv命令也展示了新的变量。所有的这些变量名称通过之前描述的内存指令被正确解释。用户可以读写这些变量。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;与全局变量相同，局部变量也存储于符号文件中。更加一致的是，调试器也将局部变量的名称解释为地址。可以安装与全局变量相同的方式进行读写操作。但是，如果需要向命令指定某个符号是本地符号，请在符号前面添加美元符号($)和感叹号(!)，例如$!var。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="windbg官方文档翻译" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/windbg%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="windbg" scheme="https://bbbccvbvv.github.io/tags/windbg/"/>
    
    <category term="access local variables" scheme="https://bbbccvbvv.github.io/tags/access-local-variables/"/>
    
  </entry>
  
  <entry>
    <title>windbg标准调试技巧-读写内存（3）：访问全局变量</title>
    <link href="https://bbbccvbvv.github.io/2023/08/04/windbg_debug_technique_reading_and_writing_memory_3/"/>
    <id>https://bbbccvbvv.github.io/2023/08/04/windbg_debug_technique_reading_and_writing_memory_3/</id>
    <published>2023-08-04T11:30:00.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>全局变量的名称存储在应用程序编译时创建的符号文件中。调试器将全局变量的名称解释为一个虚拟地址。任何接受地址作为参数的命令都可以接受变量名称作为参数。因此，可以使用在之前的《通过虚拟地址访问内存》章节中描述的全部指令读写全局变量。</p><span id="more"></span><p>除此之外，也可以使用?（计算表达式evaluate expression）指令展示与符号相关的地址。</p><p>Visual Studio和WinDbg提供了使用者可以使用（附加到命令上）的用户接口元素查看和编辑全局变量。可以参考《在Visual Studio查看和编辑内存及寄存器》和《在WinDbg查看和编辑全局变量》两章。</p><p>思考下面的例子。假设用户想要检查一个32位整数类型的全局变量MyCounter，同时假设默认进制是10进制。</p><p>也可以获取变量地址并展示如下：</p><pre><code> 0:000&gt; ? MyCounter Evaluate expression: 1244892 = 0012fedc0:000&gt; dd 0x0012fedc L1 0012fedc  00000052</code></pre><p>第一条命令输出告诉使用者MyCounter的地址是0x0012FEDC。也可以使用d*（展示内存display memory）命令在这个地址上展示一个双字（也可以使用1244892，即该地址的十进制版本，然而，多数c语言程序员更倾向于使用0x0012FEDC）。第二条指令告诉使用者MyCounter的数值是0x52（即十进制下的82）.</p><p>也可以使用如下指令实现上述过程</p><pre><code>0:000&gt; dd MyCounter L1 0012fedc  00000052</code></pre><p>可使用如下指令将MyCounter的数值改为十进制的83.</p><pre><code>0:000&gt; ed MyCounter 83 </code></pre><p>这个示例使用了十进制输入，因为十进制格式对于一个整数来说更加自然。<br>然而，d*命令的输出仍然是以16进制格式展示的。</p><pre><code>0:000&gt; dd MyCounter L1 0012fedc  00000053</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;全局变量的名称存储在应用程序编译时创建的符号文件中。调试器将全局变量的名称解释为一个虚拟地址。任何接受地址作为参数的命令都可以接受变量名称作为参数。因此，可以使用在之前的《通过虚拟地址访问内存》章节中描述的全部指令读写全局变量。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="windbg官方文档翻译" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/windbg%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="windbg" scheme="https://bbbccvbvv.github.io/tags/windbg/"/>
    
    <category term="access global variables" scheme="https://bbbccvbvv.github.io/tags/access-global-variables/"/>
    
  </entry>
  
  <entry>
    <title>windbg标准调试技巧-读写内存（2）：通过物理地址访问内存</title>
    <link href="https://bbbccvbvv.github.io/2023/08/03/windbg_debug_technique_reading_and_writing_memory_2/"/>
    <id>https://bbbccvbvv.github.io/2023/08/03/windbg_debug_technique_reading_and_writing_memory_2/</id>
    <published>2023-08-03T12:30:00.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>为了从物理地址中读取参数，可以使用!db、!dc、!dd、!dp、!du和!dw等扩展命令。</p><p>向物理地址中写入数据，可以使用!eb和!ed扩展命令。</p><p>fp（fill physical memory填充物理内存）指令向物理内存范围内写入了模板值，不停重复，知道内存被完全填充。</p><p>当在内核模式中使用windbg时，可以在windbg的内存窗口中直接进行物理内存的读写操作。</p><p>要在物理内存中搜索一段数据或一系列数据，请使用 !search 扩展命令。</p><p>想要查看更多与物理地址相关的信息，可以查看转换虚拟地址到物理地址这一章节。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为了从物理地址中读取参数，可以使用!db、!dc、!dd、!dp、!du和!dw等扩展命令。&lt;/p&gt;
&lt;p&gt;向物理地址中写入数据，可以使用!eb和!ed扩展命令。&lt;/p&gt;
&lt;p&gt;fp（fill physical memory填充物理内存）指令向物理内存范围内写入了模板值，不</summary>
      
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="windbg官方文档翻译" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/windbg%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="windows" scheme="https://bbbccvbvv.github.io/tags/windows/"/>
    
    <category term="windbg" scheme="https://bbbccvbvv.github.io/tags/windbg/"/>
    
    <category term="standard debugging techniques" scheme="https://bbbccvbvv.github.io/tags/standard-debugging-techniques/"/>
    
    <category term="reading and writng memory" scheme="https://bbbccvbvv.github.io/tags/reading-and-writng-memory/"/>
    
    <category term="physical address" scheme="https://bbbccvbvv.github.io/tags/physical-address/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】OpenSSL环境变量OPENSSL_ia32cap详解</title>
    <link href="https://bbbccvbvv.github.io/2023/07/24/openssl_env_variable_openssl_ia32cap/"/>
    <id>https://bbbccvbvv.github.io/2023/07/24/openssl_env_variable_openssl_ia32cap/</id>
    <published>2023-07-24T03:30:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-名称"><a href="#1-名称" class="headerlink" title="1 名称"></a>1 名称</h1><p>OPENSSL_ia32cap：x86[_64]架构处理器能力向量（processor capabilities vector）</p><span id="more"></span><h1 id="2-概要"><a href="#2-概要" class="headerlink" title="2 概要"></a>2 概要</h1><pre><code>env OPENSSL_ia32cap=... &lt;application&gt;</code></pre><h1 id="3-描述"><a href="#3-描述" class="headerlink" title="3 描述"></a>3 描述</h1><p>OpenSSL支持一系列的x86[_64]指令集扩展。在以EAX&#x3D;1作为输入值运行CPUID指令之后，这些扩展由处理器返回的位于EDX:ECX寄存器对能力向量的各个位表示（详情可参考Intel Application Note #241618）。这些向量在工具包初始化时被复制到内存中，被用来选择不同的代码路径以在一系列处理器之间提供最佳性能。在撰写本文时，以下位很重要：</p><ul><li>第4位：表示时间戳计数器（Time-Stamp Counter）的存在；</li><li>第19位：表示CLFLUSH（flush cache line缓存线清除操作码指令）指令可用；</li><li>第20位：由Intel保留，用于在RC4代码路径中进行选择；</li><li>第23位：表示MMX（Multi Media eXtension，多媒体扩展指令集）支持；</li><li>第24位：FXSR（FidelityFX™ Super Resolution）位，表示支持XMM寄存器；</li><li>第25位：表示支持SSE（streaming simd extensions流式单指令多数据扩展）；</li><li>第26位：表示支持SSE2；</li><li>第28位：支持超线程（Hyperthreading），用于区分具有共享缓存的核心；</li><li>第30位：由 Intel 保留，特指 Intel CPU；</li><li>第33位：表明可以使用PCLMULQDQ（Carry-Less Multiplication Quadword，是对两个GF(2^128)域上的多项式相乘）指令；</li><li>第41位：表明支持SSSE3和补充SSE3；</li><li>第43位：表明支持AMD XOP（非AMD cpu上强制设置为0）；</li><li>第54位：表明支持MOVBE（复制源操作数的数据，交换字节后，移动数据）指令；</li><li>第57位：表明支持AES-NI指令集（高级加密标准指令集，或称英特尔高级加密标准新指令，目的是改进应用程序使用高级加密标准（AES）执行加密和解密的速度）扩展；</li><li>第58位：XSAVE位，缺少该位与MOVBE结合用于识别Atom Silvermont 核心；</li><li>第59位：OSXSAVE位，表明支持YMM寄存器；</li><li>第60位：表明支持AVX（X86指令集的SSE延伸架构）扩展；</li><li>第62位：表明支持RDRAND（用于从芯片上的硬件随机数生成器中获取随机数）指令；</li></ul><p>例如，在32位应用程序上下文环境中将第26位清0，则在运行时会禁用crypto库里的高性能SSE2代码，将第24位清0将会禁用SSE2代码操作128位MMX寄存器组。如果目标OpenSSL应用程序运行在SSE2兼容的cpu上，但是操作系统却没有启用XMM寄存器，则必须执行后者将第24位清0。一般情况下，功能向量的地址通过OPENSSL_ia32cap_loc()函数暴露给应用程序，但并非全部情况下都是如此。现在唯一可以影响功能检测的方法就是在目标程序启动前，设置OPENSSL_ia32cap环境变量。例如，在Intel P4处理器中，设置env OPENSSL_ia32cap&#x3D;0x16980010 apps&#x2F;openssl，或者设置env OPENSSL_ia32cap&#x3D;~0x1000000 apps&#x2F;openssl都可以取得预期的效果。也可以重新配置no-sse2选项，并重新编译工具包。</p><p>不太直观的就是将第28位清零，或者在环境变量中设置为~0x10000000。事实是，它不是从CPUID输出逐字复制的，而是经过调整以反映数据缓存是否实际上在逻辑核心之间共享。这反过来又会影响是否应用针对缓存定时攻击的昂贵对策的决定，尤其是在AES汇编器模块中。</p><p>通过以EAX&#x3D;7和ECX&#x3D;0作为输入值获取CPUID返回的EBX数值，功能向量可以进一步扩展。下面的位很重要：</p><ul><li>第64+3位：表明支持BMI1（Bit Manipulation Instructions位操作指令）指令，例如ANDN（第一源操作数取反后与第二源操作数按位与操作，结果保存在目标操作数中）；</li><li>第64+5位：表明支持AVX2指令；</li><li>第64+8位：表明支持BMI2指令，如MULX和RORX；</li><li>第64+16位：表明支持AVX512F扩展；</li><li>第64+17位：表明支持AVX512DQ扩展；</li><li>第64+18位：表明支持RDSEED指令；</li><li>第64+19位：表明支持ADCX和ADOX指令；</li><li>第64+21位：表明支持VPMADD52[LH]UQ指令，又名AVX512IFMA扩展；</li><li>第64+29位：表明支持SHA扩展；</li><li>第64+30位：表明支持AVX512BW扩展；</li><li>第64+31位：表明支持AVX512VL扩展；</li><li>第64+41位：表明支持VAES扩展；</li><li>第64+42位：表明支持VPCLMULQDQ扩展；</li></ul><p>要控制此扩展功能，请在设置OPENSSL_ia32cap环境变量时使用:作为分隔符。例如，分配:~0x20将禁用AVX2代码路径，而:0-禁用所有后AVX扩展。</p><h1 id="4-返回值"><a href="#4-返回值" class="headerlink" title="4 返回值"></a>4 返回值</h1><p>不可用</p><p>原文地址：<a href="https://www.openssl.org/docs/man3.1/man3/OPENSSL_ia32cap.html" title="OPENSSL_ia32cap">https://www.openssl.org/docs/man3.1/man3/OPENSSL_ia32cap.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-名称&quot;&gt;&lt;a href=&quot;#1-名称&quot; class=&quot;headerlink&quot; title=&quot;1 名称&quot;&gt;&lt;/a&gt;1 名称&lt;/h1&gt;&lt;p&gt;OPENSSL_ia32cap：x86[_64]架构处理器能力向量（processor capabilities vector）&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="OpenSSL" scheme="https://bbbccvbvv.github.io/tags/OpenSSL/"/>
    
    <category term="OPENSSL_ia32cap" scheme="https://bbbccvbvv.github.io/tags/OPENSSL-ia32cap/"/>
    
  </entry>
  
  <entry>
    <title>windbg标准调试技巧-读写内存（1）：通过虚拟地址访问内存</title>
    <link href="https://bbbccvbvv.github.io/2023/07/19/windbg_debug_technique_reading_and_writing_memory_1/"/>
    <id>https://bbbccvbvv.github.io/2023/07/19/windbg_debug_technique_reading_and_writing_memory_1/</id>
    <published>2023-07-19T11:30:00.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>在调试过程中可以通过使用多个指令来访问内存或内存区域。visual studio和windbg提供命令行命令时，也提供了用户图形界面，用户可以用图形界面来查看和编辑内存。详情可以参考windbg帮助文档中的在visual studio中查看和编辑内存和寄存器，以及在windbg中查看和编辑内存两个章节。</p><span id="more"></span><p>以下命令可以读取与写入多种格式的内存。这些屙屎包含了16字节、字格式（单字、双字、四字、八字格式）、整数格式（short、long、quad、unsigned格式）、浮点数格式（10字节、16字节、32字节、64字节实数格式）以及ascii字符格式。</p><ul><li>d*（展示内存display memory）指令会展示特定内存或内驱区域的内容。</li><li>e*（输入数值enter values）指令向特定的内存地址写入数值。</li></ul><p>也可以使用如下指令处理更加特定的数据类型：</p><ul><li>dt（展示类型display type）指令会检索多种数据类型并展示被当前正在调试的应用程序锁创建出来的数据结构。改名了用途广泛并拥有多种变体及可选配置项。</li><li>ds（展示字符串display string）指令展示了STRING、ANSI_STRING和UNICODE_STRING数据结构。</li><li>dl（展示链表display linked list）指令追踪并展示链表。</li><li>d*s（展示字格式和符号display words and symbols）指令检索可能包含符号信息的双字或四字结构，之后展示对应的数据及符号信息。</li><li>!address扩展指令展示位于特定地址的内存属性信息。</li></ul><p>可以使用如下指令来进行内存范围操作：</p><ul><li>m（移动内存move memory）指令将一个内存范围的内容移到另外一个中。</li><li>f（填充内存fill mempry）指令向内存范围中写入指定的样式，后续重复该操作直到内存范围被全部填满。</li><li>c（比较内存compare memory）指令比较两个内存范围的内容；</li><li>s（搜索内存search memory）指令在一个内存范围内搜索指定格式的内容、或者搜索内存范围内的任一ascii或unicode编码；</li><li>.holdmem（保存并比较内存hold and compare memory）指令将一个内存范围与另外一个进行比较。</li></ul><p>在大多数场景下，这些命令以当前的进制解释其参数。因此，如果当前的进制不是16，那么需要在16进制地址前增加0x表示其为16进制。然而，命令的展示输出通常是16进制的，不按照当前进制进行展示。内存窗口以10进制展示了整数与实数以16进制展示其他类型的参数。</p><p>可使用n（设置数字基数set number base）指令改变默认的进制。为快速将数字由一个进制转换为另外一个进制，可使用？（计算表达式evaluate expression）指令或者.format（展示数字格式show number formats）指令。</p><p>当进行用户模式调试时，虚拟地址的含义是当前进程决定的。当你进行内核模式调试时，虚拟地址的含义可以被调试器控制。更多内容，可参考进程上下文（process context）章节。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在调试过程中可以通过使用多个指令来访问内存或内存区域。visual studio和windbg提供命令行命令时，也提供了用户图形界面，用户可以用图形界面来查看和编辑内存。详情可以参考windbg帮助文档中的在visual studio中查看和编辑内存和寄存器，以及在windbg中查看和编辑内存两个章节。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="windbg官方文档翻译" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/windbg%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="windows" scheme="https://bbbccvbvv.github.io/tags/windows/"/>
    
    <category term="windbg" scheme="https://bbbccvbvv.github.io/tags/windbg/"/>
    
    <category term="standard debugging techniques" scheme="https://bbbccvbvv.github.io/tags/standard-debugging-techniques/"/>
    
    <category term="reading and writng memory" scheme="https://bbbccvbvv.github.io/tags/reading-and-writng-memory/"/>
    
    <category term="virtual address" scheme="https://bbbccvbvv.github.io/tags/virtual-address/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】libvirt虚拟机xml配置文件格式（9）CPU model and topology</title>
    <link href="https://bbbccvbvv.github.io/2022/11/15/domain_xml_format9_cpu_model_topology/"/>
    <id>https://bbbccvbvv.github.io/2022/11/15/domain_xml_format9_cpu_model_topology/</id>
    <published>2022-11-15T10:10:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>原文网址：<a href="https://libvirt.org/formatdomain.html#id8" title="Domain XML format">https://libvirt.org/formatdomain.html#id8</a></p><span id="more"></span><h1 id="NUMA-Node-Tuning"><a href="#NUMA-Node-Tuning" class="headerlink" title="NUMA Node Tuning"></a>NUMA Node Tuning</h1><pre><code>&lt;domain&gt;  ...  &lt;numatune&gt;    &lt;memory mode=&quot;strict&quot; nodeset=&quot;1-4,^3&quot;/&gt;    &lt;memnode cellid=&quot;0&quot; mode=&quot;strict&quot; nodeset=&quot;1&quot;/&gt;    &lt;memnode cellid=&quot;2&quot; mode=&quot;preferred&quot; nodeset=&quot;2&quot;/&gt;  &lt;/numatune&gt;  ...&lt;/domain&gt;</code></pre><h2 id="numatune"><a href="#numatune" class="headerlink" title="numatune"></a>numatune</h2><p>可选元素项numatune提供了如何通过控制虚拟机进程的NUMA策略对NUMA主机的性能进行调度。注意，仅支持QEMU。自0.9.3起。</p><h2 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h2><p>可选元素项memory指明了如何对NUMA主机的虚拟机进程进行内存分配。其包含多个可选属性项。属性项mode的可用值包含interleave、strict、preferred和restrictive，默认设置为strict。restrictive指明使用系统默认策略，仅有cgroups被用来限制内存节点，在memnode元素中将mode设置为restrictive。属性项nodeset指明了numa节点，其与vcpu元素项的cpuset属性项使用相同的语法。属性项placement（自0.9.12起）可被用来表明虚拟机进程的内存放置模式，其值可以为static或auto，是vcpu的placement的默认值，如果指定了nodeset则默认值为static。auto表明虚拟机进程只会从查询numad返回的咨询节点中集中分配内存，属性nodeset的值在指定auto的情况下将会被忽略。如果vcpu的placement设置为auto，且numatune未指定，则numatune的placement设置为auto，mode设置为strict。自0.9.3起。参阅 virDomainSetNumaParameters获取该元素的更多信息。</p><h2 id="memnode"><a href="#memnode" class="headerlink" title="memnode"></a>memnode</h2><p>可选元素项memnode可以为每个虚拟机的numa节点指定内存分配策略。对于没有memnode元素的哪些节点，memory元素的默认值将会被使用。属性项cellid寻址应用设置的虚拟机NUMA节点。属性项mode和nodeset与memory元素中的对应值具有相同的含义和语法。设置与自动placement不兼容。qemu自1.2.7起。</p><h1 id="Block-I-x2F-O-Tuning"><a href="#Block-I-x2F-O-Tuning" class="headerlink" title="Block I&#x2F;O Tuning"></a>Block I&#x2F;O Tuning</h1><pre><code>&lt;domain&gt;  ...  &lt;blkiotune&gt;    &lt;weight&gt;800&lt;/weight&gt;    &lt;device&gt;      &lt;path&gt;/dev/sda&lt;/path&gt;      &lt;weight&gt;1000&lt;/weight&gt;    &lt;/device&gt;    &lt;device&gt;      &lt;path&gt;/dev/sdb&lt;/path&gt;      &lt;weight&gt;500&lt;/weight&gt;      &lt;read_bytes_sec&gt;10000&lt;/read_bytes_sec&gt;      &lt;write_bytes_sec&gt;10000&lt;/write_bytes_sec&gt;      &lt;read_iops_sec&gt;20000&lt;/read_iops_sec&gt;      &lt;write_iops_sec&gt;20000&lt;/write_iops_sec&gt;    &lt;/device&gt;  &lt;/blkiotune&gt;  ...&lt;/domain&gt;</code></pre><h2 id="blkiotune"><a href="#blkiotune" class="headerlink" title="blkiotune"></a>blkiotune</h2><p>可选元素项blkiotune为虚拟机提供了调节Blkio cgroup可调参数的能力。如果忽略该设置项，则其默认由操作系统提供。自0.8.8起。</p><h2 id="weight"><a href="#weight" class="headerlink" title="weight"></a>weight</h2><p>可选元素项weight是虚拟机的全部i&#x2F;o负载。该值的范围是100-1000.在2.6.39内核后，该值的范围是10-1000.</p><h2 id="device"><a href="#device" class="headerlink" title="device"></a>device</h2><p>虚拟机可能又有多个device元素项，以便深入调节虚拟机正在使用的每一个主机块设备的权重。注意多个磁盘（可参阅Hard drives, floppy disks, CDROMs章节）可能共享同一个主机块设备，如果他们被相同的主机文件系统中的文件备份，这也是为什么使用全局作用域的调节参数而非相关的每一个虚拟机磁盘设备的原因（与磁盘定义中的iotune元素项相反（可参阅Hard drives, floppy disks, CDROMs章节），而iotune元素项适用于单个独立的磁盘）。每一个device元素项有两个强制的子元素项，path描述了设备的绝对路径，而weight给出了设备的相对权重，权重范围是100-1000.在2.6.39版本内核之后，该值的范围变为10-1000.自0.9.8起。除此之外，也可使用如下的可选子元素项：</p><h3 id="read-bytes-sec"><a href="#read-bytes-sec" class="headerlink" title="read_bytes_sec"></a>read_bytes_sec</h3><p>以字节为单位的每秒可读吞吐量。自1.2.2起。</p><h3 id="write-bytes-sec"><a href="#write-bytes-sec" class="headerlink" title="write_bytes_sec"></a>write_bytes_sec</h3><p>以字节为单位的每秒可写吞吐量。自1.2.2起。</p><h3 id="read-iops-sec"><a href="#read-iops-sec" class="headerlink" title="read_iops_sec"></a>read_iops_sec</h3><p>每秒i&#x2F;o读操作限制。自1.2.2起。</p><h3 id="write-iops-sec"><a href="#write-iops-sec" class="headerlink" title="write_iops_sec"></a>write_iops_sec</h3><p>每秒i&#x2F;o写操作限制。自1.2.2起。</p><h1 id="Resource-partitioning"><a href="#Resource-partitioning" class="headerlink" title="Resource partitioning"></a>Resource partitioning</h1><p>虚拟机管理程序可能允许将虚拟机放入资源分区，也可能嵌套所述分区。resource元素将与资源分区相关的配置项组织在一起。当前其支持partition子元素项，该子元素项的内容定义了放置虚拟机的资源分区的绝对路径。如果没有列出任何分区，虚拟机将会被放到默认分区中。应用程序或管理员有责任确保分区在虚拟机启动之前就已存在。只有默认分区（适用于特定虚拟机管理程序）可以默认假定已经存在。</p><pre><code>...&lt;resource&gt;  &lt;partition&gt;/virtualmachines/production&lt;/partition&gt;&lt;/resource&gt;...</code></pre><p>资源分区当前在qemu和lxc中受到支持，在所有已安装的控制器中将分区路径映射到cgroups目录。自1.0.5起。</p><h1 id="Fibre-Channel-VMID"><a href="#Fibre-Channel-VMID" class="headerlink" title="Fibre Channel VMID"></a>Fibre Channel VMID</h1><p>FC SAN可以提供多个依赖于VMID的QoS等级和访问控制功能。它还可以收集每个虚拟机的遥测数据，这些数据可用于增强虚拟机的IO性能。可以通过fibrechannel元素项的appid属性项进行配置。该属性项包含了简单的字符串（最大128字节），内核可使用该属性项创建VMID。</p><pre><code>...&lt;resource&gt;  &lt;fibrechannel appid=&#39;userProvidedID&#39;/&gt;&lt;/resource&gt;...</code></pre><p>使用该特征项要求支持光纤通道的硬件，内核编译时配置有 CONFIG_BLK_CGROUP_FC_APPID选项，且nvme_fc内核模块已加载。自7.7.0起。</p><p>本章节描述了用来代表作用域的xml文件格式，根据运行的作用于种类的格式变化，有一些可选配置项用来加载文件。对于特定虚拟机的细节可以查看<br><a href="https://libvirt.org/drivers.html">相关文件</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文网址：&lt;a href=&quot;https://libvirt.org/formatdomain.html#id8&quot; title=&quot;Domain XML format&quot;&gt;https://libvirt.org/formatdomain.html#id8&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="虚拟化" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="kvm" scheme="https://bbbccvbvv.github.io/tags/kvm/"/>
    
    <category term="libvirt" scheme="https://bbbccvbvv.github.io/tags/libvirt/"/>
    
    <category term="虚拟机xml配置文件" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BAxml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
    <category term="翻译" scheme="https://bbbccvbvv.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="CPU model and topology" scheme="https://bbbccvbvv.github.io/tags/CPU-model-and-topology/"/>
    
  </entry>
  
</feed>
