<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>怀德维宁</title>
  
  <subtitle>大邦维屏，大宗维翰。怀德维宁，宗子维城。</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-12-29T02:38:41.469Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>杨维宁</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>windbg标准调试技巧-读写内存（5）：将虚拟地址转换为物理地址</title>
    <link href="http://example.com/2023/08/07/windbg_debug_technique_reading_and_writing_memory_5/"/>
    <id>http://example.com/2023/08/07/windbg_debug_technique_reading_and_writing_memory_5/</id>
    <published>2023-08-07T10:30:00.000Z</published>
    <updated>2023-12-29T02:38:41.469Z</updated>
    
    <content type="html"><![CDATA[<p>大多数调试器命令都是用虚拟地址而非物理地址作为输出及输出参数。然而，也同时存在物理地址起作用的场景。</p><span id="more"></span><p>这里有两种方式将虚拟地址转换为物理地址：使用!vtop扩展或使用!pte扩展。</p><p>#1 使用!vtop进行地址转换</p><ol><li><p>确保在16禁止之下进行操作。如果必要的话，通过N 16指令设置当前环境为16进制；</p></li><li><p>确定地址的字节索引。该数字等同于虚拟地址的低12位。因此，虚拟地址0x0012f980的字节索引为0x980；</p></li><li><p>通过使用!process扩展确定地址的字典进制：</p><pre><code> kd&gt; !process 0 0 **** NT ACTIVE PROCESS DUMP **** .... PROCESS ff779190  SessionId: 0  Cid: 04fcPeb: 7ffdf000  ParentCid: 0394 DirBase: 098fd000  ObjectTable: e1646b30 TableSize:   8. Image: MyApp.exe</code></pre></li><li><p>决定目录基址的页框号。这只是没有三个尾随十六进制零的目录基址。在本例中，目录基址为0x098FD000，因此页框号为0x098FD。</p></li><li><p>使用!vtop扩展。该扩展的第一个参数是页框号。!vtop的第二个参数就是问题中的虚拟地址：</p><p> kd&gt; !vtop 98fd 12f980<br> Pdi 0 Pti 12f<br> 0012f980 09de9000 pfn(09de9)</p></li></ol><p>最后一行中展示的第二个数字是物理页的起始物理地址。</p><ol start="6"><li>在页的开始出加上地址的字节索引：0x09DE9000 + 0x980 &#x3D; 0x09DE9980。这就是目标物理地址。</li></ol><p>也可以通过显示每个地址的内存来验证此计算是否正确完成。!d*扩展显示指定物理地址处的内存：</p><pre><code>kd&gt; !dc 9de9980# 9de9980 6d206e49 726f6d65 00120079 0012f9f4 In memory.......# 9de9990 0012f9f8 77e57119 77e8e618 ffffffff .....q.w...w....# 9de99a0 77e727e0 77f6f13e 77f747e0 ffffffff .&#39;.w&gt;..w.G.w....# 9de99b0 .....</code></pre><p>d*（展示内存）质量使用虚拟地址作为其参数：</p><pre><code>kd&gt; dc 12f9800012f980  6d206e49 726f6d65 00120079 0012f9f4  In memory.......0012f990  0012f9f8 77e57119 77e8e618 ffffffff  .....q.w...w....0012f9a0  77e727e0 77f6f13e 77f747e0 ffffffff  .&#39;.w&gt;..w.G.w....0012f9b0  .....</code></pre><p>因为结果相同，这就表明物理地址0x09DE9980确实代表了虚拟地址0x0012F980。</p><p>#2 使用!pte进行地址转换</p><p>假设客户正在调查属于MyApp.exe进程的虚拟地址0x0012F980。在使用!pte扩展指令获取其对应的物理地址过程中，操作如下：</p><ol><li><p>确保子啊16进制下进行运算。如果有必要，通过N 16指令设置当前环境为16进制；</p></li><li><p>获取地址的字节索引。该数字等同于虚拟地址的低12位。因此，虚拟地址0x0012f980的字节索引为0x980；</p></li><li><p>将进程上下文环境设置到目标进程中：</p><pre><code> kd&gt; !process 0 0 **** NT ACTIVE PROCESS DUMP **** .... PROCESS ff779190  SessionId: 0  Cid: 04fcPeb: 7ffdf000  ParentCid: 0394 DirBase: 098fd000  ObjectTable: e1646b30  TableSize:   8. Image: MyApp.exe  kd&gt; .process /p ff779190 Implicit process is now ff779190 .cache forcedecodeuser done</code></pre></li><li><p>使用!pte指令时以虚拟地址作为参数。输出信息以两列形式展示出来。左边的一列描述了地址对应的页目录条目（page directory entry，pe），右边列展示了页表条目（page table entry，pte）：</p><pre><code> kd&gt; !pte 12f980    VA 0012f980 PDE at   C0300000PTE at C00004BC contains 0BA58067  contains 09DE9067 pfn ba58 ---DA--UWVpfn 9de9 ---DA--UWV</code></pre></li><li><p>查看右边列的最后一行。符号”pfn 9de9”出现了。pte的页框号（page frame number，pfn）是0x9de9.页框号乘以0x1000（例如，左移12位）。结果0x09DE9000就是内存也的起始物理地址；</p></li><li><p>在页的开始出加上地址的字节索引：0x09DE9000 + 0x980 &#x3D; 0x09DE9980。这就是目标物理地址；</p></li></ol><p>与之前的方法得到了相同的结果。</p><p>#3 手动进行地址转换</p><p>尽管!ptov和pte指令提供了将虚拟地址转换为物理地址的最快方式，但是也可以人工完成这一转换过程。对该过程的描述将阐明虚拟内存体系结构的一些细节。</p><p>内存结构因其处理器和硬件配置的不同而会在大小方面发生变化。例子来源于一个没有启用物理地址扩展（physical address extension，pae）功能的x86系统。</p><p>使用0x0012F980作为虚拟地址，首先需要将该地址转换为2进制，可以手动转换，也可以使用.formats（dhow number formats，展示数字格式）指令实现：</p><pre><code>kd&gt; .formats 12f980Evaluate expression:  Hex:     0012f980  Decimal: 1243520  Octal:   00004574600  Binary:  00000000 00010010 11111001 10000000  Chars:   ....  Time:    Thu Jan 15 01:25:20 1970  Float:   low 1.74254e-039 high 0  Double:  6.14381e-318</code></pre><p>虚拟地址有3个字段组成。第0位到第11位是字节索引。第12位到第21位是页表索引。第22位到第31位是页目录索引。将对应字段进行拆分，实现如下：</p><pre><code>0x0012F980  =  0y  00000000 00   010010 1111   1001 10000000</code></pre><p>导出虚拟地址的3个字段：</p><ul><li>页目录索引&#x3D;0y0000000000&#x3D;0x0</li><li>页表索引&#x3D;0y0100101111&#x3D;0x12F</li><li>字节索引&#x3D;0y100110000000&#x3D;0x980</li></ul><p>之后系统需要3个额外的信息：</p><ul><li>每一个pte的大小。在非pae x86系统中是4个字节。</li><li>页大小。是0x1000字节。</li><li>PTE_BASE虚拟地址。在非pae系统中，是0xC0000000.</li></ul><p>使用这些数据，可以计算pte自身的地址：</p><pre><code>PTE address   =   PTE_BASE                  + (page directory index) * PAGE_SIZE                + (page table index) * sizeof(MMPTE)    =   0xc0000000                + 0x0   * 0x1000                + 0x12F * 4              =   0xC00004BC</code></pre><p>这就是pte的地址。pte是一个32位的双字变量。其内容如下：</p><pre><code>kd&gt; dd 0xc00004bc L1c00004bc  09de9067</code></pre><p>pte数值是0x09DE9067。其由两个字段组成。</p><ul><li>pte的低12位是状态标志（status flags）。在这种情况下，这些标志位等于0x067–或者二进制的0y000001100111.对于状态标志位的解释，可以查看!pte指令参考页。</li><li>pte的高20位等于pte的页框号pfn。在这种情况下，pfn是0x09DE9.</li></ul><p>物理页上的第一个物理地址是pfn乘以0x1000（即左移12位）。字节索引就是页上的偏移。因此，查找的物理地址就是0x09DE9000+0x980&#x3D;0x09DE9980。与之前的计算方式获取的结果一致。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大多数调试器命令都是用虚拟地址而非物理地址作为输出及输出参数。然而，也同时存在物理地址起作用的场景。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="windbg官方文档翻译" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/windbg%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="windbg" scheme="http://example.com/tags/windbg/"/>
    
    <category term="convert virtual address to physical address" scheme="http://example.com/tags/convert-virtual-address-to-physical-address/"/>
    
  </entry>
  
  <entry>
    <title>windbg标准调试技巧-读写内存（4）：访问局部变量</title>
    <link href="http://example.com/2023/08/07/windbg_debug_technique_reading_and_writing_memory_4/"/>
    <id>http://example.com/2023/08/07/windbg_debug_technique_reading_and_writing_memory_4/</id>
    <published>2023-08-07T10:20:00.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>与全局变量相同，局部变量也存储于符号文件中。更加一致的是，调试器也将局部变量的名称解释为地址。可以安装与全局变量相同的方式进行读写操作。但是，如果需要向命令指定某个符号是本地符号，请在符号前面添加美元符号($)和感叹号(!)，例如$!var。</p><span id="more"></span><p>Visual Studio和WinDbg提供了使用者可以使用（附加到命令上）的用户接口元素查看和编辑全局变量。可以参考《在Visual Studio查看和编辑内存及寄存器》和《在WinDbg查看和编辑全局变量》两章。</p><p>除此之外，也可以使用如下的方式展示、修改及使用局部变量：</p><ul><li>dv（展示局部变量display local variable）命令展示了全部局部变量的名称和数值。</li><li>!for_each_local扩展使得使用者可以重复运行一条指令，每一个针对一个局部变量。</li></ul><p>然而，在局部变量与全局变量之间还存在着一个主要的不同之处。应用程序运行时，局部变量的含义依赖于程序计数器的位置，因为局部变量的作用于仅仅局限于被定义的函数内部。</p><p>调试器依据局部上下文（local context）环境解释局部变量。默认情况下，该上下文与程序计数器的位置相匹配。但是调试器也可以改变上下文。想获取更多与局部上下文相关的信息可以参考《局部上下文》章节。</p><p>当局部上下文环境改变后，局部窗口（local window）立即更新以反应局部变量的新集合。dv命令也展示了新的变量。所有的这些变量名称通过之前描述的内存指令被正确解释。用户可以读写这些变量。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;与全局变量相同，局部变量也存储于符号文件中。更加一致的是，调试器也将局部变量的名称解释为地址。可以安装与全局变量相同的方式进行读写操作。但是，如果需要向命令指定某个符号是本地符号，请在符号前面添加美元符号($)和感叹号(!)，例如$!var。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="windbg官方文档翻译" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/windbg%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="windbg" scheme="http://example.com/tags/windbg/"/>
    
    <category term="access local variables" scheme="http://example.com/tags/access-local-variables/"/>
    
  </entry>
  
  <entry>
    <title>windbg标准调试技巧-读写内存（3）：访问全局变量</title>
    <link href="http://example.com/2023/08/04/windbg_debug_technique_reading_and_writing_memory_3/"/>
    <id>http://example.com/2023/08/04/windbg_debug_technique_reading_and_writing_memory_3/</id>
    <published>2023-08-04T11:30:00.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>全局变量的名称存储在应用程序编译时创建的符号文件中。调试器将全局变量的名称解释为一个虚拟地址。任何接受地址作为参数的命令都可以接受变量名称作为参数。因此，可以使用在之前的《通过虚拟地址访问内存》章节中描述的全部指令读写全局变量。</p><span id="more"></span><p>除此之外，也可以使用?（计算表达式evaluate expression）指令展示与符号相关的地址。</p><p>Visual Studio和WinDbg提供了使用者可以使用（附加到命令上）的用户接口元素查看和编辑全局变量。可以参考《在Visual Studio查看和编辑内存及寄存器》和《在WinDbg查看和编辑全局变量》两章。</p><p>思考下面的例子。假设用户想要检查一个32位整数类型的全局变量MyCounter，同时假设默认进制是10进制。</p><p>也可以获取变量地址并展示如下：</p><pre><code> 0:000&gt; ? MyCounter Evaluate expression: 1244892 = 0012fedc0:000&gt; dd 0x0012fedc L1 0012fedc  00000052</code></pre><p>第一条命令输出告诉使用者MyCounter的地址是0x0012FEDC。也可以使用d*（展示内存display memory）命令在这个地址上展示一个双字（也可以使用1244892，即该地址的十进制版本，然而，多数c语言程序员更倾向于使用0x0012FEDC）。第二条指令告诉使用者MyCounter的数值是0x52（即十进制下的82）.</p><p>也可以使用如下指令实现上述过程</p><pre><code>0:000&gt; dd MyCounter L1 0012fedc  00000052</code></pre><p>可使用如下指令将MyCounter的数值改为十进制的83.</p><pre><code>0:000&gt; ed MyCounter 83 </code></pre><p>这个示例使用了十进制输入，因为十进制格式对于一个整数来说更加自然。<br>然而，d*命令的输出仍然是以16进制格式展示的。</p><pre><code>0:000&gt; dd MyCounter L1 0012fedc  00000053</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;全局变量的名称存储在应用程序编译时创建的符号文件中。调试器将全局变量的名称解释为一个虚拟地址。任何接受地址作为参数的命令都可以接受变量名称作为参数。因此，可以使用在之前的《通过虚拟地址访问内存》章节中描述的全部指令读写全局变量。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="windbg官方文档翻译" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/windbg%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="windbg" scheme="http://example.com/tags/windbg/"/>
    
    <category term="access global variables" scheme="http://example.com/tags/access-global-variables/"/>
    
  </entry>
  
  <entry>
    <title>windbg标准调试技巧-读写内存（2）：通过物理地址访问内存</title>
    <link href="http://example.com/2023/08/03/windbg_debug_technique_reading_and_writing_memory_2/"/>
    <id>http://example.com/2023/08/03/windbg_debug_technique_reading_and_writing_memory_2/</id>
    <published>2023-08-03T12:30:00.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>为了从物理地址中读取参数，可以使用!db、!dc、!dd、!dp、!du和!dw等扩展命令。</p><p>向物理地址中写入数据，可以使用!eb和!ed扩展命令。</p><p>fp（fill physical memory填充物理内存）指令向物理内存范围内写入了模板值，不停重复，知道内存被完全填充。</p><p>当在内核模式中使用windbg时，可以在windbg的内存窗口中直接进行物理内存的读写操作。</p><p>要在物理内存中搜索一段数据或一系列数据，请使用 !search 扩展命令。</p><p>想要查看更多与物理地址相关的信息，可以查看转换虚拟地址到物理地址这一章节。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为了从物理地址中读取参数，可以使用!db、!dc、!dd、!dp、!du和!dw等扩展命令。&lt;/p&gt;
&lt;p&gt;向物理地址中写入数据，可以使用!eb和!ed扩展命令。&lt;/p&gt;
&lt;p&gt;fp（fill physical memory填充物理内存）指令向物理内存范围内写入了模板值，不</summary>
      
    
    
    
    <category term="计算机科学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="windbg官方文档翻译" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/windbg%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="windows" scheme="http://example.com/tags/windows/"/>
    
    <category term="windbg" scheme="http://example.com/tags/windbg/"/>
    
    <category term="standard debugging techniques" scheme="http://example.com/tags/standard-debugging-techniques/"/>
    
    <category term="reading and writng memory" scheme="http://example.com/tags/reading-and-writng-memory/"/>
    
    <category term="physical address" scheme="http://example.com/tags/physical-address/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】OpenSSL环境变量OPENSSL_ia32cap详解</title>
    <link href="http://example.com/2023/07/24/openssl_env_variable_openssl_ia32cap/"/>
    <id>http://example.com/2023/07/24/openssl_env_variable_openssl_ia32cap/</id>
    <published>2023-07-24T03:30:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-名称"><a href="#1-名称" class="headerlink" title="1 名称"></a>1 名称</h1><p>OPENSSL_ia32cap：x86[_64]架构处理器能力向量（processor capabilities vector）</p><span id="more"></span><h1 id="2-概要"><a href="#2-概要" class="headerlink" title="2 概要"></a>2 概要</h1><pre><code>env OPENSSL_ia32cap=... &lt;application&gt;</code></pre><h1 id="3-描述"><a href="#3-描述" class="headerlink" title="3 描述"></a>3 描述</h1><p>OpenSSL支持一系列的x86[_64]指令集扩展。在以EAX&#x3D;1作为输入值运行CPUID指令之后，这些扩展由处理器返回的位于EDX:ECX寄存器对能力向量的各个位表示（详情可参考Intel Application Note #241618）。这些向量在工具包初始化时被复制到内存中，被用来选择不同的代码路径以在一系列处理器之间提供最佳性能。在撰写本文时，以下位很重要：</p><ul><li>第4位：表示时间戳计数器（Time-Stamp Counter）的存在；</li><li>第19位：表示CLFLUSH（flush cache line缓存线清除操作码指令）指令可用；</li><li>第20位：由Intel保留，用于在RC4代码路径中进行选择；</li><li>第23位：表示MMX（Multi Media eXtension，多媒体扩展指令集）支持；</li><li>第24位：FXSR（FidelityFX™ Super Resolution）位，表示支持XMM寄存器；</li><li>第25位：表示支持SSE（streaming simd extensions流式单指令多数据扩展）；</li><li>第26位：表示支持SSE2；</li><li>第28位：支持超线程（Hyperthreading），用于区分具有共享缓存的核心；</li><li>第30位：由 Intel 保留，特指 Intel CPU；</li><li>第33位：表明可以使用PCLMULQDQ（Carry-Less Multiplication Quadword，是对两个GF(2^128)域上的多项式相乘）指令；</li><li>第41位：表明支持SSSE3和补充SSE3；</li><li>第43位：表明支持AMD XOP（非AMD cpu上强制设置为0）；</li><li>第54位：表明支持MOVBE（复制源操作数的数据，交换字节后，移动数据）指令；</li><li>第57位：表明支持AES-NI指令集（高级加密标准指令集，或称英特尔高级加密标准新指令，目的是改进应用程序使用高级加密标准（AES）执行加密和解密的速度）扩展；</li><li>第58位：XSAVE位，缺少该位与MOVBE结合用于识别Atom Silvermont 核心；</li><li>第59位：OSXSAVE位，表明支持YMM寄存器；</li><li>第60位：表明支持AVX（X86指令集的SSE延伸架构）扩展；</li><li>第62位：表明支持RDRAND（用于从芯片上的硬件随机数生成器中获取随机数）指令；</li></ul><p>例如，在32位应用程序上下文环境中将第26位清0，则在运行时会禁用crypto库里的高性能SSE2代码，将第24位清0将会禁用SSE2代码操作128位MMX寄存器组。如果目标OpenSSL应用程序运行在SSE2兼容的cpu上，但是操作系统却没有启用XMM寄存器，则必须执行后者将第24位清0。一般情况下，功能向量的地址通过OPENSSL_ia32cap_loc()函数暴露给应用程序，但并非全部情况下都是如此。现在唯一可以影响功能检测的方法就是在目标程序启动前，设置OPENSSL_ia32cap环境变量。例如，在Intel P4处理器中，设置env OPENSSL_ia32cap&#x3D;0x16980010 apps&#x2F;openssl，或者设置env OPENSSL_ia32cap&#x3D;~0x1000000 apps&#x2F;openssl都可以取得预期的效果。也可以重新配置no-sse2选项，并重新编译工具包。</p><p>不太直观的就是将第28位清零，或者在环境变量中设置为~0x10000000。事实是，它不是从CPUID输出逐字复制的，而是经过调整以反映数据缓存是否实际上在逻辑核心之间共享。这反过来又会影响是否应用针对缓存定时攻击的昂贵对策的决定，尤其是在AES汇编器模块中。</p><p>通过以EAX&#x3D;7和ECX&#x3D;0作为输入值获取CPUID返回的EBX数值，功能向量可以进一步扩展。下面的位很重要：</p><ul><li>第64+3位：表明支持BMI1（Bit Manipulation Instructions位操作指令）指令，例如ANDN（第一源操作数取反后与第二源操作数按位与操作，结果保存在目标操作数中）；</li><li>第64+5位：表明支持AVX2指令；</li><li>第64+8位：表明支持BMI2指令，如MULX和RORX；</li><li>第64+16位：表明支持AVX512F扩展；</li><li>第64+17位：表明支持AVX512DQ扩展；</li><li>第64+18位：表明支持RDSEED指令；</li><li>第64+19位：表明支持ADCX和ADOX指令；</li><li>第64+21位：表明支持VPMADD52[LH]UQ指令，又名AVX512IFMA扩展；</li><li>第64+29位：表明支持SHA扩展；</li><li>第64+30位：表明支持AVX512BW扩展；</li><li>第64+31位：表明支持AVX512VL扩展；</li><li>第64+41位：表明支持VAES扩展；</li><li>第64+42位：表明支持VPCLMULQDQ扩展；</li></ul><p>要控制此扩展功能，请在设置OPENSSL_ia32cap环境变量时使用:作为分隔符。例如，分配:~0x20将禁用AVX2代码路径，而:0-禁用所有后AVX扩展。</p><h1 id="4-返回值"><a href="#4-返回值" class="headerlink" title="4 返回值"></a>4 返回值</h1><p>不可用</p><p>原文地址：<a href="https://www.openssl.org/docs/man3.1/man3/OPENSSL_ia32cap.html" title="OPENSSL_ia32cap">https://www.openssl.org/docs/man3.1/man3/OPENSSL_ia32cap.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-名称&quot;&gt;&lt;a href=&quot;#1-名称&quot; class=&quot;headerlink&quot; title=&quot;1 名称&quot;&gt;&lt;/a&gt;1 名称&lt;/h1&gt;&lt;p&gt;OPENSSL_ia32cap：x86[_64]架构处理器能力向量（processor capabilities vector）&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="OpenSSL" scheme="http://example.com/tags/OpenSSL/"/>
    
    <category term="OPENSSL_ia32cap" scheme="http://example.com/tags/OPENSSL-ia32cap/"/>
    
  </entry>
  
  <entry>
    <title>windbg标准调试技巧-读写内存（1）：通过虚拟地址访问内存</title>
    <link href="http://example.com/2023/07/19/windbg_debug_technique_reading_and_writing_memory_1/"/>
    <id>http://example.com/2023/07/19/windbg_debug_technique_reading_and_writing_memory_1/</id>
    <published>2023-07-19T11:30:00.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>在调试过程中可以通过使用多个指令来访问内存或内存区域。visual studio和windbg提供命令行命令时，也提供了用户图形界面，用户可以用图形界面来查看和编辑内存。详情可以参考windbg帮助文档中的在visual studio中查看和编辑内存和寄存器，以及在windbg中查看和编辑内存两个章节。</p><span id="more"></span><p>以下命令可以读取与写入多种格式的内存。这些屙屎包含了16字节、字格式（单字、双字、四字、八字格式）、整数格式（short、long、quad、unsigned格式）、浮点数格式（10字节、16字节、32字节、64字节实数格式）以及ascii字符格式。</p><ul><li>d*（展示内存display memory）指令会展示特定内存或内驱区域的内容。</li><li>e*（输入数值enter values）指令向特定的内存地址写入数值。</li></ul><p>也可以使用如下指令处理更加特定的数据类型：</p><ul><li>dt（展示类型display type）指令会检索多种数据类型并展示被当前正在调试的应用程序锁创建出来的数据结构。改名了用途广泛并拥有多种变体及可选配置项。</li><li>ds（展示字符串display string）指令展示了STRING、ANSI_STRING和UNICODE_STRING数据结构。</li><li>dl（展示链表display linked list）指令追踪并展示链表。</li><li>d*s（展示字格式和符号display words and symbols）指令检索可能包含符号信息的双字或四字结构，之后展示对应的数据及符号信息。</li><li>!address扩展指令展示位于特定地址的内存属性信息。</li></ul><p>可以使用如下指令来进行内存范围操作：</p><ul><li>m（移动内存move memory）指令将一个内存范围的内容移到另外一个中。</li><li>f（填充内存fill mempry）指令向内存范围中写入指定的样式，后续重复该操作直到内存范围被全部填满。</li><li>c（比较内存compare memory）指令比较两个内存范围的内容；</li><li>s（搜索内存search memory）指令在一个内存范围内搜索指定格式的内容、或者搜索内存范围内的任一ascii或unicode编码；</li><li>.holdmem（保存并比较内存hold and compare memory）指令将一个内存范围与另外一个进行比较。</li></ul><p>在大多数场景下，这些命令以当前的进制解释其参数。因此，如果当前的进制不是16，那么需要在16进制地址前增加0x表示其为16进制。然而，命令的展示输出通常是16进制的，不按照当前进制进行展示。内存窗口以10进制展示了整数与实数以16进制展示其他类型的参数。</p><p>可使用n（设置数字基数set number base）指令改变默认的进制。为快速将数字由一个进制转换为另外一个进制，可使用？（计算表达式evaluate expression）指令或者.format（展示数字格式show number formats）指令。</p><p>当进行用户模式调试时，虚拟地址的含义是当前进程决定的。当你进行内核模式调试时，虚拟地址的含义可以被调试器控制。更多内容，可参考进程上下文（process context）章节。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在调试过程中可以通过使用多个指令来访问内存或内存区域。visual studio和windbg提供命令行命令时，也提供了用户图形界面，用户可以用图形界面来查看和编辑内存。详情可以参考windbg帮助文档中的在visual studio中查看和编辑内存和寄存器，以及在windbg中查看和编辑内存两个章节。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="windbg官方文档翻译" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/windbg%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="windows" scheme="http://example.com/tags/windows/"/>
    
    <category term="windbg" scheme="http://example.com/tags/windbg/"/>
    
    <category term="standard debugging techniques" scheme="http://example.com/tags/standard-debugging-techniques/"/>
    
    <category term="reading and writng memory" scheme="http://example.com/tags/reading-and-writng-memory/"/>
    
    <category term="virtual address" scheme="http://example.com/tags/virtual-address/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】libvirt虚拟机xml配置文件格式（9）CPU model and topology</title>
    <link href="http://example.com/2022/11/15/domain_xml_format9_cpu_model_topology/"/>
    <id>http://example.com/2022/11/15/domain_xml_format9_cpu_model_topology/</id>
    <published>2022-11-15T10:10:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>原文网址：<a href="https://libvirt.org/formatdomain.html#id8" title="Domain XML format">https://libvirt.org/formatdomain.html#id8</a></p><span id="more"></span><h1 id="NUMA-Node-Tuning"><a href="#NUMA-Node-Tuning" class="headerlink" title="NUMA Node Tuning"></a>NUMA Node Tuning</h1><pre><code>&lt;domain&gt;  ...  &lt;numatune&gt;    &lt;memory mode=&quot;strict&quot; nodeset=&quot;1-4,^3&quot;/&gt;    &lt;memnode cellid=&quot;0&quot; mode=&quot;strict&quot; nodeset=&quot;1&quot;/&gt;    &lt;memnode cellid=&quot;2&quot; mode=&quot;preferred&quot; nodeset=&quot;2&quot;/&gt;  &lt;/numatune&gt;  ...&lt;/domain&gt;</code></pre><h2 id="numatune"><a href="#numatune" class="headerlink" title="numatune"></a>numatune</h2><p>可选元素项numatune提供了如何通过控制虚拟机进程的NUMA策略对NUMA主机的性能进行调度。注意，仅支持QEMU。自0.9.3起。</p><h2 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h2><p>可选元素项memory指明了如何对NUMA主机的虚拟机进程进行内存分配。其包含多个可选属性项。属性项mode的可用值包含interleave、strict、preferred和restrictive，默认设置为strict。restrictive指明使用系统默认策略，仅有cgroups被用来限制内存节点，在memnode元素中将mode设置为restrictive。属性项nodeset指明了numa节点，其与vcpu元素项的cpuset属性项使用相同的语法。属性项placement（自0.9.12起）可被用来表明虚拟机进程的内存放置模式，其值可以为static或auto，是vcpu的placement的默认值，如果指定了nodeset则默认值为static。auto表明虚拟机进程只会从查询numad返回的咨询节点中集中分配内存，属性nodeset的值在指定auto的情况下将会被忽略。如果vcpu的placement设置为auto，且numatune未指定，则numatune的placement设置为auto，mode设置为strict。自0.9.3起。参阅 virDomainSetNumaParameters获取该元素的更多信息。</p><h2 id="memnode"><a href="#memnode" class="headerlink" title="memnode"></a>memnode</h2><p>可选元素项memnode可以为每个虚拟机的numa节点指定内存分配策略。对于没有memnode元素的哪些节点，memory元素的默认值将会被使用。属性项cellid寻址应用设置的虚拟机NUMA节点。属性项mode和nodeset与memory元素中的对应值具有相同的含义和语法。设置与自动placement不兼容。qemu自1.2.7起。</p><h1 id="Block-I-x2F-O-Tuning"><a href="#Block-I-x2F-O-Tuning" class="headerlink" title="Block I&#x2F;O Tuning"></a>Block I&#x2F;O Tuning</h1><pre><code>&lt;domain&gt;  ...  &lt;blkiotune&gt;    &lt;weight&gt;800&lt;/weight&gt;    &lt;device&gt;      &lt;path&gt;/dev/sda&lt;/path&gt;      &lt;weight&gt;1000&lt;/weight&gt;    &lt;/device&gt;    &lt;device&gt;      &lt;path&gt;/dev/sdb&lt;/path&gt;      &lt;weight&gt;500&lt;/weight&gt;      &lt;read_bytes_sec&gt;10000&lt;/read_bytes_sec&gt;      &lt;write_bytes_sec&gt;10000&lt;/write_bytes_sec&gt;      &lt;read_iops_sec&gt;20000&lt;/read_iops_sec&gt;      &lt;write_iops_sec&gt;20000&lt;/write_iops_sec&gt;    &lt;/device&gt;  &lt;/blkiotune&gt;  ...&lt;/domain&gt;</code></pre><h2 id="blkiotune"><a href="#blkiotune" class="headerlink" title="blkiotune"></a>blkiotune</h2><p>可选元素项blkiotune为虚拟机提供了调节Blkio cgroup可调参数的能力。如果忽略该设置项，则其默认由操作系统提供。自0.8.8起。</p><h2 id="weight"><a href="#weight" class="headerlink" title="weight"></a>weight</h2><p>可选元素项weight是虚拟机的全部i&#x2F;o负载。该值的范围是100-1000.在2.6.39内核后，该值的范围是10-1000.</p><h2 id="device"><a href="#device" class="headerlink" title="device"></a>device</h2><p>虚拟机可能又有多个device元素项，以便深入调节虚拟机正在使用的每一个主机块设备的权重。注意多个磁盘（可参阅Hard drives, floppy disks, CDROMs章节）可能共享同一个主机块设备，如果他们被相同的主机文件系统中的文件备份，这也是为什么使用全局作用域的调节参数而非相关的每一个虚拟机磁盘设备的原因（与磁盘定义中的iotune元素项相反（可参阅Hard drives, floppy disks, CDROMs章节），而iotune元素项适用于单个独立的磁盘）。每一个device元素项有两个强制的子元素项，path描述了设备的绝对路径，而weight给出了设备的相对权重，权重范围是100-1000.在2.6.39版本内核之后，该值的范围变为10-1000.自0.9.8起。除此之外，也可使用如下的可选子元素项：</p><h3 id="read-bytes-sec"><a href="#read-bytes-sec" class="headerlink" title="read_bytes_sec"></a>read_bytes_sec</h3><p>以字节为单位的每秒可读吞吐量。自1.2.2起。</p><h3 id="write-bytes-sec"><a href="#write-bytes-sec" class="headerlink" title="write_bytes_sec"></a>write_bytes_sec</h3><p>以字节为单位的每秒可写吞吐量。自1.2.2起。</p><h3 id="read-iops-sec"><a href="#read-iops-sec" class="headerlink" title="read_iops_sec"></a>read_iops_sec</h3><p>每秒i&#x2F;o读操作限制。自1.2.2起。</p><h3 id="write-iops-sec"><a href="#write-iops-sec" class="headerlink" title="write_iops_sec"></a>write_iops_sec</h3><p>每秒i&#x2F;o写操作限制。自1.2.2起。</p><h1 id="Resource-partitioning"><a href="#Resource-partitioning" class="headerlink" title="Resource partitioning"></a>Resource partitioning</h1><p>虚拟机管理程序可能允许将虚拟机放入资源分区，也可能嵌套所述分区。resource元素将与资源分区相关的配置项组织在一起。当前其支持partition子元素项，该子元素项的内容定义了放置虚拟机的资源分区的绝对路径。如果没有列出任何分区，虚拟机将会被放到默认分区中。应用程序或管理员有责任确保分区在虚拟机启动之前就已存在。只有默认分区（适用于特定虚拟机管理程序）可以默认假定已经存在。</p><pre><code>...&lt;resource&gt;  &lt;partition&gt;/virtualmachines/production&lt;/partition&gt;&lt;/resource&gt;...</code></pre><p>资源分区当前在qemu和lxc中受到支持，在所有已安装的控制器中将分区路径映射到cgroups目录。自1.0.5起。</p><h1 id="Fibre-Channel-VMID"><a href="#Fibre-Channel-VMID" class="headerlink" title="Fibre Channel VMID"></a>Fibre Channel VMID</h1><p>FC SAN可以提供多个依赖于VMID的QoS等级和访问控制功能。它还可以收集每个虚拟机的遥测数据，这些数据可用于增强虚拟机的IO性能。可以通过fibrechannel元素项的appid属性项进行配置。该属性项包含了简单的字符串（最大128字节），内核可使用该属性项创建VMID。</p><pre><code>...&lt;resource&gt;  &lt;fibrechannel appid=&#39;userProvidedID&#39;/&gt;&lt;/resource&gt;...</code></pre><p>使用该特征项要求支持光纤通道的硬件，内核编译时配置有 CONFIG_BLK_CGROUP_FC_APPID选项，且nvme_fc内核模块已加载。自7.7.0起。</p><p>本章节描述了用来代表作用域的xml文件格式，根据运行的作用于种类的格式变化，有一些可选配置项用来加载文件。对于特定虚拟机的细节可以查看<br><a href="https://libvirt.org/drivers.html">相关文件</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文网址：&lt;a href=&quot;https://libvirt.org/formatdomain.html#id8&quot; title=&quot;Domain XML format&quot;&gt;https://libvirt.org/formatdomain.html#id8&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="kvm" scheme="http://example.com/tags/kvm/"/>
    
    <category term="libvirt" scheme="http://example.com/tags/libvirt/"/>
    
    <category term="虚拟机xml配置文件" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BAxml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
    <category term="翻译" scheme="http://example.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="CPU model and topology" scheme="http://example.com/tags/CPU-model-and-topology/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】libvirt虚拟机xml配置文件格式（8）NUMA Node Tuning、Block I/O Tuning、Resource partitioning、Fibre Channel VMID</title>
    <link href="http://example.com/2022/11/14/domain_xml_format8_block_io_tuning_resource_partitioning_fibre_channel_vmid/"/>
    <id>http://example.com/2022/11/14/domain_xml_format8_block_io_tuning_resource_partitioning_fibre_channel_vmid/</id>
    <published>2022-11-14T08:10:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>原文网址：<a href="https://libvirt.org/formatdomain.html#id8" title="Domain XML format">https://libvirt.org/formatdomain.html#id8</a></p><span id="more"></span><h1 id="NUMA-Node-Tuning"><a href="#NUMA-Node-Tuning" class="headerlink" title="NUMA Node Tuning"></a>NUMA Node Tuning</h1><pre><code>&lt;domain&gt;  ...  &lt;numatune&gt;    &lt;memory mode=&quot;strict&quot; nodeset=&quot;1-4,^3&quot;/&gt;    &lt;memnode cellid=&quot;0&quot; mode=&quot;strict&quot; nodeset=&quot;1&quot;/&gt;    &lt;memnode cellid=&quot;2&quot; mode=&quot;preferred&quot; nodeset=&quot;2&quot;/&gt;  &lt;/numatune&gt;  ...&lt;/domain&gt;</code></pre><h2 id="numatune"><a href="#numatune" class="headerlink" title="numatune"></a>numatune</h2><p>可选元素项numatune提供了如何通过控制虚拟机进程的NUMA策略对NUMA主机的性能进行调度。注意，仅支持QEMU。自0.9.3起。</p><h2 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h2><p>可选元素项memory指明了如何对NUMA主机的虚拟机进程进行内存分配。其包含多个可选属性项。属性项mode的可用值包含interleave、strict、preferred和restrictive，默认设置为strict。restrictive指明使用系统默认策略，仅有cgroups被用来限制内存节点，在memnode元素中将mode设置为restrictive。属性项nodeset指明了numa节点，其与vcpu元素项的cpuset属性项使用相同的语法。属性项placement（自0.9.12起）可被用来表明虚拟机进程的内存放置模式，其值可以为static或auto，是vcpu的placement的默认值，如果指定了nodeset则默认值为static。auto表明虚拟机进程只会从查询numad返回的咨询节点中集中分配内存，属性nodeset的值在指定auto的情况下将会被忽略。如果vcpu的placement设置为auto，且numatune未指定，则numatune的placement设置为auto，mode设置为strict。自0.9.3起。参阅 virDomainSetNumaParameters获取该元素的更多信息。</p><h2 id="memnode"><a href="#memnode" class="headerlink" title="memnode"></a>memnode</h2><p>可选元素项memnode可以为每个虚拟机的numa节点指定内存分配策略。对于没有memnode元素的哪些节点，memory元素的默认值将会被使用。属性项cellid寻址应用设置的虚拟机NUMA节点。属性项mode和nodeset与memory元素中的对应值具有相同的含义和语法。设置与自动placement不兼容。qemu自1.2.7起。</p><h1 id="Block-I-x2F-O-Tuning"><a href="#Block-I-x2F-O-Tuning" class="headerlink" title="Block I&#x2F;O Tuning"></a>Block I&#x2F;O Tuning</h1><pre><code>&lt;domain&gt;  ...  &lt;blkiotune&gt;    &lt;weight&gt;800&lt;/weight&gt;    &lt;device&gt;      &lt;path&gt;/dev/sda&lt;/path&gt;      &lt;weight&gt;1000&lt;/weight&gt;    &lt;/device&gt;    &lt;device&gt;      &lt;path&gt;/dev/sdb&lt;/path&gt;      &lt;weight&gt;500&lt;/weight&gt;      &lt;read_bytes_sec&gt;10000&lt;/read_bytes_sec&gt;      &lt;write_bytes_sec&gt;10000&lt;/write_bytes_sec&gt;      &lt;read_iops_sec&gt;20000&lt;/read_iops_sec&gt;      &lt;write_iops_sec&gt;20000&lt;/write_iops_sec&gt;    &lt;/device&gt;  &lt;/blkiotune&gt;  ...&lt;/domain&gt;</code></pre><h2 id="blkiotune"><a href="#blkiotune" class="headerlink" title="blkiotune"></a>blkiotune</h2><p>可选元素项blkiotune为虚拟机提供了调节Blkio cgroup可调参数的能力。如果忽略该设置项，则其默认由操作系统提供。自0.8.8起。</p><h2 id="weight"><a href="#weight" class="headerlink" title="weight"></a>weight</h2><p>可选元素项weight是虚拟机的全部i&#x2F;o负载。该值的范围是100-1000.在2.6.39内核后，该值的范围是10-1000.</p><h2 id="device"><a href="#device" class="headerlink" title="device"></a>device</h2><p>虚拟机可能又有多个device元素项，以便深入调节虚拟机正在使用的每一个主机块设备的权重。注意多个磁盘（可参阅Hard drives, floppy disks, CDROMs章节）可能共享同一个主机块设备，如果他们被相同的主机文件系统中的文件备份，这也是为什么使用全局作用域的调节参数而非相关的每一个虚拟机磁盘设备的原因（与磁盘定义中的iotune元素项相反（可参阅Hard drives, floppy disks, CDROMs章节），而iotune元素项适用于单个独立的磁盘）。每一个device元素项有两个强制的子元素项，path描述了设备的绝对路径，而weight给出了设备的相对权重，权重范围是100-1000.在2.6.39版本内核之后，该值的范围变为10-1000.自0.9.8起。除此之外，也可使用如下的可选子元素项：</p><h3 id="read-bytes-sec"><a href="#read-bytes-sec" class="headerlink" title="read_bytes_sec"></a>read_bytes_sec</h3><p>以字节为单位的每秒可读吞吐量。自1.2.2起。</p><h3 id="write-bytes-sec"><a href="#write-bytes-sec" class="headerlink" title="write_bytes_sec"></a>write_bytes_sec</h3><p>以字节为单位的每秒可写吞吐量。自1.2.2起。</p><h3 id="read-iops-sec"><a href="#read-iops-sec" class="headerlink" title="read_iops_sec"></a>read_iops_sec</h3><p>每秒i&#x2F;o读操作限制。自1.2.2起。</p><h3 id="write-iops-sec"><a href="#write-iops-sec" class="headerlink" title="write_iops_sec"></a>write_iops_sec</h3><p>每秒i&#x2F;o写操作限制。自1.2.2起。</p><h1 id="Resource-partitioning"><a href="#Resource-partitioning" class="headerlink" title="Resource partitioning"></a>Resource partitioning</h1><p>虚拟机管理程序可能允许将虚拟机放入资源分区，也可能嵌套所述分区。resource元素将与资源分区相关的配置项组织在一起。当前其支持partition子元素项，该子元素项的内容定义了放置虚拟机的资源分区的绝对路径。如果没有列出任何分区，虚拟机将会被放到默认分区中。应用程序或管理员有责任确保分区在虚拟机启动之前就已存在。只有默认分区（适用于特定虚拟机管理程序）可以默认假定已经存在。</p><pre><code>...&lt;resource&gt;  &lt;partition&gt;/virtualmachines/production&lt;/partition&gt;&lt;/resource&gt;...</code></pre><p>资源分区当前在qemu和lxc中受到支持，在所有已安装的控制器中将分区路径映射到cgroups目录。自1.0.5起。</p><h1 id="Fibre-Channel-VMID"><a href="#Fibre-Channel-VMID" class="headerlink" title="Fibre Channel VMID"></a>Fibre Channel VMID</h1><p>FC SAN可以提供多个依赖于VMID的QoS等级和访问控制功能。它还可以收集每个虚拟机的遥测数据，这些数据可用于增强虚拟机的IO性能。可以通过fibrechannel元素项的appid属性项进行配置。该属性项包含了简单的字符串（最大128字节），内核可使用该属性项创建VMID。</p><pre><code>...&lt;resource&gt;  &lt;fibrechannel appid=&#39;userProvidedID&#39;/&gt;&lt;/resource&gt;...</code></pre><p>使用该特征项要求支持光纤通道的硬件，内核编译时配置有 CONFIG_BLK_CGROUP_FC_APPID选项，且nvme_fc内核模块已加载。自7.7.0起。</p><p>本章节描述了用来代表作用域的xml文件格式，根据运行的作用于种类的格式变化，有一些可选配置项用来加载文件。对于特定虚拟机的细节可以查看<br><a href="https://libvirt.org/drivers.html">相关文件</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文网址：&lt;a href=&quot;https://libvirt.org/formatdomain.html#id8&quot; title=&quot;Domain XML format&quot;&gt;https://libvirt.org/formatdomain.html#id8&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="kvm" scheme="http://example.com/tags/kvm/"/>
    
    <category term="libvirt" scheme="http://example.com/tags/libvirt/"/>
    
    <category term="虚拟机xml配置文件" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BAxml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
    <category term="翻译" scheme="http://example.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="NUMA Node Tuning" scheme="http://example.com/tags/NUMA-Node-Tuning/"/>
    
    <category term="Block I/O Tuning" scheme="http://example.com/tags/Block-I-O-Tuning/"/>
    
    <category term="Resource partitioning" scheme="http://example.com/tags/Resource-partitioning/"/>
    
    <category term="Fibre Channel VMID" scheme="http://example.com/tags/Fibre-Channel-VMID/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】libvirt虚拟机xml配置文件格式（7）Memory Allocation、Memory Backing和Memory Tuning</title>
    <link href="http://example.com/2022/11/10/domain_xml_format7_memory_allocation/"/>
    <id>http://example.com/2022/11/10/domain_xml_format7_memory_allocation/</id>
    <published>2022-11-10T03:56:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>原文网址：<a href="https://libvirt.org/formatdomain.html#id8" title="Domain XML format">https://libvirt.org/formatdomain.html#id8</a></p><span id="more"></span><h1 id="Memory-Allocation"><a href="#Memory-Allocation" class="headerlink" title="Memory Allocation"></a>Memory Allocation</h1><pre><code>&lt;domain&gt;  ...  &lt;maxMemory slots=&#39;16&#39; unit=&#39;KiB&#39;&gt;1524288&lt;/maxMemory&gt;  &lt;memory unit=&#39;KiB&#39;&gt;524288&lt;/memory&gt;  &lt;currentMemory unit=&#39;KiB&#39;&gt;524288&lt;/currentMemory&gt;  ...&lt;/domain&gt;</code></pre><h2 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h2><p>boot时虚拟机的最大分配内存。内存分配包含了在启动时或在之后热插拔的全部可能的额外内存设备。该值的单位由可选属性项unit设置，默认以KiB为单位（kibibytes，2^10或1024字节块）。有效的单位还有b或byte代表字节，KB代表kilobytes（10^3或1000字节），k或KiB代表kibibytes（1024字节）。MB代表megabytes（10^6或1000000字节），M或MiB代表 mebibytes（2^20或1048576字节），GB代表gigabytes（10^9或1000000000字节），T或TiB代表tebibytes（2^40或1099511627776字节）.然而，该值会被libvirt四舍五入到最近的kibibytes，也可能进一步四舍五入到虚拟机管理程序支持的粒度。一些虚拟机管理程序也会强制设置一个最小值，例如4000KiB。这种情况下，虚拟机配置的numa的memory元素会被忽略。如果发生crash，可选属性项dumpCore可用来控制是否将虚拟机内存包含在生成的coredump文件中（属性值为on和off）。unit自0.9.11起，dumpCore自0.10.2起（仅限于qemu）。</p><h2 id="maxMemory"><a href="#maxMemory" class="headerlink" title="maxMemory"></a>maxMemory</h2><p>运行时虚拟机的最大内存分配。被numa的memory元素或者numa cell大小配置的初始内存可通过内存热插拔方式增长到该元素限制的最大内存大小。unit属性项与memory中的同名属性项表现完全一致。slots属性项指定了将内存添加到虚拟机时可用slot的数量。数量上下限与虚拟机管理程序有关。注意由于内存对齐的限制，通过内存条热插拔所获得的完整内存大小可能无法达到该元素的设置值。自1.2.14起在qemu中支持。</p><h2 id="currentMemory"><a href="#currentMemory" class="headerlink" title="currentMemory"></a>currentMemory</h2><p>虚拟机真实分配的内存。该值小于最大分配数值，允许动态扩充虚拟机内存。如果未设置该项，则默认与memory元素具有同样的数值设置。unit属性项与memory中的unit作用一致。</p><h1 id="Memory-Backing"><a href="#Memory-Backing" class="headerlink" title="Memory Backing"></a>Memory Backing</h1><pre><code>&lt;domain&gt;  ...  &lt;memoryBacking&gt;    &lt;hugepages&gt;      &lt;page size=&quot;1&quot; unit=&quot;G&quot; nodeset=&quot;0-3,5&quot;/&gt;      &lt;page size=&quot;2&quot; unit=&quot;M&quot; nodeset=&quot;4&quot;/&gt;    &lt;/hugepages&gt;    &lt;nosharepages/&gt;    &lt;locked/&gt;    &lt;source type=&quot;file|anonymous|memfd&quot;/&gt;    &lt;access mode=&quot;shared|private&quot;/&gt;    &lt;allocation mode=&quot;immediate|ondemand&quot; threads=&#39;8&#39;/&gt;    &lt;discard/&gt;  &lt;/memoryBacking&gt;  ...&lt;/domain&gt;</code></pre><p>可选元素项memoryBacking包含多个影响主机内存页备份虚拟内存的元素项。</p><h2 id="hugepages"><a href="#hugepages" class="headerlink" title="hugepages"></a>hugepages</h2><p>该元素项告知虚拟机管理程序虚拟机使用大页而非通常的主机内存页大小进行内存分配。自1.2.5起。可以为每个numa节点详尽的设置大页。page元素项被引入。其包含一个强制属性项size用于指定具体使用哪些大页（在支持不同大小大页的系统中尤其有用）。size属性项的默认单位是kilobytes（1024的整数倍）。如果想要使用不同的单位，可使用可选属性项unit。对于numa系统，可选的nodeset属性可能会派上用场，因为它将给定虚拟机的NUMA节点与某些大页大小相关联。在某些例子中，除了4#节点之外的其他numa节点都使用了1G大小的大页。相关语法可以查看NUMA Node Tuning章节。</p><h2 id="nosharepages"><a href="#nosharepages" class="headerlink" title="nosharepages"></a>nosharepages</h2><p>告知虚拟机管理程序虚拟机禁用共享内存页（内存合并，ksm）。自1.0.6起。</p><h2 id="locked"><a href="#locked" class="headerlink" title="locked"></a>locked</h2><p>当虚拟机管理程序支持并设置相关数值后，虚拟机内存页将会在主机内存中锁定，而且主机也不会将其换出，这在某些工况下如实时场景中是十分必要的。对于QEMU&#x2F;KVM虚拟机，qemu进程自身使用的内存也会被锁定；与虚拟机内存不同，libvirt无法提前获取相应内存的数量，所以必须移除对于锁定内存的限制。因此，启用该可选元素项存在潜在的安全风险；当主机内存耗尽时主机无法从虚拟机回复内存，这就意味着大量的虚拟机将会造成大量内存被锁定，主机上会遭受到拒绝服务攻击。因为该原因，除非确实需要否则不建议使用该元素项；即便如此，强烈推荐为特定环境的内存分配设置 hard_limit属性项（参阅Memory Tuning章节），这可以有效的缓解上述描述的风险的发生。自1.0.6起。</p><h2 id="source"><a href="#source" class="headerlink" title="source"></a>source</h2><p>使用type属性项，可提供“file”以利用文件内存备份或保持默认的”anonymous”。自4.10.0起，也可选择memfd备份。（仅限于QEMU&#x2F;KVM）</p><h2 id="access"><a href="#access" class="headerlink" title="access"></a>access</h2><p>使用mode属性项，指明内存是shared还是private。该元素会被每个numa节点的memAccess元素覆盖。</p><h2 id="allocation"><a href="#allocation" class="headerlink" title="allocation"></a>allocation</h2><p>使用可选属性项mode，通过提供”immediate”或”ondemand”参数指明何时进行内存分配。自8.2.0起。也可以通过threads属性设置虚拟机管理程序用来进行内存分配的线程数量。</p><h2 id="discard"><a href="#discard" class="headerlink" title="discard"></a>discard</h2><p>当虚拟机管理程序支持并设置该元素时，在虚拟机关机之前（或当DIMM模块被拔出时）内存内容被丢弃。注意这仅仅只是一个优化项，并不保证在所有场景下都会起作用（例如虚拟机管理程序crash时）。自4.4.0起（仅限于QEMU&#x2F;KVM）。</p><h1 id="Memory-Tuning"><a href="#Memory-Tuning" class="headerlink" title="Memory Tuning"></a>Memory Tuning</h1><pre><code>&lt;domain&gt;  ...  &lt;memtune&gt;    &lt;hard_limit unit=&#39;G&#39;&gt;1&lt;/hard_limit&gt;    &lt;soft_limit unit=&#39;M&#39;&gt;128&lt;/soft_limit&gt;    &lt;swap_hard_limit unit=&#39;G&#39;&gt;2&lt;/swap_hard_limit&gt;    &lt;min_guarantee unit=&#39;bytes&#39;&gt;67108864&lt;/min_guarantee&gt;  &lt;/memtune&gt;  ...&lt;/domain&gt;</code></pre><h2 id="memtune"><a href="#memtune" class="headerlink" title="memtune"></a>memtune</h2><p>可选元素项memtune提供与虚拟机内存调度参数相关的细节描述。如果忽略该项设置，则默认由操作系统提供默认值。对于QEMU&#x2F;KVM，应用于qemu进程的参数被看做一个整体。因此，对其进行计数时，需要加上虚拟机ram、虚拟机显卡ram和qemu自身的一些内存。最后一点很难确定具体数值，因此需要猜想与尝试。对于每个可调参数，可以使用与memory相同的值来指定输入时数字所使用的单位。为了向后兼容，输出始终以KiB为单位。unit自0.9.11起。全部*_limit参数的可能值在0到VIR_DOMAIN_MEMORY_PARAM_UNLIMITED的范围内。</p><h2 id="hard-limit"><a href="#hard-limit" class="headerlink" title="hard_limit"></a>hard_limit</h2><p>可选元素项hard_limit是虚拟机可使用的最大内存。该值的单位是kibibytes（1024字节的块）。qemu和kvm的使用者清冽建议不要设置相关限制项，因为如果虚拟机运行过少则虚拟机可能被内核关闭，决定进程运行所需的内存是一个无法决定的问题；也就是说，如果因工况需要已在 Memory Backing中设置了locked属性，您必须考虑部署的具体细节，并确定一个足够大的hard_limit值，以支持您的虚拟机的内存需求，但是该值足够小也可以保护主机以避免虚拟机锁定全部的内存。</p><h2 id="soft-limit"><a href="#soft-limit" class="headerlink" title="soft_limit"></a>soft_limit</h2><p>可选元素项soft_limit就是内存争用期间强制设置的内存限制。该值的单位是kibibytes（1024字节块）。</p><h2 id="swap-hard-limit"><a href="#swap-hard-limit" class="headerlink" title="swap_hard_limit"></a>swap_hard_limit</h2><p>可选元素项swap_hard_limit就是加上交互内存swap后虚拟机可食用的最大内存。该值的单位是kibibytes（1024字节块）。该值应大于hard_limit的设置值。</p><h2 id="min-guarantee"><a href="#min-guarantee" class="headerlink" title="min_guarantee"></a>min_guarantee</h2><p>可选元素项min_guarantee就是应保证的虚拟机最小分配内存。该值的单位是kibibytes（1024字节块）。该元素仅被VMware ESX和OpenVZ支持。</p><p>本章节描述了用来代表作用域的xml文件格式，根据运行的作用于种类的格式变化，有一些可选配置项用来加载文件。对于特定虚拟机的细节可以查看<br><a href="https://libvirt.org/drivers.html">相关文件</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文网址：&lt;a href=&quot;https://libvirt.org/formatdomain.html#id8&quot; title=&quot;Domain XML format&quot;&gt;https://libvirt.org/formatdomain.html#id8&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="kvm" scheme="http://example.com/tags/kvm/"/>
    
    <category term="libvirt" scheme="http://example.com/tags/libvirt/"/>
    
    <category term="虚拟机xml配置文件" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BAxml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
    <category term="翻译" scheme="http://example.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="Memory Allocation" scheme="http://example.com/tags/Memory-Allocation/"/>
    
    <category term="Memory Backing" scheme="http://example.com/tags/Memory-Backing/"/>
    
    <category term="Memory Tuning" scheme="http://example.com/tags/Memory-Tuning/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】libvirt虚拟机xml配置文件格式（6）CPU Tuning</title>
    <link href="http://example.com/2022/11/04/domain_xml_format_CPU-tuning/"/>
    <id>http://example.com/2022/11/04/domain_xml_format_CPU-tuning/</id>
    <published>2022-11-04T06:35:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>原文网址：<a href="https://libvirt.org/formatdomain.html#id8" title="Domain XML format">https://libvirt.org/formatdomain.html#id8</a></p><span id="more"></span><pre><code>&lt;domain&gt;  ...  &lt;cputune&gt;    &lt;vcpupin vcpu=&quot;0&quot; cpuset=&quot;1-4,^2&quot;/&gt;    &lt;vcpupin vcpu=&quot;1&quot; cpuset=&quot;0,1&quot;/&gt;    &lt;vcpupin vcpu=&quot;2&quot; cpuset=&quot;2,3&quot;/&gt;    &lt;vcpupin vcpu=&quot;3&quot; cpuset=&quot;0,4&quot;/&gt;    &lt;emulatorpin cpuset=&quot;1-3&quot;/&gt;    &lt;iothreadpin iothread=&quot;1&quot; cpuset=&quot;5,6&quot;/&gt;    &lt;iothreadpin iothread=&quot;2&quot; cpuset=&quot;7,8&quot;/&gt;    &lt;shares&gt;2048&lt;/shares&gt;    &lt;period&gt;1000000&lt;/period&gt;    &lt;quota&gt;-1&lt;/quota&gt;    &lt;global_period&gt;1000000&lt;/global_period&gt;    &lt;global_quota&gt;-1&lt;/global_quota&gt;    &lt;emulator_period&gt;1000000&lt;/emulator_period&gt;    &lt;emulator_quota&gt;-1&lt;/emulator_quota&gt;    &lt;iothread_period&gt;1000000&lt;/iothread_period&gt;    &lt;iothread_quota&gt;-1&lt;/iothread_quota&gt;    &lt;vcpusched vcpus=&#39;0-4,^3&#39; scheduler=&#39;fifo&#39; priority=&#39;1&#39;/&gt;    &lt;iothreadsched iothreads=&#39;2&#39; scheduler=&#39;batch&#39;/&gt;    &lt;cachetune vcpus=&#39;0-3&#39;&gt;      &lt;cache id=&#39;0&#39; level=&#39;3&#39; type=&#39;both&#39; size=&#39;3&#39; unit=&#39;MiB&#39;/&gt;      &lt;cache id=&#39;1&#39; level=&#39;3&#39; type=&#39;both&#39; size=&#39;3&#39; unit=&#39;MiB&#39;/&gt;      &lt;monitor level=&#39;3&#39; vcpus=&#39;1&#39;/&gt;      &lt;monitor level=&#39;3&#39; vcpus=&#39;0-3&#39;/&gt;    &lt;/cachetune&gt;    &lt;cachetune vcpus=&#39;4-5&#39;&gt;      &lt;monitor level=&#39;3&#39; vcpus=&#39;4&#39;/&gt;      &lt;monitor level=&#39;3&#39; vcpus=&#39;5&#39;/&gt;    &lt;/cachetune&gt;    &lt;memorytune vcpus=&#39;0-3&#39;&gt;      &lt;node id=&#39;0&#39; bandwidth=&#39;60&#39;/&gt;    &lt;/memorytune&gt;  &lt;/cputune&gt;  ...&lt;/domain&gt;</code></pre><h1 id="cputune"><a href="#cputune" class="headerlink" title="cputune"></a>cputune</h1><p>可选元素项cputune为虚拟机提供与cpu可调参数相关的细节设置。注意：对于qemu驱动而言，可选的vcpupin和emulatorpin绑定设置需要考虑模拟器启动和NUMA限制后再进行设置。这就意味着主机的其他物理cpu在这段时间内会被虚拟机使用，这也可以从virsh cpu-stats的输出中反映出来。自0.9.0起。</p><h1 id="vcpupin"><a href="#vcpupin" class="headerlink" title="vcpupin"></a>vcpupin</h1><p>可选元素项vcpupin指明了虚拟机的vCPU将会被绑定到主机的哪一个物理CPU上。如果忽略该设置项，vcpu元素的cpuset属性项也没有设置，则vcpu会默认绑定到全部的物理cpu上。其包含两个所需的属性项，属性项vcpu指明了vcpu id，属性项cpuset与vcpu元素的cpuset属性项是完全一致的。qemu自0.9.0起被支持，xen自0.9.1起被支持。</p><h1 id="emulatorpin"><a href="#emulatorpin" class="headerlink" title="emulatorpin"></a>emulatorpin</h1><p>可选元素项emulatorpin元素指明了主机的拿个物理cpu是模拟器，这是不包含虚拟机的vcpu和iothreads绑定的cpu的子集。如果忽略该项设置，也没有设置vcpu的cpuset属性项，模拟器将会默认绑定到全部的物理cpu上。emulatorpin包含了一个必须的属性项cpuset用于指明要绑定到哪一个物理cpu中。</p><h1 id="iothreadpin"><a href="#iothreadpin" class="headerlink" title="iothreadpin"></a>iothreadpin</h1><p>可选元素项iothreadpin指明了IOThreads将会被绑定到哪一个物理cpu上。如果忽略该设置，且vcpu元素项的cpuset属性项也没有设置，IOThreads将会默认绑定到全部的物理cpu上。这里存在两个必须的属性项，属性项iothread指明了IOThread ID，属性项cpuset指明了绑定的物理cpu。可查看IOThreads Allocation章节查看iothread的有效值。自1.2.9起。</p><h1 id="shares"><a href="#shares" class="headerlink" title="shares"></a>shares</h1><p>可选元素项shares指明了虚拟机的比例加权份额。如果忽略该项设置，默认使用操作系统提供的默认值。注意，这个值没有单位，是建立在其他虚拟机设置上的相对量度。一个设置为2048的虚拟机将会相对另一个设置为1024的虚拟机得到两倍长的cpu时间。这个值得范围是2-262144.自0.9.0起。</p><h1 id="period"><a href="#period" class="headerlink" title="period"></a>period</h1><p>可选元素项period指明了执行间隔（单位：毫秒）。在该元素项内，虚拟机的每一个vcpu都不允许消耗超过配额的运行时间。该值的范围是1000-1000000.设置为0则意味着未设置数值。qemu自0.9.4起支持，lxc自0.9.10起支持。</p><h1 id="quota"><a href="#quota" class="headerlink" title="quota"></a>quota</h1><p>可选元素项quota指定了最大允许带宽（单位：毫秒）。quota设置为负值的虚拟机表明对于其vcpu线程具有无限制的带宽，即其不受带宽控制。该值的范围是1000-17592186044415或小于0.quota为0意味着未设置数值。可使用该特征确保所有的vcpu以相同速度运行。qemu自0.9.4起支持，lxc自0.9.10起支持。</p><h1 id="global-period"><a href="#global-period" class="headerlink" title="global_period"></a>global_period</h1><p>可选元素项global_period指定整个虚拟机的强制CFS调度程序间隔（单位：微秒），与强制每个vCPU间隔的period形成对比。该值的范围是1000-1000000.global_period设置为0意味着未设置数值。qemu自1.3.3起支持。</p><h1 id="global-quota"><a href="#global-quota" class="headerlink" title="global_quota"></a>global_quota</h1><p>可选元素项global_quota指明了全虚拟机在周期时间内的最大允许带宽（单位：毫秒）。global_quota设置为负值的虚拟机表明虚拟机具有无限制的带宽，即其不受带宽控制。该值的范围是1000-17592186044415或小于0.global_quota为0意味着未设置数值。qemu自1.3.3起支持。</p><h1 id="emulator-period"><a href="#emulator-period" class="headerlink" title="emulator_period"></a>emulator_period</h1><p>可选元素项emulator_period指明了强制间隔（单位：毫秒）。使用emulator_period设置，则虚拟机的模拟器线程（包括vcpu）不允许消耗超过emulator_quota的运行时间。该值的范围是1000-1000000.为0意味着未设置数值。qemu自0.10.0起支持.</p><h1 id="emulator-quota"><a href="#emulator-quota" class="headerlink" title="emulator_quota"></a>emulator_quota</h1><p>可选元素项emulator_quota指明了虚拟机模拟器线程（包括vcpu）最大允许带宽（单位：毫秒）。带有负值emulator_quota设置的虚拟机的模拟器线程（包括vcpu）拥有无限带宽，即其不受带宽控制。值范围是1000-17592186044415或小于0.quota设置为0意味着未设置值。qemu自0.10.0起支持.</p><h1 id="iothread-period"><a href="#iothread-period" class="headerlink" title="iothread_period"></a>iothread_period</h1><p>可选元素项iothread_period指明了IOThreads的强制间隔（单位：毫秒）。使用iothread_period，虚拟机的每一个IOThreads不允许消耗超过iothread_quota设置的运行时间。该值的范围是1000-1000000.设置为0意味着未设置该值。自2.1.0起支持qemu。</p><h1 id="iothread-quota"><a href="#iothread-quota" class="headerlink" title="iothread_quota"></a>iothread_quota</h1><p>可选元素项iothread_quota指明了IOThreads的最大允许带宽（单位：毫秒）。iothread_quota为负值的虚拟机表明虚拟机IOThreads具有无限带宽，即其不受带宽控制。该值的范围是1000-17592186044415或小于0.设置为0意味着未设置该值。可使用该特征确保全部IOThreads以相同速度运行。自2.1.0起支持qemu。</p><h1 id="vcpusched-x2F-iothreadsched-x2F-emulatorsched"><a href="#vcpusched-x2F-iothreadsched-x2F-emulatorsched" class="headerlink" title="vcpusched&#x2F;iothreadsched&#x2F;emulatorsched"></a>vcpusched&#x2F;iothreadsched&#x2F;emulatorsched</h1><p>可选元素项vcpusched、iothreadsched和emulatorsched分别指明了特定vcpu、iothread和模拟器线程的调度类型（值为batch、idle、fifo和rr）。对于vcpusched和iothreadsched，属性项vcpus和iothreads选择了该设置适用于哪些vCPUs&#x2F;IOThreads，其余的设置为默认值。元素项emulatorsched不具有该属性。vcpus的有效值为0到虚拟机中设置的vcpu数量减一。iothreads的有效值在IOThreads Allocation章节中有过描述。如果未定义iothreadids，然后libvirt将IOThreads编号从1到虚拟机可用的iothreads进行计数。对于实时调度（fifo、rr），也需指定优先级（非实时调度可忽略）。优先级的范围依赖于主机内核（通常为1-99）。自1.2.13起。emulatorsched自5.3.0起。</p><h1 id="cachetune（自4-1-0起）"><a href="#cachetune（自4-1-0起）" class="headerlink" title="cachetune（自4.1.0起）"></a>cachetune（自4.1.0起）</h1><p>可选元素项cachetune使用主机上的restctrl控制cpu缓存分配。是否支持此功能可以从一些限制（如最小尺寸和所需粒度）的功能中获取。必需的属性项vcpus指定了本次分配适用于哪一个vcpu。一个vcpu只能是一个cachetune元素分配项的成员。cachetune指定的vCPU可以与memorytune 中的vCPU相同，但不允许重复指定。可选的、仅输出的id属性唯一标识缓存。支持以下子元素：</p><h2 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h2><p>该可选元素项控制cpu缓存分配并具有以下属性项：</p><h3 id="level"><a href="#level" class="headerlink" title="level"></a>level</h3><p>用于分配的主机缓存等级。</p><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>用于分配的主机缓存id。</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>分配的类型。code代表指令，data代表数据。both则同时代表两者。当前分配类型只能与主机支持的类型保持一致，意味着不能在启用cdp（指令、数据优先级）的主机上使用both类型。</p><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>分配区域大小。默认值以字节为单位，但是unit属性项可用来缩放该值。</p><h3 id="unit-可选"><a href="#unit-可选" class="headerlink" title="unit(可选)"></a>unit(可选)</h3><p>如果unit设置为KiB、MiB、GiB或TiB（在Memory Allocation中的memory元素中描述），则size的默认值为字节。</p><h2 id="monitor（自4-10-0起）"><a href="#monitor（自4-10-0起）" class="headerlink" title="monitor（自4.10.0起）"></a>monitor（自4.10.0起）</h2><p>可选元素项monitor为当前缓存分配创建缓存管理器并拥有如下所需属性：</p><h3 id="level-1"><a href="#level-1" class="headerlink" title="level"></a>level</h3><p>monitor所属的主机缓存等级。</p><h3 id="vcpus"><a href="#vcpus" class="headerlink" title="vcpus"></a>vcpus</h3><p>vcpu列出了monitor的适用范围。一个monitor的vcpu列表只能是相关分配的vcpu列表的一部分。默认的管理器与相关的分配具有相同的vcpu列表。对于非默认monitor，不允许重复定义vcpu。</p><h1 id="memorytune（自4-7-0起）"><a href="#memorytune（自4-7-0起）" class="headerlink" title="memorytune（自4.7.0起）"></a>memorytune（自4.7.0起）</h1><p>可选元素项memorytune可使用主机上的resctrl控制内存带宽分配。是否支持此功能可以从一些限制（如最小尺寸和所需粒度）功能中获取。必需的属性项vcpus指定了本次分配适用于哪一个vcpu。一个vcpu只能是一个memorytune元素分配项的成员。memorytune指定的vCPU可以与cachetune中的vCPU相同，但不允许重复指定。支持以下子元素：</p><h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><p>该元素控制cpu内存带宽分配，拥有以下属性。</p><h3 id="id-1"><a href="#id-1" class="headerlink" title="id"></a>id</h3><p>分配内存带宽的主机节点id。</p><h3 id="bandwidth"><a href="#bandwidth" class="headerlink" title="bandwidth"></a>bandwidth</h3><p>节点中用于分配的内存带宽。该值默认以百分比为单位。</p><p>本章节描述了用来代表作用域的xml文件格式，根据运行的作用于种类的格式变化，有一些可选配置项用来加载文件。对于特定虚拟机的细节可以查看<br><a href="https://libvirt.org/drivers.html">相关文件</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文网址：&lt;a href=&quot;https://libvirt.org/formatdomain.html#id8&quot; title=&quot;Domain XML format&quot;&gt;https://libvirt.org/formatdomain.html#id8&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="kvm" scheme="http://example.com/tags/kvm/"/>
    
    <category term="libvirt" scheme="http://example.com/tags/libvirt/"/>
    
    <category term="虚拟机xml配置文件" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BAxml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
    <category term="翻译" scheme="http://example.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="CPU Tuning" scheme="http://example.com/tags/CPU-Tuning/"/>
    
  </entry>
  
  <entry>
    <title>_access函数32bit和64bit编译差异</title>
    <link href="http://example.com/2022/10/20/access_usage/"/>
    <id>http://example.com/2022/10/20/access_usage/</id>
    <published>2022-10-20T07:00:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近，在进行软件开发工作中遇到了一个问题，觉得比较有趣，在此进行以下记录。</p><p>问题比较简单，需要检查windows系统下的C:\Windows\System32路径下是否存在特定的用户文件（dll格式）。在这里使用_access函数（C运行库函数）对文件进行检查，该函数主要用于检查文件或目录是否存在及其对应的读写权限。但是开发完成后，在自检过程中却发现使用_access函数无法达到预期，主要表现为文件已存在，但是函数返回结果却表明文件不存在。如果换用win32 API函数PathFileExistsA却正常，文件存在于对应目录。本文即对_access函数的异常进行分析。</p><span id="more"></span><h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><p>win32函数访问没问题，而使用C语言库函数存在问题，即系统调用没问题，主要问题应该出现在C语言库上。而最简单的修改项就是编译环境修改，之前为了兼容性考虑，代码选择的编译环境为32位，因此将编译环境改为64位。此时，_access函数正常执行，返回了符合预期的结果。</p><p>因此，针对这一点进行分析，最终在微软官网上找到相关说明，链接如下：<a href="https://learn.microsoft.com/en-us/windows/win32/winprog64/file-system-redirector?from_wecom=1" title="【Microsoft】文件系统重定向">https://learn.microsoft.com/en-us/windows/win32/winprog64/file-system-redirector?from_wecom&#x3D;1</a>；</p><p>微软在64位操作系统上，为64位应用程序保留了%windir%\System32（通常就是C:\Windows\System32）路径。因为通常情况下，32位dll和64位dll的文件名称完全相同，因此64位dll也保存在System32路径下，而32位dll则被保存在其他路径。这就使得64位操作系统下的32位应用程序访问对应dll时，直接访问%windir%\System32路径是错误的，因此微软为64位系统下的32位程序通过访问%windir%\System32路径做了重定向。而32位要想真正访问%windir%\System32路径，就可以使用%windir%\Sysnative路径替代，也可以使用Wow64DisableWow64FsRedirection函数禁用文件重定向功能。</p><p>示例程序：</p><pre><code>#include  &lt;io.h&gt;#include  &lt;stdio.h&gt;#include  &lt;stdlib.h&gt;#include &lt;Windows.h&gt;#include &lt;iostream&gt;#include &quot;Shlwapi.h&quot;#include &lt;errhandlingapi.h &gt;int main( void )&#123;    char *file_path = &quot;C:\\Windows\\System32\\test.dll&quot;;    char *file_path1 = &quot;C:\\Windows\\Sysnative\\test.dll&quot;;    // Check for existence.    printf_s( &quot;1.access system32.\n&quot;);    if( (_access( file_path, 0 )) != -1 )    &#123;        printf_s( &quot;File %s is exists.\n&quot;, file_path);    &#125;    else    &#123;        printf_s( &quot;File %s isn&#39;t exists.\n&quot;, file_path);    &#125;    printf_s( &quot;2.access sysnative.\n&quot;);    if( (_access( file_path1, 0 )) != -1 )    &#123;        printf_s( &quot;File %s is exists.\n&quot;, file_path1);    &#125;    else    &#123;        printf_s( &quot;File %s isn&#39;t exists.\n&quot;, file_path1);    &#125;    PVOID OldValue = NULL;    //  Disable redirection immediately prior to the native API function call.    printf_s( &quot;3.Disable Redirection.\n&quot;);    bool flag = Wow64DisableWow64FsRedirection(&amp;OldValue);    printf(&quot;Wow64DisableWow64FsRedirection return value is %d.\n&quot;, flag);    if (!flag)    &#123;        DWORD dw = GetLastError();        printf(&quot;Errorcode is %d.\n&quot;, dw);    &#125;    if( (_access( file_path, 0 )) != -1 )    &#123;        printf_s( &quot;File %s is exists.\n&quot;, file_path);    &#125;    else    &#123;        printf_s( &quot;File %s isn&#39;t exists.\n&quot;, file_path);    &#125;    return 0;&#125;</code></pre><p>在32位编译环境下输出如下：</p><pre><code>1.access system32.File C:\Windows\System32\test.dll isn&#39;t exists.2.access sysnative.File C:\Windows\Sysnative\test.dll is exists.3.Disable Redirection.Wow64DisableWow64FsRedirection return value is 1.File C:\Windows\System32\test.dll is exists.</code></pre><p>（1）C:\Windows\System32路径无法直接访问；</p><p>（2）C:\Windows\Sysnative路径会被重定位到C:\Windows\System32；</p><p>（3）Wow64DisableWow64FsRedirection函数返回1代表函数正常运行，此后再使用C:\Windows\System32路径，则无重定向操作，获取到了正确的结果；</p><p>在64位编译环境下输出如下：</p><pre><code>1.access system32.File C:\Windows\System32\test.dll is exists.2.access sysnative.File C:\Windows\Sysnative\test.dll isn&#39;t exists.3.Disable Redirection.Wow64DisableWow64FsRedirection return value is 0.Errorcode is 1.File C:\Windows\System32\test.dll is exists.</code></pre><p>（1）C:\Windows\System32路径可以直接访问；</p><p>（2）C:\Windows\Sysnative路径不会被重定位到C:\Windows\System32；</p><p>（3）Wow64DisableWow64FsRedirection函数返回0代表函数异常运行，但不影响后续使用C:\Windows\System32路径获取正确的结果；</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>_access函数在32bit和64bit编译环境下输出结果存在差异，主要原因即为64位windows操作系统下，%windir%\System32被保留给了对应的64位应用程序，而32位应用程序访问%windir%\System32路径时就会被重定向到系统指定的其他路径上。而使用32bit编译环境最终生成的是32位应用程序，因此对应路径被重定向，直接访问%windir%\System32路径下的文件时就会出现异常。</p><p>因此建议在64位操作系统中使用64位的应用程序，而非32位的应用程序，虽然64位操作系统兼容32位应用程序，而32位操作系统不兼容64位应用程序，因此32位具有更广泛的兼容性。</p><p>如果不确定目标程序运行环境或程序存在运行于两种系统的使用场景，则在使用文件访问相关函数时：</p><p>（1）直接使用win32函数PathFileExistsA；</p><p>（2）使用_access函数前，先使用Wow64DisableWow64FsRedirection函数禁用文件重定向功能；</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>（1）<a href="https://learn.microsoft.com/en-us/windows/win32/winprog64/file-system-redirector?from_wecom=1" title="【Microsoft】文件系统重定向">https://learn.microsoft.com/en-us/windows/win32/winprog64/file-system-redirector?from_wecom&#x3D;1</a>；<br>（2）<a href="https://learn.microsoft.com/en-us/windows/win32/api/wow64apiset/nf-wow64apiset-wow64disablewow64fsredirection?from_wecom=1" title="【Microsoft】Wow64DisableWow64FsRedirection函数">https://learn.microsoft.com/en-us/windows/win32/api/wow64apiset/nf-wow64apiset-wow64disablewow64fsredirection?from_wecom&#x3D;1</a>；<br>（3）<a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/access-waccess?view=msvc-170&from_wecom=1" title="【Microsoft】_access函数">https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/access-waccess?view=msvc-170&from_wecom&#x3D;1</a>；<br>（4）<a href="https://learn.microsoft.com/en-us/windows/win32/api/shlwapi/nf-shlwapi-pathfileexistsa?from_wecom=1" title="【Microsoft】PathFileExistsA函数">https://learn.microsoft.com/en-us/windows/win32/api/shlwapi/nf-shlwapi-pathfileexistsa?from_wecom&#x3D;1</a>；</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近，在进行软件开发工作中遇到了一个问题，觉得比较有趣，在此进行以下记录。&lt;/p&gt;
&lt;p&gt;问题比较简单，需要检查windows系统下的C:\Windows\System32路径下是否存在特定的用户文件（dll格式）。在这里使用_access函数（C运行库函数）对文件进行检查，该函数主要用于检查文件或目录是否存在及其对应的读写权限。但是开发完成后，在自检过程中却发现使用_access函数无法达到预期，主要表现为文件已存在，但是函数返回结果却表明文件不存在。如果换用win32 API函数PathFileExistsA却正常，文件存在于对应目录。本文即对_access函数的异常进行分析。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="_access函数" scheme="http://example.com/tags/access%E5%87%BD%E6%95%B0/"/>
    
    <category term="编译环境" scheme="http://example.com/tags/%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/"/>
    
    <category term="文件检查" scheme="http://example.com/tags/%E6%96%87%E4%BB%B6%E6%A3%80%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】libvirt虚拟机xml配置文件格式（5）IOThreads Allocation</title>
    <link href="http://example.com/2022/10/19/domain_xml_format_IOThreads-Allocation/"/>
    <id>http://example.com/2022/10/19/domain_xml_format_IOThreads-Allocation/</id>
    <published>2022-10-19T09:36:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>原文网址：<a href="https://libvirt.org/formatdomain.html#id8" title="Domain XML format">https://libvirt.org/formatdomain.html#id8</a></p><p>IOThreads是支持磁盘设备的专用事件循环线程，用于执行块I&#x2F;O请求，以提高可伸缩性，尤其是在具有许多LUN的SMP主机&#x2F;客户机上。自1.2.8起（仅限于QEMU）。</p><span id="more"></span><pre><code>&lt;domain&gt;  ...  &lt;iothreads&gt;4&lt;/iothreads&gt;  ...&lt;/domain&gt;&lt;domain&gt;  ...  &lt;iothreadids&gt;    &lt;iothread id=&quot;2&quot;/&gt;    &lt;iothread id=&quot;4&quot;/&gt;    &lt;iothread id=&quot;6&quot;/&gt;    &lt;iothread id=&quot;8&quot; thread_pool_min=&quot;2&quot; thread_pool_max=&quot;32&quot;/&gt;  &lt;/iothreadids&gt;  &lt;defaultiothread thread_pool_min=&quot;8&quot; thread_pool_max=&quot;16&quot;/&gt;  ...&lt;/domain&gt;</code></pre><h1 id="iothreads"><a href="#iothreads" class="headerlink" title="iothreads"></a>iothreads</h1><p>此可选元素的内容定义要分配给虚拟机以供支持的目标存储设备使用的 IOThread数量。每一个主机CPU只有1个或2个IOThread。可能有多个受支持的设备分配给每个IOThread。自1.2.8起。</p><h1 id="iothreadids"><a href="#iothreadids" class="headerlink" title="iothreadids"></a>iothreadids</h1><p>可选的iothreadids元素提供了为虚拟机专门定义IOThread ID的能力。默认情况下，IOThread ID 是从1到为虚拟机定义的iothreads的数量顺序编号的。id属性项用于定义IOThread ID。id属性项必须是一个大于0的正整数。如果定义的iothreadids少于为虚拟机定义的iothreads，则libvirt将从1开始按顺序填充iothreadids，避免任何预定义的id。如果iothreadids大于为虚拟机定义的iothreads，iothreads的值将会相应调整。自1.2.15起。该元素有两个可选属性项thread_pool_min和thread_pool_max用于定义给定IOThread工作线程的上下限。前者可能是0，后者绝不会为0.自8.5.0起。</p><h1 id="defaultiothread"><a href="#defaultiothread" class="headerlink" title="defaultiothread"></a>defaultiothread</h1><p>该元素代表了虚拟机管理程序内部的默认事件循环，为指定特定IOThread的I&#x2F;O请求会被该循环处理。该元素可设置thread_pool_min和thread_pool_max属性项，指定了默认事件循环工作线程的上下限数量。模拟器可能是多线程的并按需生成所谓的工作线程。通常两个属性项都不会去设置（使得模拟器使用其自身的默认值），除非模拟器在实时工作负载中运行，因此无法承受生成新工作线程所需时间的不可预测性。自8.5.0起。</p><p>本章节描述了用来代表作用域的xml文件格式，根据运行的作用于种类的格式变化，有一些可选配置项用来加载文件。对于特定虚拟机的细节可以查看<br><a href="https://libvirt.org/drivers.html">相关文件</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文网址：&lt;a href=&quot;https://libvirt.org/formatdomain.html#id8&quot; title=&quot;Domain XML format&quot;&gt;https://libvirt.org/formatdomain.html#id8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;IOThreads是支持磁盘设备的专用事件循环线程，用于执行块I&amp;#x2F;O请求，以提高可伸缩性，尤其是在具有许多LUN的SMP主机&amp;#x2F;客户机上。自1.2.8起（仅限于QEMU）。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="kvm" scheme="http://example.com/tags/kvm/"/>
    
    <category term="libvirt" scheme="http://example.com/tags/libvirt/"/>
    
    <category term="虚拟机xml配置文件" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BAxml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
    <category term="翻译" scheme="http://example.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="IOThreads Allocation" scheme="http://example.com/tags/IOThreads-Allocation/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】libvirt虚拟机xml配置文件格式（4）CPU Allocation</title>
    <link href="http://example.com/2022/09/05/domain_xml_format_CPU-Allocation/"/>
    <id>http://example.com/2022/09/05/domain_xml_format_CPU-Allocation/</id>
    <published>2022-09-05T11:01:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>原文网址：<a href="https://libvirt.org/formatdomain.html#id8" title="Domain XML format">https://libvirt.org/formatdomain.html#id8</a></p><span id="more"></span><pre><code>&lt;domain&gt;  ...  &lt;vcpu placement=&#39;static&#39; cpuset=&quot;1-4,^3,6&quot; current=&quot;1&quot;&gt;2&lt;/vcpu&gt;  &lt;vcpus&gt;    &lt;vcpu id=&#39;0&#39; enabled=&#39;yes&#39; hotpluggable=&#39;no&#39; order=&#39;1&#39;/&gt;    &lt;vcpu id=&#39;1&#39; enabled=&#39;no&#39; hotpluggable=&#39;yes&#39;/&gt;  &lt;/vcpus&gt;  ...&lt;/domain&gt;</code></pre><h1 id="vcpu"><a href="#vcpu" class="headerlink" title="vcpu"></a>vcpu</h1><p>该元素定义了分配给客户机操作系统的虚拟cpu的最大数量，该值范围为1到虚拟机管理器支持的最大数量之间。</p><h2 id="cpuset"><a href="#cpuset" class="headerlink" title="cpuset"></a>cpuset</h2><p>可选属性cpuset是以逗号分隔的物理CPU编号列表，默认情况下虚拟机进程和虚拟CPU可以固定到对应编号的物理CPU上。（注意：虚拟机进程和虚拟cpu的绑定（pinning）策略可以由cputune分别指定。如果cputune的属性项emulatorpin被设置，则vcpu指定的cpuset将会被忽略。对于vcpupin指定的虚拟cpu，cpuset制定的cpuset也会被忽略。vcpupin未指定的虚拟cpu，每一个都会被绑定到cpuset指定的物理cpu上）。列表中的每一个元素可以是一个单独的cpu编号、cpu编号范围或是插入符号后跟要从先前范围中排除的CPU编号。自0.4.4版本起支持。</p><h2 id="current"><a href="#current" class="headerlink" title="current"></a>current</h2><p>可选属性current可用于指定是否应启用少于最大数量的虚拟CPU。从 0.8.5开始。</p><h2 id="placement"><a href="#placement" class="headerlink" title="placement"></a>placement</h2><p>可选属性placement可用来表明虚拟机进程的cpu布局模式。该值可为static或auto，但是如果指定了cpuset，则默认numatune的placement设置为static。使用auto表示虚拟机进程将通过查询numa固定到咨询节点集，如果指定了属性cpuset的值，则将被忽略。如果cpuset和placement都没有指定或placement设置为static，但是cpuset为指定，则虚拟机进程将会被绑定到所有的可用物理cpu上。自0.9.11起（仅限于QEMU和KVM）。</p><h1 id="vcpus"><a href="#vcpus" class="headerlink" title="vcpus"></a>vcpus</h1><p>vcpus元素项运行控制单个vCPU的状态。id属性项指定了libvirt在其他地方使用的vCPU id，例如vCPU绑定、调度程序信息和NUMA分配。请注意，在某些情况下，客户机中看到的vCPU ID可能与libvirt ID不同。有效ID 从0到vcpu元素设置的最大vCPU计数减 1。enabled属性项允许控制vCPU的状态。有效值为yes和no。hotpluggable控制在引导开机时启用CPU是否可以热插拔和热拔出给定的vCPU。请注意，所有禁用的vCPU必须是可热插拔的。有效值为yes和no。order允许指定在线vCPU的顺序。对于需要一次插入多个vCPU的虚拟机管理器&#x2F;平台，该顺序可能会在需要一次启用的所有 vCPU上重复。顺序不强制指定。然后以任意顺序添加vCPU。如果使用了顺序信息，它必须用于所有在线vCPU。虚拟机管理器可能在单一操作期间清理或更新顺序信息。请注意，虚拟机管理器可能会创建不同于引导vCPU的热插拔vCPU，因此可能需要进行特殊初始化。虚拟机管理器可能要求启动时启用的不可热插拔的vCPU在开始时从ID 0开始聚集。可能还需要vCPU 0始终存在且不可热插拔。请注意，可能需要为单个CPU提供状态以支持可寻址的 vCPU热插拔，并且此功能可能不受所有虚拟机管理器的支持。QEMU要求实现以下条件。vCPU 0需启用并设置为不可热插拔。在PPC64上，同样需要启用同一内核中的vCPU。引导开机时存在的所有非热插拔CPU都需要在vCPU 0 之后进行分组。自2.2.0起（仅限于QEMU）。</p><p>本章节描述了用来代表作用域的xml文件格式，根据运行的作用于种类的格式变化，有一些可选配置项用来加载文件。对于特定虚拟机的细节可以查看<br><a href="https://libvirt.org/drivers.html">相关文件</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文网址：&lt;a href=&quot;https://libvirt.org/formatdomain.html#id8&quot; title=&quot;Domain XML format&quot;&gt;https://libvirt.org/formatdomain.html#id8&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="kvm" scheme="http://example.com/tags/kvm/"/>
    
    <category term="libvirt" scheme="http://example.com/tags/libvirt/"/>
    
    <category term="虚拟机xml配置文件" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BAxml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
    <category term="翻译" scheme="http://example.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="CPU Allocation" scheme="http://example.com/tags/CPU-Allocation/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】libvirt虚拟机xml配置文件格式（3）SMBIOS System Information</title>
    <link href="http://example.com/2022/09/02/domain_xml_format_SMBIOS-System-Information/"/>
    <id>http://example.com/2022/09/02/domain_xml_format_SMBIOS-System-Information/</id>
    <published>2022-09-02T09:00:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>原文网址：<a href="https://libvirt.org/formatdomain.html#id8" title="Domain XML format">https://libvirt.org/formatdomain.html#id8</a></p><p>一些虚拟机管理器运行控制呈现给客户机的系统信息（例如虚拟机管理器可以填充SMBIOS并通过客户机的dmidecode指令进行检查）。可选元素项sysinfo包含了所有此类信息。自0.8.7版本起。</p><span id="more"></span><pre><code>...&lt;os&gt;  &lt;smbios mode=&#39;sysinfo&#39;/&gt;  ...&lt;/os&gt;&lt;sysinfo type=&#39;smbios&#39;&gt;  &lt;bios&gt;    &lt;entry name=&#39;vendor&#39;&gt;LENOVO&lt;/entry&gt;  &lt;/bios&gt;  &lt;system&gt;    &lt;entry name=&#39;manufacturer&#39;&gt;Fedora&lt;/entry&gt;    &lt;entry name=&#39;product&#39;&gt;Virt-Manager&lt;/entry&gt;    &lt;entry name=&#39;version&#39;&gt;0.9.4&lt;/entry&gt;  &lt;/system&gt;  &lt;baseBoard&gt;    &lt;entry name=&#39;manufacturer&#39;&gt;LENOVO&lt;/entry&gt;    &lt;entry name=&#39;product&#39;&gt;20BE0061MC&lt;/entry&gt;    &lt;entry name=&#39;version&#39;&gt;0B98401 Pro&lt;/entry&gt;    &lt;entry name=&#39;serial&#39;&gt;W1KS427111E&lt;/entry&gt;  &lt;/baseBoard&gt;  &lt;chassis&gt;    &lt;entry name=&#39;manufacturer&#39;&gt;Dell Inc.&lt;/entry&gt;    &lt;entry name=&#39;version&#39;&gt;2.12&lt;/entry&gt;    &lt;entry name=&#39;serial&#39;&gt;65X0XF2&lt;/entry&gt;    &lt;entry name=&#39;asset&#39;&gt;40000101&lt;/entry&gt;    &lt;entry name=&#39;sku&#39;&gt;Type3Sku1&lt;/entry&gt;  &lt;/chassis&gt;  &lt;oemStrings&gt;    &lt;entry&gt;myappname:some arbitrary data&lt;/entry&gt;    &lt;entry&gt;otherappname:more arbitrary data&lt;/entry&gt;  &lt;/oemStrings&gt;&lt;/sysinfo&gt;&lt;sysinfo type=&#39;fwcfg&#39;&gt;  &lt;entry name=&#39;opt/com.example/name&#39;&gt;example value&lt;/entry&gt;  &lt;entry name=&#39;opt/com.coreos/config&#39; file=&#39;/tmp/provision.ign&#39;/&gt;&lt;/sysinfo&gt;...</code></pre><p>sysinfo元素包含一个强制属性项type决定了子元素的布局，支持值如下：</p><h1 id="smbios"><a href="#smbios" class="headerlink" title="smbios"></a>smbios</h1><p>子元素调用特定的SMBIOS值，如果被用在os元素（参照Operating system booting）的smbios子元素间的连接上，将会影响客户机。sysinfo 的每个子元素命名一个SMBIOS块，并且在这些元素中可以是描述块内字段的条目元素列表。识别以下块和条目：</p><h2 id="bios"><a href="#bios" class="headerlink" title="bios"></a>bios</h2><p>这是SMBIOS的块0，条目名称来自：</p><ul><li>vender：BIOS供应商名称</li><li>version：BIOS版本</li><li>date：BIOS发行日期。如果提供了该元素项，则会改为mm&#x2F;dd&#x2F;yy或mm&#x2F;dd&#x2F;yyyy的格式。如果字符串的年部分只有两个数字，则将会假定为19yy年。</li></ul><h2 id="system"><a href="#system" class="headerlink" title="system"></a>system</h2><p>这是SMBIOS的块1，条目名称来自：</p><ul><li>manufacturer：BIOS制造商</li><li>product：产品名称</li><li>version：产品版本</li><li>serial：序列号</li><li>uuid：统一唯一标识符。如果该条目与顶层的uuid的一起设定，则两个元素值必须相同</li><li>sku：识别特定配置的sku编号</li><li>family：识别特定计算机所属的家族系列</li></ul><h2 id="baseBoard"><a href="#baseBoard" class="headerlink" title="baseBoard"></a>baseBoard</h2><p>这是SMBIOS的块2.该元素项可以重复多次用以描述所有的基板（base board）；然而，并不是所有的虚拟机管理器都支持该元素项重复。该元素项有下列的子元素项：</p><ul><li>manufacturer：BIOS的制造商</li><li>product：产品名称</li><li>version：产品版本号</li><li>serial：序列号</li><li>asset：资产标签</li><li>location：机箱内的位置</li></ul><p><strong>注意：bios、system和baseBoard块的错误条目会被忽略，而不会报错。除了uuid验证和日期格式检查之外，所有值都作为字符串传递给虚拟机管理器驱动程序。</strong></p><h2 id="chassis"><a href="#chassis" class="headerlink" title="chassis"></a>chassis</h2><p>自4.1.0起支持。SMBIOS的块3，条目名称来自：</p><ul><li>manufacturer：机箱的制造商</li><li>version：机箱的版本号</li><li>serial：序列号</li><li>asset：资产标签</li><li>sku：sku编号</li></ul><h2 id="oemStrings"><a href="#oemStrings" class="headerlink" title="oemStrings"></a>oemStrings</h2><p>SMBIOS的块11.该元素项只出现一次，却有多个entry子元素项，每一个都提供随机字符串数据。对于entry提供的数据并没有任何限制，如果数据打算由客户机中的应用程序使用，建议使用应用程序名称作为字符串中的前缀。（自4.1.0起支持）</p><h1 id="fwcfg"><a href="#fwcfg" class="headerlink" title="fwcfg"></a>fwcfg</h1><p>一些虚拟机管理器提供统一的方法来调整固件如何配置自身，或者可能包含要为客户机操作系统安装的表，例如引导顺序、ACPI、SMBIOS等。</p><p>如果允许用户自定义自己的配置blob（config blob）。在QEMU的例子中，然后这些出现在domain的sysfs下（如果客户机内核启用FW_CFG_SYSFS配置项），即&#x2F;sys&#x2F;firmware&#x2F;qemu_fw_cfg路径下。注意，这些值适用于<os/>下的<smbios/>模式。自6.5.0起支持。</p><p><strong>注意：由于数据槽数量有限，强烈建议不要使用fwcfg，而应使用 <oemStrings/>。</strong></p><pre><code>&lt;sysinfo type=&#39;fwcfg&#39;&gt;  &lt;entry name=&#39;opt/com.example/name&#39;&gt;example value&lt;/entry&gt;  &lt;entry name=&#39;opt/com.example/config&#39; file=&#39;/tmp/provision.ign&#39;/&gt;&lt;/sysinfo&gt;</code></pre><p>sysinfo元素项拥有多个entry子元素。每一个元素都有强制的name属性，它定义了blob的名称，并且必须以opt&#x2F;开头，并且为了避免与其他名称冲突，建议采用opt&#x2F;$RFQDN&#x2F;$name形式，其中$RFQDN是控制的反向完全限定域名。之后，元素项也可以包含相应数值（直接设置blob值），或者file属性项（从file中设置blob值）。</p><p>本章节描述了用来代表作用域的xml文件格式，根据运行的作用于种类的格式变化，有一些可选配置项用来加载文件。对于特定虚拟机的细节可以查看<br><a href="https://libvirt.org/drivers.html">相关文件</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文网址：&lt;a href=&quot;https://libvirt.org/formatdomain.html#id8&quot; title=&quot;Domain XML format&quot;&gt;https://libvirt.org/formatdomain.html#id8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一些虚拟机管理器运行控制呈现给客户机的系统信息（例如虚拟机管理器可以填充SMBIOS并通过客户机的dmidecode指令进行检查）。可选元素项sysinfo包含了所有此类信息。自0.8.7版本起。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="kvm" scheme="http://example.com/tags/kvm/"/>
    
    <category term="libvirt" scheme="http://example.com/tags/libvirt/"/>
    
    <category term="虚拟机xml配置文件" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BAxml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
    <category term="翻译" scheme="http://example.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="SMBIOS System Information" scheme="http://example.com/tags/SMBIOS-System-Information/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】libvirt虚拟机xml配置文件格式（2）Operating system booting</title>
    <link href="http://example.com/2022/08/31/domain_xml_format_Operating-system-booting/"/>
    <id>http://example.com/2022/08/31/domain_xml_format_Operating-system-booting/</id>
    <published>2022-08-31T11:00:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>原文网址：<a href="https://libvirt.org/formatdomain.html#id8" title="Domain XML format">https://libvirt.org/formatdomain.html#id8</a></p><p>这里有很多不同的方法用来引导操作系统开机，每一个都有优点与缺点。</p><span id="more"></span><h1 id="BIOS-bootloader"><a href="#BIOS-bootloader" class="headerlink" title="BIOS bootloader"></a>BIOS bootloader</h1><p>支持全虚拟化（full virtualization）的虚拟机管理程序可以通过BIOS引导开机。在这种情况下，BIOS存在开机顺序优先级（软盘floppy、硬盘harddisk、光盘cdrom、网络network）决定到哪里去获取&#x2F;查找开机镜像（boot image）。</p><pre><code>&lt;!-- Xen with fullvirt loader --&gt;&lt;!-- 使用全虚拟化加载器的Xen--&gt;...&lt;os&gt;  &lt;type&gt;hvm&lt;/type&gt;  &lt;loader&gt;/usr/lib/xen/boot/hvmloader&lt;/loader&gt;  &lt;boot dev=&#39;hd&#39;/&gt;&lt;/os&gt;...&lt;!-- QEMU with default firmware, serial console and SMBIOS --&gt;&lt;!-- 使用默认的硬件、串行控制台和SMBIOS的QEMU--&gt;...&lt;os&gt;  &lt;type&gt;hvm&lt;/type&gt;  &lt;boot dev=&#39;cdrom&#39;/&gt;  &lt;bootmenu enable=&#39;yes&#39; timeout=&#39;3000&#39;/&gt;  &lt;smbios mode=&#39;sysinfo&#39;/&gt;  &lt;bios useserial=&#39;yes&#39; rebootTimeout=&#39;0&#39;/&gt;&lt;/os&gt;...&lt;!-- QEMU with UEFI manual firmware and secure boot --&gt;&lt;!-- 使用UEFI手动固件和安全启动的QEMU--&gt;...&lt;os&gt;  &lt;type&gt;hvm&lt;/type&gt;  &lt;loader readonly=&#39;yes&#39; secure=&#39;yes&#39; type=&#39;pflash&#39;&gt;/usr/share/OVMF/OVMF_CODE.fd&lt;/loader&gt;  &lt;nvram template=&#39;/usr/share/OVMF/OVMF_VARS.fd&#39;&gt;/var/lib/libvirt/nvram/guest_VARS.fd&lt;/nvram&gt;  &lt;boot dev=&#39;hd&#39;/&gt;&lt;/os&gt;...&lt;!-- QEMU with UEFI manual firmware, secure boot and with NVRAM type &#39;file&#39;--&gt;&lt;!-- 使用UEFI手动固件、安全启动和NVRAM类型文件的QEMU--&gt;...&lt;os&gt;  &lt;type&gt;hvm&lt;/type&gt;  &lt;loader readonly=&#39;yes&#39; secure=&#39;yes&#39; type=&#39;pflash&#39;&gt;/usr/share/OVMF/OVMF_CODE.fd&lt;/loader&gt;  &lt;nvram type=&#39;file&#39; template=&#39;/usr/share/OVMF/OVMF_VARS.fd&#39;&gt;    &lt;source file=&#39;/var/lib/libvirt/nvram/guest_VARS.fd&#39;/&gt;  &lt;/nvram&gt;  &lt;boot dev=&#39;hd&#39;/&gt;&lt;/os&gt;...&lt;!-- QEMU with UEFI manual firmware, secure boot and with network backed NVRAM&#39;--&gt;&lt;!-- 使用UEFI手动固件、安全启动和网络支持的NVRAM的QEMU--&gt;...&lt;os&gt;  &lt;type&gt;hvm&lt;/type&gt;  &lt;loader readonly=&#39;yes&#39; secure=&#39;yes&#39; type=&#39;pflash&#39;&gt;/usr/share/OVMF/OVMF_CODE.fd&lt;/loader&gt;  &lt;nvram type=&#39;network&#39;&gt;    &lt;source protocol=&#39;iscsi&#39; name=&#39;iqn.2013-07.com.example:iscsi-nopool/0&#39;&gt;      &lt;host name=&#39;example.com&#39; port=&#39;6000&#39;/&gt;      &lt;auth username=&#39;myname&#39;&gt;        &lt;secret type=&#39;iscsi&#39; usage=&#39;mycluster_myname&#39;/&gt;      &lt;/auth&gt;    &lt;/source&gt;  &lt;/nvram&gt;  &lt;boot dev=&#39;hd&#39;/&gt;&lt;/os&gt;...&lt;!-- QEMU with automatic UEFI firmware and secure boot --&gt;&lt;!-- 使用自动UEFI固件和安全启动的QEMU--&gt;...&lt;os firmware=&#39;efi&#39;&gt;  &lt;type&gt;hvm&lt;/type&gt;  &lt;loader secure=&#39;yes&#39;/&gt;  &lt;boot dev=&#39;hd&#39;/&gt;&lt;/os&gt;...&lt;!-- QEMU with automatic UEFI stateless firmware for AMD SEV --&gt;&lt;!-- 使用适用于AMD SEV的自动UEFI无状态固件的QEMU--&gt;...&lt;os firmware=&#39;efi&#39;&gt;  &lt;type&gt;hvm&lt;/type&gt;  &lt;loader stateless=&#39;yes&#39;/&gt;  &lt;boot dev=&#39;hd&#39;/&gt;&lt;/os&gt;...</code></pre><h2 id="firmware固件"><a href="#firmware固件" class="headerlink" title="firmware固件"></a>firmware固件</h2><p>firmware属性项允许管理程序自动填充<loader/>和<nvram/>元素，通过选择的固件可以使能启用一些必须的特征项。可接受的值为bios和efi。选择过程扫描在特定位置的描述已安装固件镜像的文件，使用最具体的一个填充domain的需求。选择的位置（从通用到最具体的一个）如下：</p><ul><li>&#x2F;usr&#x2F;share&#x2F;qemu&#x2F;firmware</li><li>&#x2F;etc&#x2F;qemu&#x2F;firmware</li><li>$XDG_CONFIG_HOME&#x2F;qemu&#x2F;firmware</li></ul><p>对于更多信息，可以参考QEMU代码库中的docs&#x2F;interop&#x2F;firmware.json描述的固件元数据规范。常规用户可不关心这一点。从libvirt 5.2.0（仅限于QEMU和KVM）版本开始。</p><p>对于VMware客户机，当客户机使用UEFI时则必须设置为efi，使用BIOS时可以不设置。从libvirt 5.3.0（VMware ESX和Workstation&#x2F;Player）版本开始。</p><h2 id="type类型"><a href="#type类型" class="headerlink" title="type类型"></a>type类型</h2><p>type属性项指明了在虚拟机中启动的操作系统的类型。</p><ul><li>hvm表明操作系统被设计用来在裸机（bare metal）上运行，因此需要全虚拟化。</li><li>linux（糟糕的命名）表明是一个支持Xen 3虚拟机管理程序客户机ABI的操作系统。</li><li>【可选】arch表明了需要虚拟化的CPU架构。</li><li>【可选】machine表明了机器类型。</li></ul><p>xml功能（Capabilities XML）章节描述了允许值得详细信息。大多数虚拟机管理程序的驱动程序都省略了arch的设置，则所在主机host的架构就会被选择。对于test、ESX和VMWare虚拟机管理程序驱动程序，在x86_64主机上通常会选择i686架构。从libvirt 0.0.1版本开始提供支持。</p><h2 id="firmware固件-1"><a href="#firmware固件-1" class="headerlink" title="firmware固件"></a>firmware固件</h2><p>从libvirt 7.2.0版本开始仅对QEMU&#x2F;KVM提供支持。</p><p>当使用固件自动选择功能时，固件中存在不同的可用特征。特征列表限制了为虚拟机自动选择的固件。特征列表也可以通过使用0或更多的feature元素进行指定。选择硬件时，libvirt只会考虑列表中的特征，忽略其他特征项。</p><h3 id="feature"><a href="#feature" class="headerlink" title="feature"></a>feature</h3><p>强制属性列表：</p><ul><li><p>enabled：可用值为<strong>yes</strong>和<strong>no</strong>，告诉libvirt在自动选择固件时是否要启用或禁用对应特征项</p></li><li><p>name：特征项名称，特征值如下表所示：</p><ul><li><p>enrolled-keys:选择的nvram模板是否有默认证书注册。带有安全启动（Secure Boot）特征的固件如果没有注册密钥，将会以无签名二进制文件成功开机。仅针对带有安全启动（Secure Boot）特征的固件进行校验。</p></li><li><p>secure-boot:固件是否实现UEFI安全启动（Secure Boot）特征。</p></li></ul></li></ul><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>可选配置项loader标签指的是固件blob，通过绝对路径指定，被用来辅助domain创建过程。该标签为Xen全虚拟化domain使用，也被用来为QEMU&#x2F;KVM domain设置QEMU BIOS文件路径。Xen自libvirt 0.1.0版本后被支持，QEMU&#x2F;KVM自libvirt 0.9.12版本后被支持。该元素有两个可选的属性项：readonly（可用值为yes或no）表明镜像是可写的还是只读的。第二个属性项type可用值为rom和pflash。其告诉虚拟机管理程序文件应该被映射到客户机内存的什么位置上。例如，如果loader的路径指向一个UEFI镜像，type就应该是pflash。此外，一些固件会实现安全启动（Secure Boot）功能。属性项secure可以向虚拟机管理程序表明固件是否兼容安全启动（Secure Boot）功能。它不能用于在固件中启用或禁用功能本身。自libvirt 2.1.0版本后被支持.如果loader被标记为只读（read-only），之后在UEFI环境下，其会假定这里存在一个可用的可写NVRAM。在某些情况下，loader更倾向于在无 NVRAM环境下运行，在关机时丢弃任何配置变化。stateless标识（自libvirt 8.6.0版本后被支持）可被用来控制这种行为，如果设置为n，o则NVRAM将永远不会被创建。</p><h2 id="nvram"><a href="#nvram" class="headerlink" title="nvram"></a>nvram</h2><p>一些UEFI固件可能想要使用一个非易失性存储器去保存一些变量。在主机中，这表示为一个文件，文件的绝对路径被保存在这一元素中。此外，当domain启动时，libvirt复制在qemu.conf中定义的所谓的主NVRAM存储文件。如果必要的话，template属性可用于配置文件中主NVRAM存储的每个域的覆盖映射。对于非持久性domain，如果NVRAM文件已由libvirt创建，则它会被留下，并且管理程序有责任保存和删除文件（如果需要持久保存）。自1.2.8起。</p><p>自8.5.0版本起，该元素拥有type属性项（可用值为file、block和network）。在这种情况下，NVRAM存储器被<source>子元素使用和disk源相同的语法进行阐述。详情可参阅Hard drives, floppy disks, CDROMs章节。</p><p>注意：network支持的NVRAM不是从template中实例化的，因此使用者需人为提供一个可用的NVRAM镜像。</p><p>如果loader被标记为stateless，则提供该元素是无效的。</p><h2 id="boot"><a href="#boot" class="headerlink" title="boot"></a>boot</h2><p>dev属性项使用fd、hd、cdrom和network等值。用于指定下一个要考虑的引导设备。boot元素可以重复多次以安装用于轮流尝试的引导设备优先级列表。多个相同类型的设备根据它们的目标进行排序，同时保留总线的顺序。在define完domain后，libvirt返回XML配置（通过virDomainGetXMLDesc）列出已排好序的设备。排序完成之后，第一个设备被标记为可引导的（bootable）。配置为从“hd”引导且分配有vdb、hda、vda和hdc磁盘的域将从vda引导启动（排序列表为vda、vdb、hda、hdc）。类似的带有hdc、vda、vdb和hda磁盘的domain竟会从hda（磁盘排序为：hda、hdc、vda和vdb）引导启动。以所需方式进行配置将会十分麻烦，这就是引入每个设备引导元素的原因，也是提供对引导顺序的完全控制的首选方式。boot元素和每个设备引导元素是互斥的。boot元素自0.1.3起提供支持，per-device boot自0.8.8起提供支持。</p><h2 id="smbios"><a href="#smbios" class="headerlink" title="smbios"></a>smbios</h2><p>如何填充客户机中可见的SMBIOS信息。mode属性项必须被指定，其值为emulate（虚拟机管理程序生成所有值）、host（从主机的SMBIOS值中复制除UUID之外的全部Block 0 和Block 1；virConnectGetSysinfo函数调用可以被用来查看哪些值被复制）或sysinfo（使用 SMBIOS System Information元素中的值）。如果未制定，则虚拟机管理程序默认使用。从0.8.7版本起提供支持。</p><p>到目前为止，BIOS&#x2F;UEFI配置旋钮足够通用，可以由大多数（不是全部）固件实现。然而，从现在开始，并不是每一个单项配置都对所有固件起作用。例如，rebootTimeout对UEFI无作用，useserial可能对不产生输出到串行行的BIOS固件有影响等等。此外，固件经常不能导出其功能以便libvirt（或使用者）进行检查。固件功能的集合会随着新版本而发生变化。因此，建议用户在生产中依赖它们之前尝试他们使用的设置。</p><h2 id="bootmenu"><a href="#bootmenu" class="headerlink" title="bootmenu"></a>bootmenu</h2><p>在客户机启动时是否启用交互式引导菜单提示。enable属性项可以是yes或no。如果没有指明，虚拟机见识程序默认使用该功能。自0.8.3版本提供支持。额外的属性项timeout指明需要多少毫秒等待启动菜单，直到它超时。允许的值是 [0, 65535] 范围内的数字，除非 enable 设置为“yes”，否则该属性项会被忽略。自1.2.8版本提供支持。</p><h2 id="bios"><a href="#bios" class="headerlink" title="bios"></a>bios</h2><p>该元素属性项useserial可用值为yes或no。该属性项启用或禁用串行图形适配器（Serial Graphics Adapter）功能，该功能可以使得用户在串口上看到BIOS信息。因此，需定义串口。自0.9.4版本起。自0.10.2版本起（仅限于QEMU）。还有另外一个属性项rebootTimeout，当引导启动失败时，该属性想决定是否重启以及间隔多长时间后再次尝试引导启动。该值以毫秒为单位，最大值为65535，特殊值-1禁用重启功能。</p><h1 id="Host-bootloader"><a href="#Host-bootloader" class="headerlink" title="Host bootloader"></a>Host bootloader</h1><p>采用半虚拟化的管理程序通常不会模拟BIOS，而是主机负责启动操作系统引导。在主机中使用pseudo-bootloader提供接口以便为客户机选择一个内核。一个例子便是Xen的pygrub。而Bhyve虚拟机管理程序也使用主机bootloader方式，bhyveload或grub-bhyve。</p><h2 id="bootloader"><a href="#bootloader" class="headerlink" title="bootloader"></a>bootloader</h2><p>bootloader提供了主机操作系统中引导加载程序可执行文件的完全限定路径。运行bootloader选择要引导的内核。引导加载程序所需的输出取决于使用的管理程序。自0.1.1起。</p><h2 id="bootloader-args"><a href="#bootloader-args" class="headerlink" title="bootloader_args"></a>bootloader_args</h2><p>可选配置项bootloader_args允许将命令行参数传递给bootloader。自0.2.3起。</p><h1 id="Direct-kernel-boot"><a href="#Direct-kernel-boot" class="headerlink" title="Direct kernel boot"></a>Direct kernel boot</h1><p>安装一个新的客户机操作系统时，直接从存储在主机操作系统中的内核和 initrd引导通常很有用，可以将命令行参数直接传递给安装程序。该功能可在半虚拟化和全虚拟化客户机中使用。</p><pre><code>...&lt;os&gt;  &lt;type&gt;hvm&lt;/type&gt;  &lt;loader&gt;/usr/lib/xen/boot/hvmloader&lt;/loader&gt;  &lt;kernel&gt;/root/f8-i386-vmlinuz&lt;/kernel&gt;  &lt;initrd&gt;/root/f8-i386-initrd&lt;/initrd&gt;  &lt;cmdline&gt;console=ttyS0 ks=http://example.com/f8-i386/os/&lt;/cmdline&gt;  &lt;dtb&gt;/root/ppc.dtb&lt;/dtb&gt;  &lt;acpi&gt;    &lt;table type=&#39;slic&#39;&gt;/path/to/slic.dat&lt;/table&gt;  &lt;/acpi&gt;&lt;/os&gt;...</code></pre><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>该属性项与之前在BIOS bootloader中的描述有相同的语义。</p><h2 id="loader-1"><a href="#loader-1" class="headerlink" title="loader"></a>loader</h2><p>该属性项与之前在BIOS bootloader中的描述有相同的语义。</p><h2 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h2><p>该属性项指明了主机中内核镜像的全限定路径。</p><h2 id="initrd"><a href="#initrd" class="headerlink" title="initrd"></a>initrd</h2><p>该属性项指明了主机中ramdisk镜像（可选项）的全限定路径。</p><h2 id="cmdline"><a href="#cmdline" class="headerlink" title="cmdline"></a>cmdline</h2><p>该属性项指明了引导启动时传递给内核（或安装程序）的参数。这经常被用来指定备用主控制台（或串口）、安装媒体源&#x2F;kickstart 文件。</p><h2 id="dtb"><a href="#dtb" class="headerlink" title="dtb"></a>dtb</h2><p>该元素项指明了主机中的设备树二进制（device tree binary，dtb）镜像的全限定路径。从1.0.4版本起提供支持。</p><h2 id="acpi"><a href="#acpi" class="headerlink" title="acpi"></a>acpi</h2><p>table元素包含了ACPI（Advanced Configuration and Power Interface，高级配置和电源接口）表。type属性项包含ACPI表类型（当前只有slic被支持）。自1.3.5支持QEMU。自5.9.0支持Xen。</p><h1 id="Container-boot"><a href="#Container-boot" class="headerlink" title="Container boot"></a>Container boot</h1><p>当使用基于虚拟化的容器引导启动一个虚拟机时，可不使用内核&#x2F;引导镜像，使用init元素指定init二进制文件的路径。默认无参数加载。为指明初始化参数，使用initarg参数项，根据需要重复多次。如果设置了cmdline元素，将会被用来提供一个&#x2F;proc&#x2F;cmdline的替代项，但是却不会影响初始化参数（init argv）。</p><p>使用initenv元素设置环境变量，一个元素代表一个变量。</p><p>使用initdir元素为初始化设置特定的工作目录。</p><p>以给定的用户或用户组运行初始化命令，分别使用inituser或initgroup。两个元素可以被用来提供用户id或用户名称。使用**a+**前缀用户或组ID将强制将其视为数值。如果没有该项，它将首先作为用户名或组名进行尝试。</p><pre><code>&lt;os&gt;  &lt;type arch=&#39;x86_64&#39;&gt;exe&lt;/type&gt;  &lt;init&gt;/bin/systemd&lt;/init&gt;  &lt;initarg&gt;--unit&lt;/initarg&gt;  &lt;initarg&gt;emergency.service&lt;/initarg&gt;  &lt;initenv name=&#39;MYENV&#39;&gt;some value&lt;/initenv&gt;  &lt;initdir&gt;/my/custom/cwd&lt;/initdir&gt;  &lt;inituser&gt;tester&lt;/inituser&gt;  &lt;initgroup&gt;1000&lt;/initgroup&gt;&lt;/os&gt;</code></pre><p>如果想要使用用户命名空间，设置idmap属性项。uid和gid元素有3个属性项：</p><ul><li><p>start：容器的第一个用户ID。其值为0.</p></li><li><p>target：容器的第一个用户ID将会映射到主机中的目标用户ID。</p></li><li><p>count：映射到主机中的用户的容器用户数量。</p>  <idmap>    <uid start='0' target='1000' count='10'/>    <gid start='0' target='1000' count='10'/>  </idmap></li></ul><p>本章节描述了用来代表作用域的xml文件格式，根据运行的作用于种类的格式变化，有一些可选配置项用来加载文件。对于特定虚拟机的细节可以查看<br><a href="https://libvirt.org/drivers.html">相关文件</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文网址：&lt;a href=&quot;https://libvirt.org/formatdomain.html#id8&quot; title=&quot;Domain XML format&quot;&gt;https://libvirt.org/formatdomain.html#id8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里有很多不同的方法用来引导操作系统开机，每一个都有优点与缺点。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="kvm" scheme="http://example.com/tags/kvm/"/>
    
    <category term="libvirt" scheme="http://example.com/tags/libvirt/"/>
    
    <category term="虚拟机xml配置文件" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BAxml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
    <category term="翻译" scheme="http://example.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="Operating system booting" scheme="http://example.com/tags/Operating-system-booting/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】libvirt虚拟机xml配置文件格式（1）General metadata</title>
    <link href="http://example.com/2022/08/20/domain_xml_format_general-metadata/"/>
    <id>http://example.com/2022/08/20/domain_xml_format_general-metadata/</id>
    <published>2022-08-20T07:56:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>原文网址：<a href="https://libvirt.org/formatdomain.html#id8" title="Domain XML format">https://libvirt.org/formatdomain.html#id8</a></p><p>所有的虚拟机都需要的根元素是domain。其包含两个属性项，typo属性项指明了被用来运行虚拟机的虚拟机管理程序（hypervisor）。该项允许的数值与驱动相关，包含了xen、kvm、hvf（从8.1.0和QEMU 2.12版本起）、qemu和lxc。第二个属性项是id，代表运行客户机（guest）的一个唯一数字标识符。不活跃的客户机没有id。</p><span id="more"></span><pre><code>&lt;domain type=&#39;kvm&#39; id=&#39;1&#39;&gt;  &lt;name&gt;MyGuest&lt;/name&gt;  &lt;uuid&gt;4dea22b3-1d52-d8f3-2516-782e98ab3fa0&lt;/uuid&gt;  &lt;genid&gt;43dc0cf8-809b-4adb-9bea-a9abb5f3d90e&lt;/genid&gt;  &lt;title&gt;A short description - title - of the domain&lt;/title&gt;  &lt;description&gt;Some human readable description&lt;/description&gt;  &lt;metadata&gt;    &lt;app1:foo xmlns:app1=&quot;http://app1.org/app1/&quot;&gt;..&lt;/app1:foo&gt;    &lt;app2:bar xmlns:app2=&quot;http://app1.org/app2/&quot;&gt;..&lt;/app2:bar&gt;  &lt;/metadata&gt;  ...</code></pre><h1 id="name名称"><a href="#name名称" class="headerlink" title="name名称"></a>name名称</h1><p>name元素的内容为虚拟机提供了一个小名。这个名称应该仅由字母或数字字符组成，同时在母机（host）范围内该名称必须是唯一的。该名称经常被用来生成文件以储存持久化配置文件。</p><h1 id="uuid统一唯一标识符"><a href="#uuid统一唯一标识符" class="headerlink" title="uuid统一唯一标识符"></a>uuid统一唯一标识符</h1><p>uuid属性项的内容为虚拟机提供了一个全局唯一标识符。uuid的格式必须符合RFC 4122标准，例如<em>3e3fce45-4f53-4fa7-bb32-11f34168b82b</em>。该属性项可以省略，那么当定义define或创建一个新的虚拟机时，会生成一个随机的uuid。也可以通过<br>SMBIOS System Information规范提供uuid。（uuid从libvirt 0.0.1版本起提供支持，sysinfo从libvirt 0.8.7版本起提供支持）</p><h1 id="genid代际id"><a href="#genid代际id" class="headerlink" title="genid代际id"></a>genid代际id</h1><p>从libvirt 4.4.0版本开始，genid属性项使用与uuid相同格式的一个128位、随机加密的整数数值标识符代表全局唯一标识符（Globally Unique Identifier，即GUID），为虚拟机增加一个代际id。当虚拟机重复运行之前已经运行的某些操作时，该值用来帮助通知客户机。例如：</p><ul><li>虚拟机开始执行一个快照</li><li>虚拟机从备份中恢复</li><li>虚拟机陷入到故障恢复操作中</li><li>虚拟机正在导入import、拷贝copy或克隆clone</li></ul><p>客户机操作系统注意到了这些变化，通过标记分布式数据库的拷贝为脏数据、重新初始化它的随机数生成器等操作做出正常的反应。</p><p>libvirt xml解析器既可以接受给定的GUID数值，也可以未配置的情况，这时会生成一个GUID并保存在xml文件中。对于上述的过渡性操作，libvirt将会在重新运行之前改变GUID。</p><h1 id="title标题"><a href="#title标题" class="headerlink" title="title标题"></a>title标题</h1><p>title是可选配置项，为domain提供了一个简短的描述空间。title中不应该包含任何换行。从libvirt 0.9.10版本开始提供对title的支持。</p><h1 id="description描述"><a href="#description描述" class="headerlink" title="description描述"></a>description描述</h1><p>description属性项为虚拟机提供了一个人类易读的描述。该数据不会被libvirt使用，但是却包含用户想要的所有内容。从libvirt 0.7.2版本开始提供支持。</p><h1 id="metadata元数据"><a href="#metadata元数据" class="headerlink" title="metadata元数据"></a>metadata元数据</h1><p>metadata节点可以被应用程序以xml节点（node）&#x2F;树（tree）的形式用来存储特定数据。应用程序必须使用xml节点（node）&#x2F;树（tree）中的特定命名空间（namespace），每一个命名空间只有一个顶层（top-level）元素（如果应用程序需要使用结构体，则在其命名空间元素下存在相应子元素）。从libvirt 0.9.10版本开始提供支持。</p><p>本章节描述了用来代表作用域的xml文件格式，根据运行的作用于种类的格式变化，有一些可选配置项用来加载文件。对于特定虚拟机的细节可以查看<br><a href="https://libvirt.org/drivers.html">相关文件</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文网址：&lt;a href=&quot;https://libvirt.org/formatdomain.html#id8&quot; title=&quot;Domain XML format&quot;&gt;https://libvirt.org/formatdomain.html#id8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所有的虚拟机都需要的根元素是domain。其包含两个属性项，typo属性项指明了被用来运行虚拟机的虚拟机管理程序（hypervisor）。该项允许的数值与驱动相关，包含了xen、kvm、hvf（从8.1.0和QEMU 2.12版本起）、qemu和lxc。第二个属性项是id，代表运行客户机（guest）的一个唯一数字标识符。不活跃的客户机没有id。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="kvm" scheme="http://example.com/tags/kvm/"/>
    
    <category term="libvirt" scheme="http://example.com/tags/libvirt/"/>
    
    <category term="虚拟机xml配置文件" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BAxml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
    <category term="翻译" scheme="http://example.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="General metadata" scheme="http://example.com/tags/General-metadata/"/>
    
  </entry>
  
  <entry>
    <title>哲学三思之一：我是谁</title>
    <link href="http://example.com/2022/08/18/who_am_i-202208181900/"/>
    <id>http://example.com/2022/08/18/who_am_i-202208181900/</id>
    <published>2022-08-18T10:56:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个理科生，我其实并不是十分喜欢哲学，对于一个无法证实或证伪的学科，实在是觉得谈哲学更近似于谈玄，打嘴炮为主。但是在社会生活中，哲学的诸多理论却实在的影响着人类生活的方方面面。尤其是终极三问，我是谁、我从哪里来、我到哪里去是很多人都十分感兴趣的话题，我也不例外。</p><span id="more"></span><p>对于宗教教徒来说，我是谁这个问题就简单了很多，我是神的选民或神的子民，既增加了教众的全体认同感，也使得教众多了一份相对于异教徒或无信者的优越感。我不是信徒，因此不能单纯的以神的选民的身份来搪塞自己，因此就必须实实在在的思考这个问题。</p><p>对于人而言，人的自我认同部分集中于其社会关系上，家人、朋友、同事等种种的社会关系塑造了人的外在形象，别人根据这个形象相互交往，而人自身往往也在主动或被动的维护着这个形象。但是面具戴久了，往往很难摘下来，不知不觉中，很多人产生了我为别人活的想法，认为自己主要在维护着一个光鲜的外部形象，却从没有为自己而活。我却不同意这个想法，维护外在形象固然有社会形象的影响，但更多的还是人自己的选择，因为外在形象获得社会的认同，如果不是自身乐在其中，又怎么会数十年不厌其烦的扮演呢。而后面的抱怨，也无非是生活或工作遇到了挫折，对于维护外在形象的动力减弱，但是如果再次有正反馈传来，很多人还是乐此不疲。</p><p>但是，哲学考虑的更加深入，外部的社会关系其实是一个可以重复的条件，换言之，如果另一个人拥有和自己相同的外部社会关系，那是不是就说明别人也可以成为自己，自己并不是独一无二的。站在科学的角度，如果我们可以精确的定义人及其生活环境的一切变量，那我们自然可以说可以塑造出一个人出来，把自己作为独一无二是一种傲慢，把自己作为不可复制也是一种傲慢。但是事实是在可见的未来，我们还没有办法算尽一切，因此我们也许可以制造出生物意义上的人，但这个人却无法代替你，即他不是你。如果真的有一天存在那样的高位文明可以复制你的一切，但是他们这么做有什么意义呢？最恶劣的猜想，你对于他们来说只是一个小白鼠，用于满足他们对于人这个物种的研究之用，那又如何？人的强大不是单体的强大，而是人组成的社会或文明总体的强大，一时的强弱并不重要，只要有前进的决心与努力，文明就会精彩，人生也是如此。</p><p>所以，与其思考我是谁这样的哲学命题，倒不如抓紧时间做事，做事就是做人，保持前进的欲望，走弯路也强过原地踏步。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;作为一个理科生，我其实并不是十分喜欢哲学，对于一个无法证实或证伪的学科，实在是觉得谈哲学更近似于谈玄，打嘴炮为主。但是在社会生活中，哲学的诸多理论却实在的影响着人类生活的方方面面。尤其是终极三问，我是谁、我从哪里来、我到哪里去是很多人都十分感兴趣的话题，我也不例外。&lt;/p&gt;</summary>
    
    
    
    <category term="哲学" scheme="http://example.com/categories/%E5%93%B2%E5%AD%A6/"/>
    
    
    <category term="终极三问" scheme="http://example.com/tags/%E7%BB%88%E6%9E%81%E4%B8%89%E9%97%AE/"/>
    
  </entry>
  
  <entry>
    <title>Virtio-设备模拟详解</title>
    <link href="http://example.com/2021/11/09/virtio-202111091100/"/>
    <id>http://example.com/2021/11/09/virtio-202111091100/</id>
    <published>2021-11-09T03:00:00.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是virtio"><a href="#什么是virtio" class="headerlink" title="什么是virtio"></a>什么是virtio</h2><p>virtio 是一种 I&#x2F;O 半虚拟化解决方案，是一套通用 I&#x2F;O 设备虚拟化的程序，是对半虚拟化 Hypervisor 中的一组通用 I&#x2F;O 设备的抽象。提供了一套上层应用与各 Hypervisor 虚拟化设备（KVM，Xen，VMware等）之间的通信框架和编程接口，减少跨平台所带来的兼容性问题，大大提高驱动程序开发效率。<br>virtio 协议定义了各类设备与驱动，定义了它们如何初始化，如何通信，如何通知等。其中，最核心的是设备与驱动的通信机制，避免了每次访问外设寄存器都要 vm_exit&#x2F;vm_enter 的问题。</p><span id="more"></span><h2 id="Virtio架构"><a href="#Virtio架构" class="headerlink" title="Virtio架构"></a>Virtio架构</h2><p>从总体上看，virtio 可以分为四层，包括前端 guest 中各种驱动程序模块，后端 Hypervisor （实现在Qemu上）上的处理程序模块，中间用于前后端通信的 virtio 层和 virtio-ring 层，virtio 这一层实现的是虚拟队列接口，算是前后端通信的桥梁，而 virtio-ring 则是该桥梁的具体实现，它实现了两个环形缓冲区，分别用于保存前端驱动程序和后端处理程序执行的信息。</p><p>严格来说，virtio 和 virtio-ring 可以看做是一层，virtio-ring 实现了 virtio 的具体通信机制和数据流程。或者这么理解可能更好，virtio 层属于控制层，负责前后端之间的通知机制（kick，notify）和控制流程，而 virtio-vring 则负责具体数据流转发。</p><h2 id="vring共享内存基本原理"><a href="#vring共享内存基本原理" class="headerlink" title="vring共享内存基本原理"></a>vring共享内存基本原理</h2><p>virtio vring 本质是共享内存，要求使用共享内存的软件模块可以访问这段内存。在虚拟化场景，guest&#x2F;host 如何实现共享内存呢？</p><p>第一个问题：vring 描述符中存放的内存地址是什么？</p><p>vring 由 guest 驱动申请，所以 vring 描述符内存放的地址是 GPA。</p><p>第二个问题：guest&#x2F;host 如何实现共享？</p><p>总体看有三种情况：</p><ol><li>通过 qemu 模拟的设备，GPA 位于 qemu 的进程地址空间，qemu 天然可以访问。</li><li>qemu 外部模拟的设备，比如 vhost-net&#x2F;vhost-user，需要建立新的内存映射。</li><li>对于一个真实的硬件设备，需要使用 IOMMU 辅助完成地址转换。</li></ol><p>以 vhost-net 为例简要说明：</p><p>(1)初始化过程中，qemu 通过 ioctl 命令字将 vring 的内存信息通知 vhost-net 内核模块。内存信息包括：GPA&#x2F;userspace_addr&#x2F;size 等。</p><p>(2)vhost-net 内核模块会记录 GPA 与 userspace_addr（qemu 进程上下文虚拟地址） 的内存映射。</p><p>(3)vhost-net 内核模块在启动内核线程时记录此线程为哪个 qemu 虚拟机服务，同时记录 qemu 虚拟机进程的页表信息，在内核线程运行时，使用对应的 qemu 虚拟机进程页表。这样 vhost-net 内核模块就可以访问 qemu 进程上下文的虚拟地址。</p><h2 id="PCI设备概述"><a href="#PCI设备概述" class="headerlink" title="PCI设备概述"></a>PCI设备概述</h2><p>PCI即Peripheral Component Interconnect，中文意思是“外围器件互联”，是由PCISIG (PCI Special Interest Group)推出的一种局部并行总线标准。PCI总线是由ISA(Industy Standard Architecture)总线发展而来的，是一种同步的独立于处理器的32位或64位局部总线。从结构上看，PCI是在CPU的供应商和原来的系统总线之间插入的一级总线，具体由一个桥接电路实现对这一层的管理，并实现上下之间的接口以协调数据的传送。</p><p>PCI总线是一种共享总线，所以需要特定的仲裁器（Arbiter）来决定当前时刻的总线的控制权。一般该仲裁器位于北桥中，而仲裁器（主机）则通过一对引脚，REQ#（request） 和GNT# （grant）来与各个从机连接。<br>CPU可以直接通过load&#x2F;store指令来访问PCI设备，PCI设备有如下三种不同内存：</p><ul><li>MMIO</li><li>PCI IO space</li><li>PCI configuration space</li></ul><h2 id="guest前端驱动程序操作接口"><a href="#guest前端驱动程序操作接口" class="headerlink" title="guest前端驱动程序操作接口"></a>guest前端驱动程序操作接口</h2><p>驱动程序对PCI 配置的操作可以分成以下几个部分：</p><p>读写 feature bits<br>定义了 Guest 和 Host 支持的功能，例如 VIRTIO_NET_F_CSUM bit 表示网络设备是否支持 checksum offload。feature bits 机制提供了未来扩充功能的灵活性，以及兼容旧设备的能力。</p><h3 id="读写配置空间"><a href="#读写配置空间" class="headerlink" title="读写配置空间"></a>读写配置空间</h3><p>一般通过一个数据结构和一个虚拟设备关联，Guest 可以读写此空间。</p><h3 id="读写-status-bits"><a href="#读写-status-bits" class="headerlink" title="读写 status bits"></a>读写 status bits</h3><p>这是一个8bits的长度，Guest用来标识device probe的状态，当 VIRIO_CONFIG_S_DRIVE_OK被设置，那么Guest已经完成了feature协商，可以跟host进行数据交互了。</p><h3 id="Device-reset"><a href="#Device-reset" class="headerlink" title="Device reset"></a>Device reset</h3><p>重置设备，配置status bits。</p><h3 id="Virtqueue的创建和销毁"><a href="#Virtqueue的创建和销毁" class="headerlink" title="Virtqueue的创建和销毁"></a>Virtqueue的创建和销毁</h3><p>提供了分配virtqueue内存和Host的IO空间的初始化操作。</p><p>对应的代码如下：</p><pre><code>//代码路径virtio-win/VirtIO/windows/VirtIOPCIModern.cstatic const struct virtio_device_ops virtio_pci_device_ops = &#123;.get_config = vio_modern_get_config,.set_config = vio_modern_set_config,.get_config_generation = vio_modern_get_generation,.get_status = vio_modern_get_status,.set_status = vio_modern_set_status,.reset = vio_modern_reset,.get_features = vio_modern_get_features,.set_features = vio_modern_set_features,.set_config_vector = vio_modern_set_config_vector,.set_queue_vector = vio_modern_set_queue_vector,.query_queue_alloc = vio_modern_query_vq_alloc,.setup_queue = vio_modern_setup_vq,.delete_queue = vio_modern_del_vq,&#125;;//代码路径virtio-win/virtio/virtio_pci.hstruct virtio_device_ops&#123;// read/write device config and read config generation countervoid (*get_config)(VirtIODevice *vdev, unsigned offset, void *buf, unsigned len);void (*set_config)(VirtIODevice *vdev, unsigned offset, const void *buf, unsigned len);u32 (*get_config_generation)(VirtIODevice *vdev);// read/write device status byte and reset the deviceu8 (*get_status)(VirtIODevice *vdev);void (*set_status)(VirtIODevice *vdev, u8 status);void (*reset)(VirtIODevice *vdev);// get/set device feature bitsu64 (*get_features)(VirtIODevice *vdev);NTSTATUS (*set_features)(VirtIODevice *vdev, u64 features);// set config/queue MSI interrupt vector, returns the new vectoru16 (*set_config_vector)(VirtIODevice *vdev, u16 vector);u16 (*set_queue_vector)(struct virtqueue *vq, u16 vector);// query virtual queue size and memory requirementsNTSTATUS (*query_queue_alloc)(VirtIODevice *vdev,unsigned index, unsigned short *pNumEntries,unsigned long *pRingSize,unsigned long *pHeapSize);// allocate and initialize a queueNTSTATUS (*setup_queue)(struct virtqueue **queue,VirtIODevice *vdev, VirtIOQueueInfo *info,unsigned idx, u16 msix_vec);// tear down and deallocate a queuevoid (*delete_queue)(VirtIOQueueInfo *info);&#125;;</code></pre><h2 id="virtio-数据流交互机制：virtqueue"><a href="#virtio-数据流交互机制：virtqueue" class="headerlink" title="virtio 数据流交互机制：virtqueue"></a>virtio 数据流交互机制：virtqueue</h2><p>Virtio 使用 virtqueue 来实现 I&#x2F;O 机制，每个 virtqueue 就是一个承载大量数据的队列，具体使用多少个队列取决于需求，例如，virtio 网络驱动程序（virtio-net）使用两个队列（一个用于接受，另一个用于发送），而 virtio 块驱动程序（virtio-blk）仅使用一个队列。</p><pre><code>//VirtIO.hstruct virtqueue &#123;VirtIODevice *vdev;struct vring vring;struct &#123;u16 flags;u16 idx;&#125; master_vring_avail;unsigned int index;unsigned int num_unused;unsigned int num_added_since_kick;u16 first_unused;u16 last_used;void *notification_addr;void (*notification_cb)(struct virtqueue *vq);void *opaque[];&#125;;</code></pre><p>针对Virtqueue的具体操作包含：</p><p>1.向queue中添加一个新的buffer，opaque为一个非空的令牌，用于识别buffer，当buffer内容被消耗后，opaque会返回。</p><pre><code>//VirtIORing.cint virtqueue_add_buf(struct virtqueue *vq,/* 虚拟化队列 */struct scatterlist sg[],   /* 缓存区描述符数组，长度为驱动程序-&gt;设备缓冲区描述符（in）+设备-&gt;驱动程序缓冲区描述符（out）*/unsigned int out,/* sg中驱动程序到设备缓冲区描述符数量 */unsigned int in, /* sg中设备到驱动程序缓冲区描述符数量 */void *opaque,/* virtqueue_get_buf 函数返回值（used ring缓冲区起始描述符指针）*/void *va_indirect,   /* 间接页的虚拟地址或空指针*/ULONGLONG phys_indirect) /*间接页的物理地址或空指针*/</code></pre><p>2.Guest 通知 host 单个或者多个 buffer 已经添加到 queue 中,调用 virtqueue_notify()，notify 函数会向 queue notify(VIRTIO_PCI_QUEUE_NOTIFY)寄存器写入 queue index 来通知 host。</p><pre><code> //VirtIOPCICommon.cvoid virtqueue_kick(struct virtqueue *vq)&#123;if (virtqueue_kick_prepare(vq)) &#123;virtqueue_notify(vq);&#125;&#125;</code></pre><p>3.返回使用过的 buffer，len 为写入到 buffer 中数据的长度。获取数据，释放 buffer,更新 vring 描述符表格中的 index。</p><pre><code>//VirtIORing.cvoid *virtqueue_get_buf(struct virtqueue *vq, /* the queue */unsigned int *len)/* number of bytes returned by the device */</code></pre><p>4.示意 guest 不再需要再知道一个 buffer 已经使用了，也就是关闭 device 的中断。驱动会在初始化时注册一个回调函数，disable_cb()通常在这个 virtqueue 回调函数中使用，用于关闭再次的回调发生。</p><pre><code>//VirtIORing.cvoid virtqueue_disable_cb(struct virtqueue *vq)</code></pre><p>5.与 disable_cb()刚好相反，用于重新开启设备中断的上报。</p><pre><code>//VirtIORing.cbool virtqueue_enable_cb(struct virtqueue *vq) </code></pre><p>virtio 的核心机制就是通过共享内存在前端驱动与后端实现间进行数据传输，共享内存区域被称作 vring。</p><h2 id="virtio-传输机制：vring的构成与实现"><a href="#virtio-传输机制：vring的构成与实现" class="headerlink" title="virtio 传输机制：vring的构成与实现"></a>virtio 传输机制：vring的构成与实现</h2><p>vring 是 virtio 传输机制的实现，vring 引入 ring buffers 来作为数据传输的载体，包含三个部分:</p><pre><code>// virtio_ring.hstruct vring &#123;unsigned int num;struct vring_desc *desc;struct vring_avail *avail;struct vring_used *used;&#125;;</code></pre><p>Descriptor Table： 描述内存 buffer，主要包括 addr&#x2F;len 等信息。</p><pre><code>// virtio_ring.h/* This marks a buffer as continuing via the next field. */#define VIRTQ_DESC_F_NEXT1/* This marks a buffer as write-only (otherwise read-only). */#define VIRTQ_DESC_F_WRITE2/* This means the buffer contains a list of buffer descriptors. */#define VIRTQ_DESC_F_INDIRECT4/* Virtio ring: 16 bytes.  These can chain together via &quot;next&quot;. */struct vring_desc &#123;/* Address (guest-physical). */__virtio64 addr;/* Length. */__virtio32 len;/* The flags as indicated above. */__virtio16 flags;/* We chain unused descriptors via this, too */__virtio16 next;&#125;;</code></pre><p>Available Ring： 用于驱动通知设备有新的可用的描述符。比如，通知后端设备，有一个待发送的报文描述符。</p><p>注意：驱动提供了新的可用描述符后，设备侧不一定要立即使用，比如 virtio-net 会提供一些描述符用于报文接收，当报文到达后按需使用这些描述符即可。</p><pre><code>// virtio_ring.h#define VIRTQ_AVAIL_F_NO_INTERRUPT1struct vring_avail &#123;    //控制信息，比如 VIRTQ_AVAIL_F_NO_INTERRUPT 表示驱动侧不想接收通知__virtio16 flags;//idx：驱动将把下一个描述符放在哪里，即 ring 数组的下标__virtio16 idx;    //ring[]：avail 描述符在 Descriptor Table 中的 id__virtio16 ring[];&#125;;</code></pre><p>Used Ring： 用于通知驱动设备侧已用的描述符。比如，后端设备收到一个报文，需要将报文数据放入可用的描述符，并更新Used Ring，同时通知前端驱动。</p><pre><code>// virtio_ring.h#define VIRTQ_USED_F_NO_NOTIFY1struct vring_used_elem &#123;/* Index of start of used descriptor chain. */__virtio32 id;/* Total length of the descriptor chain which was used (written to) */__virtio32 len;&#125;;struct vring_used &#123;__virtio16 flags;__virtio16 idx;struct vring_used_elem ring[];&#125;;</code></pre><p>注意：相比 avail ring 结构多了 len 字段，用于表示设备侧写入的数据长度。对于只读数据类型，不改变 len 长度。</p><p>vring 主要通过两个环形缓冲区来完成数据流的转发。</p><p>当 guest 向 virtqueue 中写数据时，实际上是向 desc 结构指向的 buffer 中填充数据，完了会更新 available ring，然后再通知 host。<br>当 host 收到接收数据的通知时，首先从 desc 指向的 buffer 中找到 available ring 中添加的 buffer，映射内存，同时更新 used ring，并通知 guest 接收数据完毕。</p><h2 id="qemu后端处理模块"><a href="#qemu后端处理模块" class="headerlink" title="qemu后端处理模块"></a>qemu后端处理模块</h2><p>下面以Virtio Network Device设备的初始化为例对qemu中virtio的实现进行说明。</p><h3 id="预定义结构体"><a href="#预定义结构体" class="headerlink" title="预定义结构体"></a>预定义结构体</h3><pre><code>//代码路径：QEMU/qom/object.cstatic TypeInfo object_info = &#123;.name = TYPE_OBJECT,.instance_size = sizeof(Object),.instance_init = object_instance_init,.abstract = true,&#125;;//代码路径：QEMU/hw/core/qdev.cstatic const TypeInfo device_type_info = &#123;.name = TYPE_DEVICE,.parent = TYPE_OBJECT,.instance_size = sizeof(DeviceState),.instance_init = device_initfn,.instance_post_init = device_post_init,.instance_finalize = device_finalize,.class_base_init = device_class_base_init,.class_init = device_class_init,.abstract = true,.class_size = sizeof(DeviceClass),&#125;;//代码路径：QEMU/hw/virtio/virtio.cstatic const TypeInfo virtio_device_info = &#123;.name = TYPE_VIRTIO_DEVICE,.parent = TYPE_DEVICE,.instance_size = sizeof(VirtIODevice),.class_init = virtio_device_class_init,.instance_finalize = virtio_device_instance_finalize,.abstract = true,.class_size = sizeof(VirtioDeviceClass),&#125;;//代码路径：QEMU/hw/net/virtio-net.cstatic const TypeInfo virtio_net_info = &#123;.name = TYPE_VIRTIO_NET,.parent = TYPE_VIRTIO_DEVICE,.instance_size = sizeof(VirtIONet),.instance_init = virtio_net_instance_init,.class_init = virtio_net_class_init,&#125;;static void virtio_register_types(void)&#123;type_register_static(&amp;virtio_net_info);&#125;type_init(virtio_register_types)</code></pre><p>Virtio Network Device这种类的定义是有多层继承关系的，TYPE_VIRTIO_NET的父类是TYPE_VIRTIO_DEVICE，TYPE_VIRTIO_DEVICE的父类是TYPE_DEVICE，TYPE_DEVICE的父类是TYPE_OBJECT，继承关系就到头了。type_init用于注册这种类，这里面每一层都有class_init，用于从TypeImpl生成xxxClass，也有instance_init，会将xxxClass初始化为实例。</p><h3 id="创建VirtQueue"><a href="#创建VirtQueue" class="headerlink" title="创建VirtQueue"></a>创建VirtQueue</h3><p>TYPE_VIRTIO_NET层的class_init函数是virtio_net_class_init，它定义了DeviceClass的realize函数为virtio_net_device_realize，如下所示：</p><pre><code>//代码路径：QEMU/hw/net/virtio-net.cstatic void virtio_net_class_init(ObjectClass *klass, void *data)&#123;DeviceClass *dc = DEVICE_CLASS(klass);VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);dc-&gt;props = virtio_net_properties;set_bit(DEVICE_CATEGORY_NETWORK, dc-&gt;categories);vdc-&gt;realize = virtio_net_device_realize;vdc-&gt;unrealize = virtio_net_device_unrealize;vdc-&gt;get_config = virtio_net_get_config;vdc-&gt;set_config = virtio_net_set_config;vdc-&gt;get_features = virtio_net_get_features;vdc-&gt;set_features = virtio_net_set_features;vdc-&gt;bad_features = virtio_net_bad_features;vdc-&gt;reset = virtio_net_reset;vdc-&gt;set_status = virtio_net_set_status;vdc-&gt;preset_dma_map = virtio_net_preset_dma_map;vdc-&gt;set_host_notifier = virtio_net_set_host_notifier;vdc-&gt;unset_host_notifier = virtio_net_unset_host_notifier;vdc-&gt;guest_notifier_mask = virtio_net_guest_notifier_mask;vdc-&gt;guest_notifier_pending = virtio_net_guest_notifier_pending;vdc-&gt;load = virtio_net_load_device;vdc-&gt;save = virtio_net_save_device;&#125;static void virtio_net_device_realize(DeviceState *dev, Error **errp)&#123;VirtIODevice *vdev = VIRTIO_DEVICE(dev);VirtIONet *n = VIRTIO_NET(dev);NetClientState *nc;int i;         … …n-&gt;max_queues = MAX(n-&gt;nic_conf.peers.queues, 1);… …for (i = 0; i &lt; n-&gt;max_queues; i++) &#123;virtio_net_add_queue(n, i);&#125;n-&gt;ctrl_vq = virtio_add_queue(vdev, 64, virtio_net_handle_ctrl);qemu_macaddr_default_if_unset(&amp;n-&gt;nic_conf.macaddr);memcpy(&amp;n-&gt;mac[0], &amp;n-&gt;nic_conf.macaddr, sizeof(n-&gt;mac));n-&gt;status = VIRTIO_NET_S_LINK_UP;n-&gt;announce_timer = timer_new_ms(QEMU_CLOCK_VIRTUAL, virtio_net_announce_timer, n);if (n-&gt;netclient_type) &#123;n-&gt;nic = qemu_new_nic(&amp;net_virtio_info, &amp;n-&gt;nic_conf,  n-&gt;netclient_type, n-&gt;netclient_name, n);&#125; else &#123;n-&gt;nic = qemu_new_nic(&amp;net_virtio_info, &amp;n-&gt;nic_conf,  object_get_typename(OBJECT(dev)), dev-&gt;id, n);&#125;… …&#125;</code></pre><p>上述代码创建了一个VirtIODevice，而virtio_init用来初始化这个设备。VirtIODevice结构里面有一个VirtQueue数组，这就是virtio前端和后端互相传数据的队列，最多有VIRTIO_QUEUE_MAX（1024）个。</p><p>但是net设备也有与其他设备不一样的地方，即代码中存在这样的语句n-&gt;max_queues * 2 + 1 &gt; VIRTIO_QUEUE_MAX。为什么要乘以2呢？这是因为对于网络设备来讲，应该分发送队列和接收队列两个方向。</p><h3 id="VirtQueue队列初始化"><a href="#VirtQueue队列初始化" class="headerlink" title="VirtQueue队列初始化"></a>VirtQueue队列初始化</h3><p>接下来调用virtio_net_add_queue来初始化队列，可以看出这里面就有发送tx_vq和接收rx_vq两个队列，如下所示：</p><pre><code>//代码路径：QEMU/hw/net/virtio-net.cstatic void virtio_net_add_queue(VirtIONet *n, int index)&#123;VirtIODevice *vdev = VIRTIO_DEVICE(n);n-&gt;vqs[index].rx_vq = virtio_add_queue(vdev, n-&gt;net_conf.rx_queue_size,   virtio_net_handle_rx);if (n-&gt;net_conf.tx &amp;&amp; !strcmp(n-&gt;net_conf.tx, &quot;timer&quot;)) &#123;n-&gt;vqs[index].tx_vq =virtio_add_queue(vdev, n-&gt;net_conf.tx_queue_size, virtio_net_handle_tx_timer);n-&gt;vqs[index].tx_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,  virtio_net_tx_timer,  &amp;n-&gt;vqs[index]);&#125; else &#123;n-&gt;vqs[index].tx_vq =virtio_add_queue(vdev, n-&gt;net_conf.tx_queue_size, virtio_net_handle_tx_bh);n-&gt;vqs[index].tx_bh = qemu_bh_new(virtio_net_tx_bh, &amp;n-&gt;vqs[index]);&#125;n-&gt;vqs[index].tx_waiting = 0;n-&gt;vqs[index].n = n;&#125;</code></pre><p>每个VirtQueue中，都有一个vring用来维护这个队列里面的数据；另外还有函数virtio_net_handle_rx用于处理网络包的接收；函数virtio_net_handle_tx_bh用于网络包的发送。</p><h3 id="创建虚拟机网卡"><a href="#创建虚拟机网卡" class="headerlink" title="创建虚拟机网卡"></a>创建虚拟机网卡</h3><p>qemu_new_nic会创建一个虚拟机里面的网卡，如下所示：</p><pre><code>//代码路径：QEMU/net/net.cNICState *qemu_new_nic(NetClientInfo *info,   NICConf *conf,   const char *model,   const char *name,   void *opaque)&#123;NetClientState **peers = conf-&gt;peers.ncs;NICState *nic;int i, queues = MAX(1, conf-&gt;peers.queues);assert(info-&gt;type == NET_CLIENT_OPTIONS_KIND_NIC);assert(info-&gt;size &gt;= sizeof(NICState));nic = g_malloc0(info-&gt;size + sizeof(NetClientState) * queues);nic-&gt;ncs = (void *)nic + info-&gt;size;nic-&gt;conf = conf;nic-&gt;opaque = opaque;for (i = 0; i &lt; queues; i++) &#123;qemu_net_client_setup(&amp;nic-&gt;ncs[i], info, peers[i], model, name,  NULL);nic-&gt;ncs[i].queue_index = i;&#125;return nic;&#125;static void qemu_net_client_setup(NetClientState *nc,  NetClientInfo *info,  NetClientState *peer,  const char *model,  const char *name,  NetClientDestructor *destructor)&#123;nc-&gt;info = info;nc-&gt;model = g_strdup(model);if (name) &#123;nc-&gt;name = g_strdup(name);&#125; else &#123;nc-&gt;name = assign_name(nc, model);&#125;if (peer) &#123;assert(!peer-&gt;peer);nc-&gt;peer = peer;peer-&gt;peer = nc;&#125;QTAILQ_INSERT_TAIL(&amp;net_clients, nc, next);nc-&gt;incoming_queue = qemu_new_net_queue(qemu_deliver_packet_iov, nc);nc-&gt;destructor = destructor;QTAILQ_INIT(&amp;nc-&gt;filters);&#125;</code></pre><h2 id="kernel内核驱动程序"><a href="#kernel内核驱动程序" class="headerlink" title="kernel内核驱动程序"></a>kernel内核驱动程序</h2><p>在虚拟机里面的进程发送一个网络包，通过文件系统和Socket调用网络协议栈到达网络设备层，只不过这个不是普通的网络设备，而是virtio_net的驱动。virtio_net的驱动程序代码在Linux操作系统的源代码里面，文件名为linux&#x2F;drivers&#x2F;net&#x2F;virtio_net.c，如下所示：</p><h3 id="预定义结构体-1"><a href="#预定义结构体-1" class="headerlink" title="预定义结构体"></a>预定义结构体</h3><pre><code>static struct virtio_driver virtio_net_driver = &#123;    .feature_table = features,    .feature_table_size = ARRAY_SIZE(features),    .driver.name =KBUILD_MODNAME,    .driver.owner =THIS_MODULE,    .id_table =id_table,    .probe =virtnet_probe,    .remove =virtnet_remove,    .config_changed = virtnet_config_changed,#ifdef CONFIG_PM_SLEEP    .freeze =virtnet_freeze,    .restore =virtnet_restore,#endif&#125;;module_virtio_driver(virtio_net_driver);MODULE_DEVICE_TABLE(virtio, id_table);MODULE_DESCRIPTION(&quot;Virtio network driver&quot;);MODULE_LICENSE(&quot;GPL&quot;);</code></pre><h3 id="模块初始化"><a href="#模块初始化" class="headerlink" title="模块初始化"></a>模块初始化</h3><p>在virtio_net的驱动程序的初始化代码中，需要注册一个驱动函数virtio_net_driver。当一个设备驱动作为一个内核模块被初始化的时候，probe函数会被调用，因而来看一下virtnet_probe：</p><pre><code>static int virtnet_probe(struct virtio_device *vdev)&#123;    int i, err;    struct net_device *dev;    struct virtnet_info *vi;    u16 max_queue_pairs;    int mtu;    … …    dev = alloc_etherdev_mq(sizeof(struct virtnet_info), max_queue_pairs);    if (!dev)        return -ENOMEM;    /* Set up network device as normal. */    dev-&gt;priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE;    dev-&gt;netdev_ops = &amp;virtnet_netdev;    dev-&gt;features = NETIF_F_HIGHDMA;    SET_ETHTOOL_OPS(dev, &amp;virtnet_ethtool_ops);    SET_NETDEV_DEV(dev, &amp;vdev-&gt;dev);    … …    /* Set up our device-specific information */    vi = netdev_priv(dev);    vi-&gt;dev = dev;    vi-&gt;vdev = vdev;    vdev-&gt;priv = vi;    vi-&gt;stats = alloc_percpu(struct virtnet_stats);    err = -ENOMEM;    … …    err = init_vqs(vi);    if (err)        goto free_index;    netif_set_real_num_tx_queues(dev, vi-&gt;curr_queue_pairs);    netif_set_real_num_rx_queues(dev, vi-&gt;curr_queue_pairs);    virtnet_init_settings(dev);    err = register_netdev(dev);    if (err) &#123;        pr_debug(&quot;virtio_net: registering device failed\n&quot;);        goto free_vqs;    &#125;    virtio_device_ready(vdev);    … …    virtnet_set_queues(vi, vi-&gt;curr_queue_pairs);    … …&#125;</code></pre><p>在virtnet_probe中会创建struct net_device，并且通过register_netdev注册这个网络设备，这样在客户机里面就能看到这个网卡了。</p><h3 id="初始化virtqueue"><a href="#初始化virtqueue" class="headerlink" title="初始化virtqueue"></a>初始化virtqueue</h3><p>在virtnet_probe中，还有一件重要的事情就是，init_vqs会初始化发送和接收的virtqueue，如下所示：</p><pre><code>static int init_vqs(struct virtnet_info *vi)&#123;    int ret;    /* Allocate send &amp; receive queues */    ret = virtnet_alloc_queues(vi);    if (ret)        goto err;    ret = virtnet_find_vqs(vi);    if (ret)        goto err_free;    get_online_cpus();    virtnet_set_affinity(vi);    put_online_cpus();    return 0;err_free:    virtnet_free_queues(vi);err:    return ret;&#125;</code></pre><h3 id="Virtqueue实体查找"><a href="#Virtqueue实体查找" class="headerlink" title="Virtqueue实体查找"></a>Virtqueue实体查找</h3><p>按照之前的virtio原理，virtqueue是一个介于客户机前端和qemu后端的一个结构，用于在这两端之间传递数据，对于网络设备来讲有发送和接收两个方向的队列。这里建立的struct virtqueue是客户机前端对于队列管理的数据结构。队列的实体需要通过函数virtnet_find_vqs查找或者生成，这里还会指定接收队列的callback函数为skb_recv_done，发送队列的callback函数为skb_xmit_done。当buffer使用发生变化的时候，可以调用这个callback函数进行通知，如下所示：</p><pre><code>static int virtnet_find_vqs(struct virtnet_info *vi)&#123;    vq_callback_t **callbacks;    struct virtqueue **vqs;    int ret = -ENOMEM;    int i, total_vqs;    const char **names;    /* We expect 1 RX virtqueue followed by 1 TX virtqueue, followed by     * possible N-1 RX/TX queue pairs used in multiqueue mode, followed by     * possible control vq.     */    total_vqs = vi-&gt;max_queue_pairs * 2 +        virtio_has_feature(vi-&gt;vdev, VIRTIO_NET_F_CTRL_VQ);    /* Allocate space for find_vqs parameters */    vqs = kzalloc(total_vqs * sizeof(*vqs), GFP_KERNEL);    if (!vqs)        goto err_vq;    callbacks = kmalloc(total_vqs * sizeof(*callbacks), GFP_KERNEL);    if (!callbacks)        goto err_callback;    names = kmalloc(total_vqs * sizeof(*names), GFP_KERNEL);    if (!names)        goto err_names;    /* Parameters for control virtqueue, if any */    if (vi-&gt;has_cvq) &#123;        callbacks[total_vqs - 1] = NULL;        names[total_vqs - 1] = &quot;control&quot;;    &#125;    /* Allocate/initialize parameters for send/receive virtqueues */    for (i = 0; i &lt; vi-&gt;max_queue_pairs; i++) &#123;        callbacks[rxq2vq(i)] = skb_recv_done;        callbacks[txq2vq(i)] = skb_xmit_done;        sprintf(vi-&gt;rq[i].name, &quot;input.%d&quot;, i);        sprintf(vi-&gt;sq[i].name, &quot;output.%d&quot;, i);        names[rxq2vq(i)] = vi-&gt;rq[i].name;        names[txq2vq(i)] = vi-&gt;sq[i].name;    &#125;    ret = vi-&gt;vdev-&gt;config-&gt;find_vqs(vi-&gt;vdev, total_vqs, vqs, callbacks,                     names);    if (ret)        goto err_find;    if (vi-&gt;has_cvq) &#123;        vi-&gt;cvq = vqs[total_vqs - 1];        if (virtio_has_feature(vi-&gt;vdev, VIRTIO_NET_F_CTRL_VLAN))            vi-&gt;dev-&gt;features |= NETIF_F_HW_VLAN_CTAG_FILTER;    &#125;    for (i = 0; i &lt; vi-&gt;max_queue_pairs; i++) &#123;        vi-&gt;rq[i].vq = vqs[rxq2vq(i)];        vi-&gt;sq[i].vq = vqs[txq2vq(i)];    &#125;    kfree(names);    kfree(callbacks);    kfree(vqs);    return 0;err_find:    kfree(names);err_names:    kfree(callbacks);err_callback:    kfree(vqs);err_vq:    return ret;&#125;</code></pre><p>这里的find_vqs是在struct virtnet_info里的struct virtio_device里的struct virtio_config_ops *config里面定义的。</p><p>根据virtio_config_ops的定义，find_vqs会调用vp_modern_find_vqs。在vp_modern_find_vqs 中，vp_find_vqs会调用vp_find_vqs_intx。在vp_find_vqs_intx 中，通过request_irq注册一个中断处理函数vp_interrupt，当设备向队列中写入信息时会产生一个中断，也就是vq中断。中断处理函数需要调用相应队列的回调函数，然后根据队列的数目，依次调用vp_setup_vq完成virtqueue、vring的分配和初始化。</p><p>同样，这些数据结构会和virtio后端的VirtIODevice、VirtQueue、vring对应起来，都应该指向刚才创建的那一段内存。客户机同样会通过调用专门给外部设备发送指令的函数iowrite告诉外部的pci设备，这些共享内存的地址。至此前端设备驱动和后端设备驱动之间的两个收发队列就关联好了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>virtio 是 guest 与 host 之间通信的润滑剂，提供了一套通用框架和标准接口或协议来完成两者之间的交互过程，极大地解决了各种驱动程序和不同虚拟化解决方案之间的适配问题。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是virtio&quot;&gt;&lt;a href=&quot;#什么是virtio&quot; class=&quot;headerlink&quot; title=&quot;什么是virtio&quot;&gt;&lt;/a&gt;什么是virtio&lt;/h2&gt;&lt;p&gt;virtio 是一种 I&amp;#x2F;O 半虚拟化解决方案，是一套通用 I&amp;#x2F;O 设备虚拟化的程序，是对半虚拟化 Hypervisor 中的一组通用 I&amp;#x2F;O 设备的抽象。提供了一套上层应用与各 Hypervisor 虚拟化设备（KVM，Xen，VMware等）之间的通信框架和编程接口，减少跨平台所带来的兼容性问题，大大提高驱动程序开发效率。&lt;br&gt;virtio 协议定义了各类设备与驱动，定义了它们如何初始化，如何通信，如何通知等。其中，最核心的是设备与驱动的通信机制，避免了每次访问外设寄存器都要 vm_exit&amp;#x2F;vm_enter 的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="kvm" scheme="http://example.com/tags/kvm/"/>
    
    <category term="virtio" scheme="http://example.com/tags/virtio/"/>
    
  </entry>
  
  <entry>
    <title>kvm windows虚拟机dmp文件转储</title>
    <link href="http://example.com/2021/08/17/kvm_windows_vm_dump-202208171626-karlqyang/"/>
    <id>http://example.com/2021/08/17/kvm_windows_vm_dump-202208171626-karlqyang/</id>
    <published>2021-08-17T08:34:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>kvm下的windows虚拟机转储可从子机侧和母机侧两方面进行。</p><span id="more"></span><h3 id="子机侧"><a href="#子机侧" class="headerlink" title="子机侧"></a>子机侧</h3><p>子机侧转储windows子机信息，主要是在主机内部执行virsh inject-nmi UUID指令，通过人为模拟nmi中断实现的，之后子机触发BSOD（蓝屏），继而执行核心文件转储和重启操作。转储的文件名为MEMORY.dmp，根据设置的windows内存核心转储方式不同，该文件一般存储于c:\Windows目录或c:\Windows\Minidump目录下。</p><h3 id="母机侧"><a href="#母机侧" class="headerlink" title="母机侧"></a>母机侧</h3><h4 id="qemu-monitor-command指令"><a href="#qemu-monitor-command指令" class="headerlink" title="qemu-monitor-command指令"></a>qemu-monitor-command指令</h4><p>virsh qemu-monitor-command domain<br>使用该类指令时，需安装qemu-monitor相关组件，否则无法使用相关指令</p><pre><code>#故意让windows蓝屏virsh qemu-monitor-command instance-00000b2e --hmp  nmi#导出guest内存virsh qemu-monitor-command instance-00000b2e --hmp  dump-guest-memory  /home/qemu/instance-00000b2e.dump</code></pre><h4 id="dump指令"><a href="#dump指令" class="headerlink" title="dump指令"></a>dump指令</h4><p>对应语法如下：</p><pre><code>#virsh dump指令语法virsh dump domain corefilepath [--bypass-cache]   &#123; [--live] | [--crash] | [--reset] &#125;   [--verbose] [--memory-only] [--format string]</code></pre><p>–live ：使用该参数后，qemu进程在内核转储完成后继续运行</p><p>–crash ：使用该参数后，qemu进程在内核转储完成后因crash事件而暂停</p><p>–reset：使用该参数后，qemu进程在内核转储完成后重启<br>若没有使用上述三个参数，则进程在内核转储完成后保持pause状态</p><p>-bypass-cache：使用该参数后，转储文件不会保存os文件系统缓存文件</p><p>–memory-only：使用该参数后，转储文件为elf格式文件，且仅包含虚拟机内存及cpu通用寄存器数值</p><p>–format：该参数与memory-only绑定使用，指定保存的转储文件的格式，其支持的文件格式（即string的参数值）包含elf、kdump-zlib（使用zlib压缩的kdump压缩格式）、kdump-lzo（使用lzo压缩的kdump压缩格式）、kdump-sbappy（使用sbappy压缩的kdump压缩格式）、win-dmp（windows的完全转储格式）</p><p>如果仅使用最简单的dump语法：virsh dump domain corefilepath，则生成的转储文件格式如下：</p><pre><code>windows_dump_no-memory-only.dmp:QEMU suspend to disk image</code></pre><p>如果使用memory-only语法，但不指定format，则默认格式如下：</p><pre><code>windows_dump_memory-only.dmp:ELF 64-bit LSB core file x86-64, version 1 (SYSV)</code></pre><h3 id="转储文件格式转换"><a href="#转储文件格式转换" class="headerlink" title="转储文件格式转换"></a>转储文件格式转换</h3><p>virsh dump指令在低版本不支持win-dmp格式，因此生成的dump文件的格式以elf文件为主，而windbg是无法直接使用并分析elf文件的，因此需进行转换，将elf文件转换为windows的dmp格式文件。</p><p>文件格式的转换主要使用<a href="https://github.com/volatilityfoundation/volatility">volatility</a>和<a href="https://github.com/gdabah/distorm">distorm</a>两个python库。</p><pre><code>#安装工具git clone https://github.com/volatilityfoundation/volatilitypython setup.py install#有inline失败的问题，把函数把inline变为非inlinegit clone https://github.com/gdabah/distormpython setup.py install#复制distorm目录下的_distorm3.so库到python sys.path否则报错cp build/lib.linux-x86_64-2.7/_distorm3.so  /usr/lib64/python2.7/#分析guest内存布局[root@rg1-ostack37 /home/huiwei]# file instance-00000b2e.dumpinstance-00000b2e.dump: ELF 64-bit LSB core file x86-64, version 1 (SYSV), SVR4-style[root@rg1-ostack37 /home/huiwei]# /bin/vol.py imageinfo -f instance-00000b2e.dumpVolatility Foundation Volatility Framework 2.6.1INFO: volatility.debug: Determining profile based on KDBG search...  Suggested Profile(s) : Win7SP1x64, Win7SP0x64, Win2008R2SP0x64, Win2008R2SP1x64_24000, Win2008R2SP1x64_23418, Win2008R2SP1x64, Win7SP1x64_24000, Win7SP1x64_23418 AS Layer1 : WindowsAMD64PagedMemory (Kernel AS) AS Layer2 : QemuCoreDumpElf (Unnamed AS) AS Layer3 : FileAddressSpace (/home/huiwei/instance-00000b2e.dump)  PAE type : No PAE   DTB : 0x187000L  KDBG : 0xf8000164f110L  Number of Processors : 2 Image Type (Service Pack) : 1KPCR for CPU 0 : 0xfffff80001650d00LKPCR for CPU 1 : 0xfffff880009c5000L KUSER_SHARED_DATA : 0xfffff78000000000L   Image date and time : 2020-10-22 09:37:00 UTC+0000 Image local date and time : 2020-10-22 17:37:00 +0800#进行转换[root@rg1-ostack37 /home/huiwei]# /bin/vol.py -f instance-00000b2e.dump --profile Win2008R2SP1x64  raw2dmp -O   instance-00000b2e.dmpVolatility Foundation Volatility Framework 2.6.1Writing data (5.00 MB chunks): |..................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................|[root@rg1-ostack37 /home/huiwei]# file instance-00000b2e.dmpinstance-00000b2e.dmp: MS Windows 64bit crash dump, full dump, 1310720 pages</code></pre><p>windows目标文件的格式需选择，可通过&#x2F;bin&#x2F;vol.py -f XXX.dump –profile相关指令获取本机相关库支持的windows格式进行参数填写。</p><p>经过上述处理之后，即可使用windbg工具对相关dmp文件进行分析，以查找系统异常原因。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;kvm下的windows虚拟机转储可从子机侧和母机侧两方面进行。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="kvm" scheme="http://example.com/tags/kvm/"/>
    
    <category term="windows" scheme="http://example.com/tags/windows/"/>
    
    <category term="coredump" scheme="http://example.com/tags/coredump/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu离线情况下安装gcc编译器</title>
    <link href="http://example.com/2020/12/23/Ubuntu_offline_setup_gcc/"/>
    <id>http://example.com/2020/12/23/Ubuntu_offline_setup_gcc/</id>
    <published>2020-12-23T03:38:49.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统版本"><a href="#系统版本" class="headerlink" title="系统版本"></a>系统版本</h2><p>（1）Ubuntu系统版本：20.04.1LTS；<br>（2）gcc编译器版本：gcc-9.3.0；<br>当前可找到的gcc最新版本为gcc-10，但是笔者在安装gcc-10版本时发现一些依赖项无法安装，因此选取了gcc-9版本。如果是在联网情况下安装，直接使用apt相关的安装指令即可。</p><span id="more"></span><h2 id="安装说明"><a href="#安装说明" class="headerlink" title="安装说明"></a>安装说明</h2><p>安装建议在root模式下进行，因为各人的系统已安装软件不同，因此使用gcc9.3可能会造成一些依赖库降级，如果不了解的情况下，不建议降级。笔者所用的为linux虚拟机，为学习之用，近似于裸机，因此不考虑对其他软件的影响。<br>安装顺序不定，因为非裸机情况下，可能已安装部分支持库。笔者建议直接安装上述安装包内的gcc-9_9.3.0-10ubuntu2_amd64.deb，根据提示再去进行其他依赖库的安装。安装完成gcc之后，再安装g++-9_9.3.0-10ubuntu2_amd64.deb。<br>如果在安装过程中发现部分依赖库不存在，可到<a href="https://pkgs.org/">https://pkgs.org</a>网站进行下载。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>安装完成之后，可通过gcc -v与g++ -v指令获取当前的编译器版本信息。但是笔者在安装完成之后发现，无法通过这两条指令获取版本信息，提示命令不存在。但是可通过gcc-9 -v与g++-9 -v指令获取编译器版本信息。因此需进行处理，处理方法如下（转载自<a href="https://www.zhihu.com/question/348286167/answer/838993075">https://www.zhihu.com/question/348286167/answer/838993075</a>）：<br>（1）依次执行下面三个命令：</p><pre><code>cd //进入home目录touch .bash_profile //生成新文件vim .touch_profile //编辑&#39;.bash_profile&#39;文件</code></pre><p>（2）将以下alias命令复制进 .bash_profile 文件：</p><pre><code>alias gcc=&#39;gcc-9&#39;alias g++=&#39;g++-9&#39;</code></pre><p>&#x2F;&#x2F;切记&#x3D;两边不要加空格</p><p>（3）然后执行如下命令：</p><pre><code>source .bash_profile</code></pre><p>然后，就可以使用gcc -v和g++ -v相关指令了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;系统版本&quot;&gt;&lt;a href=&quot;#系统版本&quot; class=&quot;headerlink&quot; title=&quot;系统版本&quot;&gt;&lt;/a&gt;系统版本&lt;/h2&gt;&lt;p&gt;（1）Ubuntu系统版本：20.04.1LTS；&lt;br&gt;（2）gcc编译器版本：gcc-9.3.0；&lt;br&gt;当前可找到的gcc最新版本为gcc-10，但是笔者在安装gcc-10版本时发现一些依赖项无法安装，因此选取了gcc-9版本。如果是在联网情况下安装，直接使用apt相关的安装指令即可。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="Ubuntu" scheme="http://example.com/tags/Ubuntu/"/>
    
    <category term="gcc" scheme="http://example.com/tags/gcc/"/>
    
  </entry>
  
</feed>
