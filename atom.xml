<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>怀德维宁</title>
  
  <subtitle>大邦维屏，大宗维翰。怀德维宁，宗子维城。</subtitle>
  <link href="https://bbbccvbvv.github.io/atom.xml" rel="self"/>
  
  <link href="https://bbbccvbvv.github.io/"/>
  <updated>2024-10-14T11:25:17.120Z</updated>
  <id>https://bbbccvbvv.github.io/</id>
  
  <author>
    <name>杨维宁</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>windbg手动添加非官方pdb文件进行调试</title>
    <link href="https://bbbccvbvv.github.io/2024/07/25/windbg_add_pdb_file_manually/"/>
    <id>https://bbbccvbvv.github.io/2024/07/25/windbg_add_pdb_file_manually/</id>
    <published>2024-07-25T13:33:20.000Z</published>
    <updated>2024-10-14T11:25:17.120Z</updated>
    
    <content type="html"><![CDATA[<p>在使用windbg分析windows产生的dmp异常转储文件时，常常需要使用到相关应用的pdb文件，否则就只能看到粗略的模块，却不能看到具体的函数执行内容。而微软的官方pdb服务器可以下载到windows相关的pdb文件，对于非官方的程序或驱动，就需要调试者自己去查找并进行设置。本文就如何在使用windbg调试dmp时，如何手动添加非官方的pdb文件进行描述，希望能够帮助遇到该问题的开发者。</p><span id="more"></span><p>笔者最近在分析一个dmp文件，从其stack中可以看到，异常发生时涉及到了一个第三方程序netkvm，查询资料发现这是一个开源的第三方网络驱动，主要用于虚拟机。由于初始时只有微软的相关pdb文件，因此在stack中只能看到netkvm的模块名称，却无法准确判断具体的异常函数。</p><pre><code>STACK_TEXT:  fffff802`8f11dc08 fffff802`8d247a4e     : 00000000`00000080 00000000`004f4454 00000000`00000000 00000000`00000000 : nt!KeBugCheckExfffff802`8f11dc10 fffff802`8d4bc1c0     : ffffc006`7b554968 fffff802`8d25fe30 fffff802`8d25fe30 00000000`00000001 : hal!HalBugCheckSystem+0x7efffff802`8f11dc50 fffff802`8d248a1e     : fffff802`000006c0 fffff802`8d64a600 fffff802`8f11dd30 fffff802`8d3349d8 : nt!WheaReportHwError+0x258fffff802`8f11dcb0 fffff802`8d334302     : 00000000`000c00e1 00000000`00000000 00000000`00000000 fffff802`8d3347a8 : hal!HalHandleNMI+0xfefffff802`8f11dce0 fffff802`8d3f6142     : 00000000`000c00e1 fffff802`8f11def0 00000000`00000000 00000000`00000000 : nt!KiProcessNMI+0x106fffff802`8f11dd30 fffff802`8d3f5f43     : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : nt!KxNmiInterrupt+0x82fffff802`8f11de70 fffff802`8d3fd6a1     : fffff802`8d22b2f5 00000000`00000002 fffff802`8d22b2f5 00000000`00000002 : nt!KiNmiInterrupt+0x1c3ffff8300`63eada68 fffff802`8d22b2f5     : 00000000`00000002 fffff802`8d22b2f5 00000000`00000002 fffff802`8d22b2f5 : nt!HvlWriteApicCommandRegister+0x1dffff8300`63eada70 fffff802`8d213b62     : ffffffff`ffd10738 00000000`00000001 ffff8300`63eadbb0 00001f80`00260cb0 : hal!HalpApicRequestInterrupt+0x176b5ffff8300`63eadae0 fffff802`8d2c92a3     : 00000000`00000001 fffff802`8d21392f ffffffff`ffd10738 00000000`00000001 : hal!HalRequestIpi+0x452ffff8300`63eadd60 fffff802`8d2c8b49     : 00000000`00000001 00000000`00010008 00000000`00000001 00000000`00000002 : nt!KiIpiSendRequest+0x453ffff8300`63eadf70 fffff802`8d2d7e2f     : 00000000`00000002 00000000`00000000 00000000`00000002 00000000`074d8416 : nt!MiFlushTbList+0x349ffff8300`63eae0c0 fffff802`8d2cb9b8     : ffffee81`5e88c420 00000000`c0000001 ffffee80`0000c420 00000000`00000004 : nt!MiGetPteFromCopyList+0x9fffff8300`63eae1e0 fffff802`8d296966     : 00000000`00000416 00000000`074d8416 80000074`d8416963 00000000`00000004 : nt!MiCopyPage+0x3e8ffff8300`63eae2a0 fffff802`8d293e27     : ffffee81`5e88c420 00000000`074d8416 ffffee81`5e88c420 00000000`08100000 : nt!MiStealPage+0x1562ffff8300`63eae620 fffff802`8d291e48     : fffff802`8d5af400 ffffee81`5e88c420 00000000`00000001 ffff8300`63eae760 : nt!MiClaimPhysicalRun+0x4cbffff8300`63eae6b0 fffff802`8d28f31d     : 00000000`00000000 00000000`00000000 00000000`00000004 fffff802`00000003 : nt!MiFindContiguousPages+0x424ffff8300`63eae830 fffff802`8d28f141     : ffff8300`00000000 00000000`00001000 0000000f`ffffffff fffff180`0001e8a8 : nt!MiAllocateContiguousMemory+0x1bdffff8300`63eae8d0 fffff802`8d2331d2     : 00000000`00011000 00000000`00000000 00000000`00001000 00000000`00000000 : nt!MmAllocateContiguousNodeMemory+0x81ffff8300`63eae920 fffff80a`6d202a2e     : 00000000`00000001 ffffc006`7b54f1a0 ffffc006`862e1648 00000000`00001000 : hal!HalAllocateCommonBufferV2+0x5effff8300`63eae960 fffff80a`6da67455     : ffffc006`862e1930 00000000`00000001 fffff80a`6da73601 00000000`00001000 : NDIS!NdisMAllocateSharedMemory+0xfeffff8300`63eae9c0 fffff80a`6da5d853     : ffffc006`862e1930 ffffc006`7d9c4340 ffffc006`356d7551 ffff8300`6ff7c010 : netkvm+0x17455ffff8300`63eaea00 fffff80a`6da5dd12     : ffffc006`7d9c4340 fffff80a`6da77000 00000000`0000009b ffffc006`7d9c43a8 : netkvm+0xd853ffff8300`63eaea40 fffff80a`6da5d733     : ffffc006`7d9c4340 00000000`00000000 00000000`00000030 00000000`00000000 : netkvm+0xdd12ffff8300`63eaea80 fffff80a`6da54a9f     : ffffc006`7b541000 00000000`0000002e fffff80a`356d7551 00000000`356d0047 : netkvm+0xd733ffff8300`63eaeab0 fffff80a`6da5309b     : 00000000`00000000 fffff80a`6da77000 00000000`00000000 ffffc006`7b541000 : netkvm+0x4a9fffff8300`63eaeb10 fffff80a`6da65dc9     : ffffc006`7b541498 ffff8300`63eaec50 ffffc006`7b541000 fffff80a`6d1c76b8 : netkvm+0x309bffff8300`63eaeb50 fffff80a`6d1fd532     : ffffc006`7b54f1a0 ffffc006`7b54f1a0 ffff8300`63eaee70 ffffc006`7b550028 : netkvm+0x15dc9ffff8300`63eaed10 fffff80a`6d23b848     : ffffc006`7b54fed8 00000000`00000000 00000000`00000000 ffffc006`7b54f1a0 : NDIS!ndisMInvokeInitialize+0x5effff8300`63eaed70 fffff80a`6d1fd9d3     : 00000000`00000000 00000000`000005b4 ffffc006`7b744490 01da68a5`e1ad1af4 : NDIS!ndisMInitializeAdapter+0x4d4ffff8300`63eaf430 fffff80a`6d1fdae0     : 00000000`000005b4 ffffc006`7b7fc490 ffffaa0d`0d578010 ffffc006`7b54f1a0 : NDIS!ndisInitializeAdapter+0x5fffff8300`63eaf480 fffff80a`6d1efb3b     : ffffc006`7b54f1a0 fffff80a`6d1ef9f0 ffffc006`78092250 fffff802`8d74969c : NDIS!ndisPnPStartDevice+0x80ffff8300`63eaf4c0 fffff80a`6d1efa21     : 00000000`00000100 ffffc006`7b54f1a0 ffffc006`7b7f80c0 fffff80a`6d06f4a0 : NDIS!ndisStartDeviceSynchronous+0x4fffff8300`63eaf510 fffff802`8d2cfb59     : ffffc006`756dd040 ffffc006`7b7f80c0 ffffaa0d`00000000 ffffc006`756dd040 : NDIS!ndisStartDeviceWorkItem+0x31ffff8300`63eaf540 fffff802`8d321a39     : ffffc006`756dd040 00000000`00000080 ffffc006`7569e6c0 ffffc006`756dd040 : nt!ExpWorkerThread+0xe9ffff8300`63eaf5d0 fffff802`8d3f2976     : ffff8300`5df40180 ffffc006`756dd040 fffff802`8d3219f8 00000000`00000000 : nt!PspSystemThreadStartup+0x41ffff8300`63eaf620 00000000`00000000     : ffff8300`63eb0000 ffff8300`63ea9000 00000000`00000000 00000000`00000000 : nt!KiStartSystemThread+0x16</code></pre><p>因为netkvm是开源的驱动文件，因此很容易在社区中找到了所需的sys和pdb文件，但是直接将对应的文件放入到笔者设置的本地symbol路径下，并重新reload并没有效果，那么问题应该是文件路径不对，windbg没有识别相关的文件，因此需要获取windbg加载pdb的详细路径。</p><p>使用“.reload &#x2F;f netkvm.sys”指令尝试加载相关的模块，可以看到windbg异常输出如下：</p><pre><code>0: kd&gt; .reload /f netkvm.sysSYMSRV:  BYINDEX: 0x1F        d:\symbols*https://msdl.microsoft.com/download/symbols        netkvm.sys        61A8F2E22e000SYMSRV:  UNC: d:\symbols\netkvm.sys\61A8F2E22e000\netkvm.sys - path not foundSYMSRV:  UNC: d:\symbols\netkvm.sys\61A8F2E22e000\netkvm.sy_ - path not foundSYMSRV:  UNC: d:\symbols\netkvm.sys\61A8F2E22e000\file.ptr - path not foundSYMSRV:  HTTPGET: /download/symbols/netkvm.sys/61A8F2E22e000/netkvm.sysSYMSRV:  HttpQueryInfo: 80190194 - HTTP_STATUS_NOT_FOUNDSYMSRV:  HTTPGET: /download/symbols/netkvm.sys/61A8F2E22e000/netkvm.sy_SYMSRV:  HttpQueryInfo: 80190194 - HTTP_STATUS_NOT_FOUNDSYMSRV:  HTTPGET: /download/symbols/netkvm.sys/61A8F2E22e000/file.ptrSYMSRV:  HttpQueryInfo: 80190194 - HTTP_STATUS_NOT_FOUNDSYMSRV:  RESULT: 0x80190194DBGHELP: C:\Windows\system32\netkvm.sys - file not foundDBGHELP: C:\Windows\system32\netkvm.sys - file not foundDBGENG:  \SystemRoot\System32\drivers\netkvm.sys - Image mapping disallowed by non-local path.Unable to load image \SystemRoot\System32\drivers\netkvm.sys, Win32 error 0n2SYMSRV:  BYINDEX: 0x20        d:\symbols*https://msdl.microsoft.com/download/symbols        netkvm.pdb        E2CD669467F24AFB9856B5AF63BB298B2SYMSRV:  UNC: d:\symbols\netkvm.pdb\E2CD669467F24AFB9856B5AF63BB298B2\netkvm.pdb - path not foundSYMSRV:  UNC: d:\symbols\netkvm.pdb\E2CD669467F24AFB9856B5AF63BB298B2\netkvm.pd_ - path not foundSYMSRV:  UNC: d:\symbols\netkvm.pdb\E2CD669467F24AFB9856B5AF63BB298B2\file.ptr - path not foundSYMSRV:  HTTPGET: /download/symbols/netkvm.pdb/E2CD669467F24AFB9856B5AF63BB298B2/netkvm.pdbSYMSRV:  HttpQueryInfo: 80190194 - HTTP_STATUS_NOT_FOUNDSYMSRV:  HTTPGET: /download/symbols/netkvm.pdb/E2CD669467F24AFB9856B5AF63BB298B2/netkvm.pd_SYMSRV:  HttpQueryInfo: 80190194 - HTTP_STATUS_NOT_FOUNDSYMSRV:  HTTPGET: /download/symbols/netkvm.pdb/E2CD669467F24AFB9856B5AF63BB298B2/file.ptrSYMSRV:  HttpQueryInfo: 80190194 - HTTP_STATUS_NOT_FOUNDSYMSRV:  RESULT: 0x80190194DBGHELP: C:\cygwin64\tmp\build\source\internal-kvm-guest-drivers-windows\NetKVM\x64\Win10Release\netkvm.pdb - file not foundDBGHELP: netkvm - no symbols loaded************* Symbol Loading Error Summary **************Module name            Errornetkvm                 The system cannot find the file specified                The SYMSRV client failed to find a file in the UNC store, or there                is an invalid UNC store (an invalid path or the pingme.txt file is                not present in the root directory), or the file is present in the                symbol server exclusion list.</code></pre><p>从上述报错信息可以看到，windbg尝试从“d:\symbols\netkvm.sys\61A8F2E22e000”路径加载netkvm.sys文件，从“d:\symbols\netkvm.pdb\E2CD669467F24AFB9856B5AF63BB298B2”路径加载netkvm.pdb文件。因此解决方法也很简单，创建指定的文件目录，并把所需的文件放入到指定的路径下，并使用“.reload”指令重新加载pdb文件后查看stack，可以看到netkvm显示了具体的调用函数信息。</p><pre><code>fffff802`8f11dc08 fffff802`8d247a4e     : 00000000`00000080 00000000`004f4454 00000000`00000000 00000000`00000000 : nt!KeBugCheckExfffff802`8f11dc10 fffff802`8d4bc1c0     : ffffc006`7b554968 fffff802`8d25fe30 fffff802`8d25fe30 00000000`00000001 : hal!HalBugCheckSystem+0x7efffff802`8f11dc50 fffff802`8d248a1e     : fffff802`000006c0 fffff802`8d64a600 fffff802`8f11dd30 fffff802`8d3349d8 : nt!WheaReportHwError+0x258fffff802`8f11dcb0 fffff802`8d334302     : 00000000`000c00e1 00000000`00000000 00000000`00000000 fffff802`8d3347a8 : hal!HalHandleNMI+0xfefffff802`8f11dce0 fffff802`8d3f6142     : 00000000`000c00e1 fffff802`8f11def0 00000000`00000000 00000000`00000000 : nt!KiProcessNMI+0x106fffff802`8f11dd30 fffff802`8d3f5f43     : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : nt!KxNmiInterrupt+0x82fffff802`8f11de70 fffff802`8d3fd6a1     : fffff802`8d22b2f5 00000000`00000002 fffff802`8d22b2f5 00000000`00000002 : nt!KiNmiInterrupt+0x1c3 (TrapFrame @ fffff802`8f11de70)ffff8300`63eada68 fffff802`8d22b2f5     : 00000000`00000002 fffff802`8d22b2f5 00000000`00000002 fffff802`8d22b2f5 : nt!HvlWriteApicCommandRegister+0x1dffff8300`63eada70 fffff802`8d213b62     : ffffffff`ffd10738 00000000`00000001 ffff8300`63eadbb0 00001f80`00260cb0 : hal!HalpApicRequestInterrupt+0x176b5ffff8300`63eadae0 fffff802`8d2c92a3     : 00000000`00000001 fffff802`8d21392f ffffffff`ffd10738 00000000`00000001 : hal!HalRequestIpi+0x452ffff8300`63eadd60 fffff802`8d2c8b49     : 00000000`00000001 00000000`00010008 00000000`00000001 00000000`00000002 : nt!KiIpiSendRequest+0x453ffff8300`63eadf70 fffff802`8d2d7e2f     : 00000000`00000002 00000000`00000000 00000000`00000002 00000000`074d8416 : nt!MiFlushTbList+0x349ffff8300`63eae0c0 fffff802`8d2cb9b8     : ffffee81`5e88c420 00000000`c0000001 ffffee80`0000c420 00000000`00000004 : nt!MiGetPteFromCopyList+0x9fffff8300`63eae1e0 fffff802`8d296966     : 00000000`00000416 00000000`074d8416 80000074`d8416963 00000000`00000004 : nt!MiCopyPage+0x3e8ffff8300`63eae2a0 fffff802`8d293e27     : ffffee81`5e88c420 00000000`074d8416 ffffee81`5e88c420 00000000`08100000 : nt!MiStealPage+0x1562ffff8300`63eae620 fffff802`8d291e48     : fffff802`8d5af400 ffffee81`5e88c420 00000000`00000001 ffff8300`63eae760 : nt!MiClaimPhysicalRun+0x4cbffff8300`63eae6b0 fffff802`8d28f31d     : 00000000`00000000 00000000`00000000 00000000`00000004 fffff802`00000003 : nt!MiFindContiguousPages+0x424ffff8300`63eae830 fffff802`8d28f141     : ffff8300`00000000 00000000`00001000 0000000f`ffffffff fffff180`0001e8a8 : nt!MiAllocateContiguousMemory+0x1bdffff8300`63eae8d0 fffff802`8d2331d2     : 00000000`00011000 00000000`00000000 00000000`00001000 00000000`00000000 : nt!MmAllocateContiguousNodeMemory+0x81ffff8300`63eae920 fffff80a`6d202a2e     : 00000000`00000001 ffffc006`7b54f1a0 ffffc006`862e1648 00000000`00001000 : hal!HalAllocateCommonBufferV2+0x5effff8300`63eae960 fffff80a`6da67455     : ffffc006`862e1930 00000000`00000001 fffff80a`6da73601 00000000`00001000 : NDIS!NdisMAllocateSharedMemory+0xfeffff8300`63eae9c0 fffff80a`6da5d853     : ffffc006`862e1930 ffffc006`7d9c4340 ffffc006`356d7551 ffff8300`6ff7c010 : netkvm!ParaNdis_InitialAllocatePhysicalMemory+0x29 [C:\cygwin64\tmp\build\source\internal-kvm-guest-drivers-windows\NetKVM\wlh\ParaNdis6_Impl.cpp @ 119] ffff8300`63eaea00 fffff80a`6da5dd12     : ffffc006`7d9c4340 fffff80a`6da77000 00000000`0000009b ffffc006`7d9c43a8 : netkvm!CParaNdisRX::CreateRxDescriptorOnInit+0xc3 [C:\cygwin64\tmp\build\source\internal-kvm-guest-drivers-windows\NetKVM\Common\ParaNdis_RX.cpp @ 164] ffff8300`63eaea40 fffff80a`6da5d733     : ffffc006`7d9c4340 00000000`00000000 00000000`00000030 00000000`00000000 : netkvm!CParaNdisRX::PrepareReceiveBuffers+0x5e [C:\cygwin64\tmp\build\source\internal-kvm-guest-drivers-windows\NetKVM\Common\ParaNdis_RX.cpp @ 114] ffff8300`63eaea80 fffff80a`6da54a9f     : ffffc006`7b541000 00000000`0000002e fffff80a`356d7551 00000000`356d0047 : netkvm!CParaNdisRX::Create+0x6b [C:\cygwin64\tmp\build\source\internal-kvm-guest-drivers-windows\NetKVM\Common\ParaNdis_RX.cpp @ 99] ffff8300`63eaeab0 fffff80a`6da5309b     : 00000000`00000000 fffff80a`6da77000 00000000`00000000 ffffc006`7b541000 : netkvm!ParaNdis_VirtIONetInit+0x233 [C:\cygwin64\tmp\build\source\internal-kvm-guest-drivers-windows\NetKVM\Common\ParaNdis_Common.cpp @ 1143] ffff8300`63eaeb10 fffff80a`6da65dc9     : ffffc006`7b541498 ffff8300`63eaec50 ffffc006`7b541000 fffff80a`6d1c76b8 : netkvm!ParaNdis_FinishInitialization+0x97 [C:\cygwin64\tmp\build\source\internal-kvm-guest-drivers-windows\NetKVM\Common\ParaNdis_Common.cpp @ 1301] ffff8300`63eaeb50 fffff80a`6d1fd532     : ffffc006`7b54f1a0 ffffc006`7b54f1a0 ffff8300`63eaee70 ffffc006`7b550028 : netkvm!ParaNdis6_Initialize+0x4b9 [C:\cygwin64\tmp\build\source\internal-kvm-guest-drivers-windows\NetKVM\wlh\ParaNdis6_Driver.cpp @ 332] ffff8300`63eaed10 fffff80a`6d23b848     : ffffc006`7b54fed8 00000000`00000000 00000000`00000000 ffffc006`7b54f1a0 : NDIS!ndisMInvokeInitialize+0x5effff8300`63eaed70 fffff80a`6d1fd9d3     : 00000000`00000000 00000000`000005b4 ffffc006`7b744490 01da68a5`e1ad1af4 : NDIS!ndisMInitializeAdapter+0x4d4ffff8300`63eaf430 fffff80a`6d1fdae0     : 00000000`000005b4 ffffc006`7b7fc490 ffffaa0d`0d578010 ffffc006`7b54f1a0 : NDIS!ndisInitializeAdapter+0x5fffff8300`63eaf480 fffff80a`6d1efb3b     : ffffc006`7b54f1a0 fffff80a`6d1ef9f0 ffffc006`78092250 fffff802`8d74969c : NDIS!ndisPnPStartDevice+0x80ffff8300`63eaf4c0 fffff80a`6d1efa21     : 00000000`00000100 ffffc006`7b54f1a0 ffffc006`7b7f80c0 fffff80a`6d06f4a0 : NDIS!ndisStartDeviceSynchronous+0x4fffff8300`63eaf510 fffff802`8d2cfb59     : ffffc006`756dd040 ffffc006`7b7f80c0 ffffaa0d`00000000 ffffc006`756dd040 : NDIS!ndisStartDeviceWorkItem+0x31ffff8300`63eaf540 fffff802`8d321a39     : ffffc006`756dd040 00000000`00000080 ffffc006`7569e6c0 ffffc006`756dd040 : nt!ExpWorkerThread+0xe9ffff8300`63eaf5d0 fffff802`8d3f2976     : ffff8300`5df40180 ffffc006`756dd040 fffff802`8d3219f8 00000000`00000000 : nt!PspSystemThreadStartup+0x41ffff8300`63eaf620 00000000`00000000     : ffff8300`63eb0000 ffff8300`63ea9000 00000000`00000000 00000000`00000000 : nt!KiStartSystemThread+0x16</code></pre><script src="https://utteranc.es/client.js" repo="bbbccvbvv/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;在使用windbg分析windows产生的dmp异常转储文件时，常常需要使用到相关应用的pdb文件，否则就只能看到粗略的模块，却不能看到具体的函数执行内容。而微软的官方pdb服务器可以下载到windows相关的pdb文件，对于非官方的程序或驱动，就需要调试者自己去查找并进行设置。本文就如何在使用windbg调试dmp时，如何手动添加非官方的pdb文件进行描述，希望能够帮助遇到该问题的开发者。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="windbg" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/windbg/"/>
    
    
    <category term="windows" scheme="https://bbbccvbvv.github.io/tags/windows/"/>
    
    <category term="windbg" scheme="https://bbbccvbvv.github.io/tags/windbg/"/>
    
    <category term="非官方pdb" scheme="https://bbbccvbvv.github.io/tags/%E9%9D%9E%E5%AE%98%E6%96%B9pdb/"/>
    
  </entry>
  
  <entry>
    <title>关于南宋权相现象的一些思考</title>
    <link href="https://bbbccvbvv.github.io/2024/02/27/south_song_leader-20240227/"/>
    <id>https://bbbccvbvv.github.io/2024/02/27/south_song_leader-20240227/</id>
    <published>2024-02-27T11:56:10.000Z</published>
    <updated>2024-02-27T11:57:02.946Z</updated>
    
    <content type="html"><![CDATA[<p>秦朝奠定了三公九卿制度，但先是西汉时，汉武帝建立内朝，剥夺了丞相的定策权利，转而以尚书主管负责内朝的实际运转。</p><span id="more"></span><p>再是东汉时以三公取代丞相的职权，甚至于不再设置丞相，将相权拆分为多份，而实际处理政务、发号施令的机构是尚书台，因此两汉权臣的标配是录尚书事。</p><p>三国时，蜀国丞相只有诸葛亮一人，后面的蒋费二人都没有获得丞相的官职，主要是以大将军身份处理朝政。而东吴的丞相一直存在，但是大多数情况下只是朝局发展的背景板。魏国则在尚书台机构之外，设立了中书监机构，剥夺了尚书的部分职权。</p><p>西晋大体维持了中书尚书和三公的权力架构，但是东晋迫于北方的严峻军事压力又设立了丞相一职，后来的南朝又新增了门下机构用以制衡中书机构。</p><p>隋唐一统天下，最终以三省六部取代三公九卿，完成了制度的又一变革，但是唐末的节度使制度崩坏，而文官的官职分离则是行政制度发展的又一趋势。</p><p>北宋统一了中原及南方后，对制度进行了修正，形成了东西府制度，即代表文官的中书门下和代表武官的枢密院，两院的首长都可以成为宰相。</p><p>由宋神宗和王安石推动的变法运动不仅是致力于政策的实施，同时修正了官制，使得官职分离的现象得到改善。而到了南宋，则出现了北宋从没有出现过的权相，这一现象的产生必然有其深刻的社会历史原因。</p><p>纵观之前的制度建设情况，丞相代表的是以官僚为主的行政权，而皇帝大部分情况下的皇权实质是军权，即皇帝代表的暴力机构与官僚的对抗是政治制度发展变化的主要原因。而之前对于相权的拆分与削弱也可以认为是皇帝代表的军权的衰弱，皇权弱了，如果不削弱对应的相权，那么可能又会出一个王莽了。这个制度在承平年代还能撑得住，换言之，大部分人无所谓其好与不好，只是没有新的出路，凑活着过罢了。但是这个制度一旦面临外部冲击，其自身是十分脆弱的，因为制度改革把大部分情况下不足以更新体制本身，只是隔靴搔痒罢了，更何况皇帝的个人素质大部分情况下连中人之姿都没有，维持一个强力的相权，难道不怕喧宾夺主吗？所以皇权和相权大部分情况下都是臭棋篓子下棋，越下越臭，两者一同衰弱。</p><p>衰弱的封建制度遇到了有活力的社会团体的冲击，自然要先被打个七零八落的。但是官僚制度既然存在必然有其存在的理由，秦皇汉武、唐宗宋祖都是在这个体制的支撑下才成就其事业的。外部冲击下，直观的表现就是战争失利，面临生死存亡的危机，皇帝与官僚也不得不放弃对于武将的压制，因此军队就首先在外部冲击之下变得高效起来，而军队的维持需要消耗物资，越高效的军队对于物资的消耗量也越大，这就要求有一个与之配套的组织生产的机构，即行政官僚。因此中国的历史大致就可以看作是，承平日久，军队和官僚一起摆烂，毕竟军队都烂了，官僚也没必要再保持那么高的行政效率。突遇危机，军队不得不高效，因此行政制度也随之高效运转，一些以前不能突破的禁区突破了，不敢动的规则变更了，整个社会在先军的目标下运行效率逐渐提升。</p><p>因此南宋的权相产生原因便是源于自北宋末年而来的来自于北方的强大军事压力，在这种情况下，往往会有一个所谓的中兴之主，重新驾驭高效的军事及行政机构，完成复兴，并再次衰落。但是很可惜，完颜构不是这样的人（有人辩解九妹比南明强多了，那我就说你都和南明比了，就顺从你吧）。即军事及行政机构复兴后，皇帝没有能力或不愿驾驭相关权力，但是权力天然就会集中，因此作为文官之首的丞相是驾驭这一权力的天然顺位继承人，这就是南宋出现这些权相的原因。</p><p>只是权相可以驾驭这些权力，但是却不具有大义的名分。因此看似权力虽大，但是始终无法突破体制的桎梏，在初期的辉煌之后只能落寞，在体制内缝缝补补。幸而北方的金朝也同步衰落，让其续命若干年，但是面临更加高效的蒙古体制的冲击，必然败下阵来。</p><p>有人说元朝的民族歧视政策，但是九妹的南宋也是有归正人与北人的说法的。纵观历史，宋朝军队只要皇帝不姓赵，其战斗力都是极为强大的，每思至此，免不得一声长叹。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;秦朝奠定了三公九卿制度，但先是西汉时，汉武帝建立内朝，剥夺了丞相的定策权利，转而以尚书主管负责内朝的实际运转。&lt;/p&gt;</summary>
    
    
    
    <category term="历史" scheme="https://bbbccvbvv.github.io/categories/%E5%8E%86%E5%8F%B2/"/>
    
    
    <category term="南宋权相" scheme="https://bbbccvbvv.github.io/tags/%E5%8D%97%E5%AE%8B%E6%9D%83%E7%9B%B8/"/>
    
    <category term="丞相制度" scheme="https://bbbccvbvv.github.io/tags/%E4%B8%9E%E7%9B%B8%E5%88%B6%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】windbg调试0xef异常（1）</title>
    <link href="https://bbbccvbvv.github.io/2024/02/05/windbg_0xef_debug_1/"/>
    <id>https://bbbccvbvv.github.io/2024/02/05/windbg_0xef_debug_1/</id>
    <published>2024-02-05T13:17:00.000Z</published>
    <updated>2024-02-05T13:23:21.938Z</updated>
    
    <content type="html"><![CDATA[<p>停止码0xEF出现的可能原因如下：</p><span id="more"></span>​<p>（1）硬件故障，尤其是内存和磁盘；</p><p>（2）安全软件例如杀毒软件；</p><p>（3）windows自身原因；</p><p>第一个原因是以上三个原因中最普遍的原因，尤其是加载到内存中的程序因为一些未处理的异常而中止自身运行是最典型的情况。之后造成操作系统突然panic并抛出0xEF停止码。另一方面，如果安全软件不信任二进制运行文件并中止其运行。如果对应的程序是critical关键进程（例如scvhost.exe），这会造成灾难性的后果。但是第二种情况较少出现。</p><p>然而，在这篇文章中，我将会将注意力集中到第三个原因上，当启动了影子栈shadow stack功能，并且监测到影子栈与调用栈间存在差异，windows系统会中止运行进程，并进而导致0xEF停止码被抛出。这也是我把windows自身作为0xEF异常产生原因的理由，尽管这种情况也有可能是因为异常的驱动程序或内存引起的。</p><p>如果启用了基于硬件的栈保护，处理器会保持两份调用栈的拷贝，第二份拷贝就是知名的影子栈。该栈旨在控制线程的运行流，如果任一栈的返回地址存在异常，则一个特殊的硬件异常被抛出进而造成进程被windows中止。</p><pre><code>CRITICAL_PROCESS_DIED (ef)        A critical system process diedArguments:Arg1: ffffaf08b56a90c0, Process object or thread objectArg2: 0000000000000000, If this is 0, a process died. If this is 1, a thread died.Arg3: 0000000000000000Arg4: 00000000000000003: kd&gt; knL# Child-SP          RetAddr               Call Site00 ffff8c0a`14b3ed38 fffff801`0ed0d122     nt!KeBugCheckEx01 ffff8c0a`14b3ed40 fffff801`0ec0c7a3     nt!PspCatchCriticalBreak+0x10e02 ffff8c0a`14b3ede0 fffff801`0ea99290     nt!PspTerminateAllThreads+0x17291703 ffff8c0a`14b3ee50 fffff801`0ea9908c     nt!PspTerminateProcess+0xe004 ffff8c0a`14b3ee90 fffff801`0e80f8f8     nt!NtTerminateProcess+0x9c &lt;&lt; Terminate our svchost.exe process which then bugchecks the system05 ffff8c0a`14b3ef00 fffff801`0e800ca0     nt!KiSystemServiceCopyEnd+0x2806 ffff8c0a`14b3f098 fffff801`0e860d9d     nt!KiServiceLinkage07 ffff8c0a`14b3f0a0 fffff801`0e8106a4     nt!KiDispatchException+0x17941d08 ffff8c0a`14b3f8e0 fffff801`0e80e03c     nt!KiFastFailDispatch+0xe409 ffff8c0a`14b3fac0 00007ffc`f18833c6     nt!KiControlProtectionFault+0x2fc &lt;&lt; Throws #CP (Control Protection) exception0a 0000002f`4637f820 000001b1`ae000340     ntdll!RtlpGetActivationContextData+0x520b 0000002f`4637f828 000001b1`ae002480     0x000001b1`ae0003400c 0000002f`4637f830 00000000`00000001     0x000001b1`ae0024800d 0000002f`4637f838 000001b1`000000f0     0x10e 0000002f`4637f840 00000000`00000002     0x000001b1`000000f00f 0000002f`4637f848 00000050`00000000     0x210 0000002f`4637f850 00000000`00000002     0x00000050`0000000011 0000002f`4637f858 00000000`000000f0     0x212 0000002f`4637f860 00000000`00000000     0xf0</code></pre><p>如果检查传递给nt!KiDispatchException函数的第一个参数，就可以看到抛出的异常类型信息。</p><pre><code>07 ffff8c0a14b3f0a0 fffff8010e8106a4 nt!KiDispatchException+17941d (perf)    Parameter[0] = ffff8c0a14b3fa18    Parameter[1] = 0000000000000000    Parameter[2] = ffffffffffffff80    Parameter[3] = 0000002f4637f8203: kd&gt; .exr ffff8c0a14b3fa18ExceptionAddress: 00007ffcf18833c6 (ntdll!RtlpGetActivationContextData+0x0000000000000052)ExceptionCode: c0000409 (Security check failure or stack buffer overrun)ExceptionFlags: 00000001NumberParameters: 1Parameter[0]: 0000000000000039Subcode: 0x39 FAST_FAIL_CONTROL_INVALID_RETURN_ADDRESS Shadow stack violation</code></pre><p>进一步检查异常，当启用了cet（Control-flow Enforcement Technology，控制流执行技术）时，运行调用指令，两个返回地址被压入栈：一个进入了调用栈，另一个进入影子栈。之后当返回指令运行时，会检查并比较两个返回地址，如果两个地址不匹配，则cp异常就会像之前提到的那样被抛出。但是cet仅在使用call调用指令时起作用，当使用压栈指令将地址压栈时，cet不起作用，因此影子栈中也不存在返回地址。考虑到这一点，推荐使用cfg保护的jmp跳转指令。cfg的行为与cet类似，如果发现了异常，则中止违规进程。如果进程是critical关键进程，抛出0xEF停止码。</p><p>参考链接：</p><p>1.<a href="https://techcommunity.microsoft.com/t5/windows-os-platform-blog/developer-guidance-for-hardware-enforced-stack-protection/ba-p/2163340%EF%BC%9B">https://techcommunity.microsoft.com/t5/windows-os-platform-blog/developer-guidance-for-hardware-enforced-stack-protection/ba-p/2163340；</a></p><p>2.<a href="https://learn.microsoft.com/en-us/windows/win32/secbp/control-flow-guard%EF%BC%9B">https://learn.microsoft.com/en-us/windows/win32/secbp/control-flow-guard；</a></p><p>原文链接：<a href="https://bsodtutorials.wordpress.com/2023/12/09/debugging-stop-0xef-critical_process_died/">https://bsodtutorials.wordpress.com/2023/12/09/debugging-stop-0xef-critical_process_died/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;停止码0xEF出现的可能原因如下：&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="windbg" scheme="https://bbbccvbvv.github.io/tags/windbg/"/>
    
    <category term="停止码0xEF" scheme="https://bbbccvbvv.github.io/tags/%E5%81%9C%E6%AD%A2%E7%A0%810xEF/"/>
    
    <category term="bsod" scheme="https://bbbccvbvv.github.io/tags/bsod/"/>
    
  </entry>
  
  <entry>
    <title>《矛盾论》与《实践论》读后感</title>
    <link href="https://bbbccvbvv.github.io/2024/01/23/on_contraction_on_practice/"/>
    <id>https://bbbccvbvv.github.io/2024/01/23/on_contraction_on_practice/</id>
    <published>2024-01-23T04:56:10.000Z</published>
    <updated>2024-01-23T08:09:06.282Z</updated>
    
    <content type="html"><![CDATA[<p>教员曾经说过：“上了大学，不想和工人划等号了，要作工人贵族。就是普通的工人农民每天也在进步。群众是真正的英雄，而我们却是幼稚可笑的，包括我。”。作为一个经历过大学教育的人，一时间竟不知道该如何自称，读书人或知识分子总感觉是臭老九之类的骂人的话，虽然想自称为劳动者，可是感觉又无法表现出来自己的一些特质（仔细想来除了大学好像也没有什么值得称道的特质了），看来自己还是比较虚伪的，还是需要自我检讨。</p><span id="more"></span><p>作为已经而立之年的90后，我这个人在家里人看来有些不省心，一没房，二没车，更不要说婚姻与家庭了，因此父母总是有些抱怨。本人在闲暇时间也是总在思考，自己当前的生活状态的原因是什么，推到自己的经历与性格肯定是主要原因，但是好像只讲自己的性格又有些片面。人是社会性的人，我自然与父母有不同的时代经历与三观，但是人要考虑自身，同时也需要来考虑其身处的时代。但是如果将一切都推给时代，又颇有些怨天尤人的无能狂怒，好像时代变化了就没有现在的这些问题了。这是有可能的，但是这又是不科学的，事物总在变化发展之中，旧的矛盾消失，新的矛盾出现，妄图通过某一项或多项的举动就能一劳永逸，这是不现实的。因此我就尝试从先哲的思想中学习相关的方法论，以期可以帮助分析自己现在遇到的问题，或者也可以说是逃到知识的海洋里以忘却现实的烦扰。但是需要记住，逃避只是一时，事情总会发展到你逃无可逃的地步，当你对自身有了一定的认知时，就需要结合理论进行实践，否则就只能是一个嘴强王者了。</p><p>选择《矛盾论》与《实践论》的主要原因是我很敬佩教员。90后的青年（貌似40还可以算作青年，我这也不算装嫩了）对于他的态度是不断变化的。就我个人而言，在我出生成长的年代，对于前三十年的否定是社会的主流意识形态，记得小时候看到的书及文章，有揭露cv黑暗的，有展示国军抗日功绩的，当时年少的我对于他的态度是很激烈的，37都不太认同，更是幻想要不是他，说不定提前30年就过上好日子了。仔细想来这种态度确实在我们那一代人里还是比较有市场的，具体问题具体分析、实事求是的态度很多成年人或大人物都无法做到，更何况我们这些小孩子呢。</p><p>孩子大多不具有辨别材料真伪的能力，因此社会的主流意识形态便会不自觉地占领孩子们的大脑，并在很长一段时间内产生影响。但是中国的教育又与其他国家存在区别，虽然中国的教育存在问题，但是像政治课这种统治阶级基础课却是义务教育阶段的必修课，这在其他国家还是很少见的。毕竟不是哪个统治阶级都乐意把血淋淋的现实呈现在人民面前，而人民也往往轻易的放弃了自己的权力，在青少年间普及政治教育更像是一项吃力不讨好的举动。对于统治阶级，人民中头脑清醒的人越多就越不好管，刁民就越多。而对于青少年，枯燥的知识远不如其他学科吸引人，更像是被灌输。可是有趣的是，青少年意识到自己被灌输，意识到自己被统治，这正是开设相关课程的目的所在。</p><p>对于我而言，初中时开设的政治课讲了一些阶级与国家的概念，印象最深的一句就是“国家是阶级统治的工具”，当时年少轻狂，觉得社会存在一些黑暗现象，因此这句话就十分符合个人胃口，可作为对于现实的控诉理由。当时学的阶级、国家、国家暴力机器等等观点，虽然是以灌输式的方法强行记下来的，但是这些观点却在以后的岁月里总是不断浮现，现实教育了自己这些观点的普遍性与泛用性。因此学生期间有多么厌恶思政，进入社会后就多么同意保留这些课程。</p><p>重读在这两篇文章后，突然发现其中的观点大部分都在大学的相关思政课上学过了，《矛盾论》的基本观点在教材上都有，而《实践论》则着重提了理性认识与感性认识，但是却缺失了社会实践的相关描述（也可能是我学的不好，忘记了）。我的学校是一所工科学校，我也是工科专业，本科生的思政课一直持续到了大三，当时的思政课老师我还有些印象，印象最深的自然是她给了我高分（虽然可能是我在之前的课堂活动上有些出风头，强辩而非专业辩论积累了一定的表现分），另外就是她说之前都是工科生治国，当时却有一个她的校友（我们学校隔壁）进入了长老团，因此这可能代表一些社会趋势的变化，但是现在看来变化也不是很大，不是每个文科生都能像教员那样的。</p><p>结合自身的一些经历，发现自己的社会实践主要是生产活动，其他的社会实践好像都没有参与，不知道写博客算不算是文学艺术创作，应该是不算的。而这个生产活动也只是雇佣劳动，并没有掌握生产资料，连高级打工仔都不算，就是底层的码农。7年的时间下来，对于资本主义雇佣劳动关系理解更深了，因此对于某些事物的态度也更为悲观了。不过脾气确实好了很多，也可以认为是被社会打平了棱角，但是总归来说都是自己的选择罢了。记得之前高中毕业时，曾经寄语：不要成为自己厌恶的那些人。可以说做到了，但是也没有成为自己想要成为的那些人，总归来说，还是一个不是那么坏的人，一个不给社会添麻烦的人。</p><p>现实不是文学创作，矛盾与知行的理论也不是教员首先提出，我记得道家就有过一句话：反者，道之动，与矛盾的变化发展观点就有着异曲同工之妙，而王阳明的知行合一也可以看作是认知与实践的一个很好的注解。但是正如后世的道家与心学无法深入贯彻先哲的学说，如今的我在读了教员的理论后，也不见得就可以立即拿来指导生活实践，但是我会努力朝着这个方向实践，分析自己，总结经验，争取成为一个真实的人，一个有用的人，一个热爱劳动的人，一个有益于人民的人。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;教员曾经说过：“上了大学，不想和工人划等号了，要作工人贵族。就是普通的工人农民每天也在进步。群众是真正的英雄，而我们却是幼稚可笑的，包括我。”。作为一个经历过大学教育的人，一时间竟不知道该如何自称，读书人或知识分子总感觉是臭老九之类的骂人的话，虽然想自称为劳动者，可是感觉又无法表现出来自己的一些特质（仔细想来除了大学好像也没有什么值得称道的特质了），看来自己还是比较虚伪的，还是需要自我检讨。&lt;/p&gt;</summary>
    
    
    
    <category term="哲学" scheme="https://bbbccvbvv.github.io/categories/%E5%93%B2%E5%AD%A6/"/>
    
    
    <category term="《矛盾论》" scheme="https://bbbccvbvv.github.io/tags/%E3%80%8A%E7%9F%9B%E7%9B%BE%E8%AE%BA%E3%80%8B/"/>
    
    <category term="《实践论》" scheme="https://bbbccvbvv.github.io/tags/%E3%80%8A%E5%AE%9E%E8%B7%B5%E8%AE%BA%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Windows系统tscon工具概述</title>
    <link href="https://bbbccvbvv.github.io/2023/12/22/windows_tool_tscon/"/>
    <id>https://bbbccvbvv.github.io/2023/12/22/windows_tool_tscon/</id>
    <published>2023-12-22T12:15:41.000Z</published>
    <updated>2024-01-02T13:04:15.607Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到了一个使用tscon工具解决windows远程链接断开后部分应用随之中断的案例，因此对tscon产生了一些好奇，这里就总结一下tscon工具的功能及使用方法。<br>在微软的官方文档上（<a href="https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/tscon">tscon</a>）可以看到该工具的一些描述，因此结合该文档对tscon工具进行描述。</p><span id="more"></span>​<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>该工具用来连接到远程桌面会话主机服务器上的另一个会话。<br>备注：必须拥有“完全控制”访问权限或“连接”特殊访问权限才能连接到另一个会话（即使用该工具的账号需具有较高的权限）</p><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p>Windows server服务器，即Windows Server 2022、Windows Server 2019、Windows Server 2016、Windows Server 2012 R2、Windows Server 2012。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><pre><code>tscon &#123;&lt;sessionID&gt; | &lt;sessionname&gt;&#125; [/dest:&lt;sessionname&gt;] [/password:&lt;pw&gt; | /password:*] [/v]</code></pre><p>参数详解如下：</p><ul><li><sessionID>：指定要连接到的会话的 ID。 如果你使用可选的 &#x2F;dest:<sessionname> 参数，则还可以指定当前会话的名称。</li><li><sessionname>：指定要连接到的会话的名称</li><li>&#x2F;dest:<sessionname>：指定当前会话的名称。 连接到新会话时，此会话将断开连接。 还可以使用此参数将其他用户的会话连接到一个不同的会话。</li><li>&#x2F;password:<pw>：指定拥有你要连接到的会话的用户的密码。 当进行连接的用户不拥有会话时，需要提供此密码。</li><li>&#x2F;password:*：提示输入拥有你要连接到的会话的用户的密码。</li><li>&#x2F;v：显示有关正在执行的操作的信息。</li><li>&#x2F;?：在命令提示符下显示帮助。</li></ul><p>备注：<br>（1）如果未在 &#x2F;password 参数中指定密码，并且目标会话属于当前用户以外的用户，则此命令将失败。<br>（2）你无法连接到控制台会话。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>（1）若要连接到当前远程桌面服务会话主机服务器上的会话 12，并断开当前会话的连接，请键入：</p><pre><code>tscon 12</code></pre><p>(2)若要使用密码 mypass 连接到当前远程桌面服务会话主机服务器上的会话 23，并断开当前会话的连接，请键入：</p><pre><code>tscon 23 /password:mypass</code></pre><p>（3）若要将名为 TERM03 的会话连接到名为 TERM05 的会话，然后断开会话 TERM05 的连接，请键入：</p><pre><code>tscon TERM03 /v /dest:TERM05</code></pre><h2 id="复杂脚本分析"><a href="#复杂脚本分析" class="headerlink" title="复杂脚本分析"></a>复杂脚本分析</h2><p>当使用远程桌面连接到远程计算机时，关闭远程桌面将会锁定计算机并显示登录界面，在锁定模式下，计算机不会有GUI图形界面，因此所有正在运行和即将调度的GUI任务都会失败。<br>为避免GUI任务失败，可以使用tscon组件实现从远程桌面断开连接，tscon会把控制权返还给远程计算机上的原始本地会话，这样就绕过了登录界面。远程计算机上的全部程序（包含GUI图形任务在内）都会继续正常运行。</p><pre><code>for /f &quot;skip=1 tokens=3&quot; %%s in (&#39;query user %USERNAME%&#39;) do (%windir%\System32\tscon.exe %%s /dest:console)</code></pre><p>该脚本的运行逻辑如下：<br>1.查询以用户名%USERNAME%登录的全部会话；<br>2.使用”skip&#x3D;1 tokens&#x3D;3”语法过滤掉查询结果的首行（标题行），并选取第3列（session ID）作为输出值；<br>3.遍历筛选过的全部会话id，使用tscon将会话的控制钱返还给计算机上的原始本地会话（console），依此实现断开连接，但是绕过登录界面，保持会话内的全部任务可以后续继续执行；</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>1.<a href="https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/tscon%EF%BC%9B">https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/tscon；</a><br>2.<a href="https://support.smartbear.com/testcomplete/docs/testing-with/running/via-rdp/keeping-computer-unlocked.html%EF%BC%9B">https://support.smartbear.com/testcomplete/docs/testing-with/running/via-rdp/keeping-computer-unlocked.html；</a><br>3.<a href="https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/for%EF%BC%9B">https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/for；</a><br>4.<a href="https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/query-user%EF%BC%9B">https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/query-user；</a><br>​</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近看到了一个使用tscon工具解决windows远程链接断开后部分应用随之中断的案例，因此对tscon产生了一些好奇，这里就总结一下tscon工具的功能及使用方法。&lt;br&gt;在微软的官方文档上（&lt;a href=&quot;https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/tscon&quot;&gt;tscon&lt;/a&gt;）可以看到该工具的一些描述，因此结合该文档对tscon工具进行描述。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="tscon" scheme="https://bbbccvbvv.github.io/tags/tscon/"/>
    
    <category term="windows会话" scheme="https://bbbccvbvv.github.io/tags/windows%E4%BC%9A%E8%AF%9D/"/>
    
    <category term="微软官方工具" scheme="https://bbbccvbvv.github.io/tags/%E5%BE%AE%E8%BD%AF%E5%AE%98%E6%96%B9%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>windbg标准调试技巧-读写内存（5）：将虚拟地址转换为物理地址</title>
    <link href="https://bbbccvbvv.github.io/2023/08/07/windbg_debug_technique_reading_and_writing_memory_5/"/>
    <id>https://bbbccvbvv.github.io/2023/08/07/windbg_debug_technique_reading_and_writing_memory_5/</id>
    <published>2023-08-07T10:30:00.000Z</published>
    <updated>2023-12-29T02:38:41.469Z</updated>
    
    <content type="html"><![CDATA[<p>大多数调试器命令都是用虚拟地址而非物理地址作为输出及输出参数。然而，也同时存在物理地址起作用的场景。</p><span id="more"></span><p>这里有两种方式将虚拟地址转换为物理地址：使用!vtop扩展或使用!pte扩展。</p><p>#1 使用!vtop进行地址转换</p><ol><li><p>确保在16禁止之下进行操作。如果必要的话，通过N 16指令设置当前环境为16进制；</p></li><li><p>确定地址的字节索引。该数字等同于虚拟地址的低12位。因此，虚拟地址0x0012f980的字节索引为0x980；</p></li><li><p>通过使用!process扩展确定地址的字典进制：</p><pre><code> kd&gt; !process 0 0 **** NT ACTIVE PROCESS DUMP **** .... PROCESS ff779190  SessionId: 0  Cid: 04fcPeb: 7ffdf000  ParentCid: 0394 DirBase: 098fd000  ObjectTable: e1646b30 TableSize:   8. Image: MyApp.exe</code></pre></li><li><p>决定目录基址的页框号。这只是没有三个尾随十六进制零的目录基址。在本例中，目录基址为0x098FD000，因此页框号为0x098FD。</p></li><li><p>使用!vtop扩展。该扩展的第一个参数是页框号。!vtop的第二个参数就是问题中的虚拟地址：</p><p> kd&gt; !vtop 98fd 12f980<br> Pdi 0 Pti 12f<br> 0012f980 09de9000 pfn(09de9)</p></li></ol><p>最后一行中展示的第二个数字是物理页的起始物理地址。</p><ol start="6"><li>在页的开始出加上地址的字节索引：0x09DE9000 + 0x980 &#x3D; 0x09DE9980。这就是目标物理地址。</li></ol><p>也可以通过显示每个地址的内存来验证此计算是否正确完成。!d*扩展显示指定物理地址处的内存：</p><pre><code>kd&gt; !dc 9de9980# 9de9980 6d206e49 726f6d65 00120079 0012f9f4 In memory.......# 9de9990 0012f9f8 77e57119 77e8e618 ffffffff .....q.w...w....# 9de99a0 77e727e0 77f6f13e 77f747e0 ffffffff .&#39;.w&gt;..w.G.w....# 9de99b0 .....</code></pre><p>d*（展示内存）质量使用虚拟地址作为其参数：</p><pre><code>kd&gt; dc 12f9800012f980  6d206e49 726f6d65 00120079 0012f9f4  In memory.......0012f990  0012f9f8 77e57119 77e8e618 ffffffff  .....q.w...w....0012f9a0  77e727e0 77f6f13e 77f747e0 ffffffff  .&#39;.w&gt;..w.G.w....0012f9b0  .....</code></pre><p>因为结果相同，这就表明物理地址0x09DE9980确实代表了虚拟地址0x0012F980。</p><p>#2 使用!pte进行地址转换</p><p>假设客户正在调查属于MyApp.exe进程的虚拟地址0x0012F980。在使用!pte扩展指令获取其对应的物理地址过程中，操作如下：</p><ol><li><p>确保子啊16进制下进行运算。如果有必要，通过N 16指令设置当前环境为16进制；</p></li><li><p>获取地址的字节索引。该数字等同于虚拟地址的低12位。因此，虚拟地址0x0012f980的字节索引为0x980；</p></li><li><p>将进程上下文环境设置到目标进程中：</p><pre><code> kd&gt; !process 0 0 **** NT ACTIVE PROCESS DUMP **** .... PROCESS ff779190  SessionId: 0  Cid: 04fcPeb: 7ffdf000  ParentCid: 0394 DirBase: 098fd000  ObjectTable: e1646b30  TableSize:   8. Image: MyApp.exe  kd&gt; .process /p ff779190 Implicit process is now ff779190 .cache forcedecodeuser done</code></pre></li><li><p>使用!pte指令时以虚拟地址作为参数。输出信息以两列形式展示出来。左边的一列描述了地址对应的页目录条目（page directory entry，pe），右边列展示了页表条目（page table entry，pte）：</p><pre><code> kd&gt; !pte 12f980    VA 0012f980 PDE at   C0300000PTE at C00004BC contains 0BA58067  contains 09DE9067 pfn ba58 ---DA--UWVpfn 9de9 ---DA--UWV</code></pre></li><li><p>查看右边列的最后一行。符号”pfn 9de9”出现了。pte的页框号（page frame number，pfn）是0x9de9.页框号乘以0x1000（例如，左移12位）。结果0x09DE9000就是内存也的起始物理地址；</p></li><li><p>在页的开始出加上地址的字节索引：0x09DE9000 + 0x980 &#x3D; 0x09DE9980。这就是目标物理地址；</p></li></ol><p>与之前的方法得到了相同的结果。</p><p>#3 手动进行地址转换</p><p>尽管!ptov和pte指令提供了将虚拟地址转换为物理地址的最快方式，但是也可以人工完成这一转换过程。对该过程的描述将阐明虚拟内存体系结构的一些细节。</p><p>内存结构因其处理器和硬件配置的不同而会在大小方面发生变化。例子来源于一个没有启用物理地址扩展（physical address extension，pae）功能的x86系统。</p><p>使用0x0012F980作为虚拟地址，首先需要将该地址转换为2进制，可以手动转换，也可以使用.formats（dhow number formats，展示数字格式）指令实现：</p><pre><code>kd&gt; .formats 12f980Evaluate expression:  Hex:     0012f980  Decimal: 1243520  Octal:   00004574600  Binary:  00000000 00010010 11111001 10000000  Chars:   ....  Time:    Thu Jan 15 01:25:20 1970  Float:   low 1.74254e-039 high 0  Double:  6.14381e-318</code></pre><p>虚拟地址有3个字段组成。第0位到第11位是字节索引。第12位到第21位是页表索引。第22位到第31位是页目录索引。将对应字段进行拆分，实现如下：</p><pre><code>0x0012F980  =  0y  00000000 00   010010 1111   1001 10000000</code></pre><p>导出虚拟地址的3个字段：</p><ul><li>页目录索引&#x3D;0y0000000000&#x3D;0x0</li><li>页表索引&#x3D;0y0100101111&#x3D;0x12F</li><li>字节索引&#x3D;0y100110000000&#x3D;0x980</li></ul><p>之后系统需要3个额外的信息：</p><ul><li>每一个pte的大小。在非pae x86系统中是4个字节。</li><li>页大小。是0x1000字节。</li><li>PTE_BASE虚拟地址。在非pae系统中，是0xC0000000.</li></ul><p>使用这些数据，可以计算pte自身的地址：</p><pre><code>PTE address   =   PTE_BASE                  + (page directory index) * PAGE_SIZE                + (page table index) * sizeof(MMPTE)    =   0xc0000000                + 0x0   * 0x1000                + 0x12F * 4              =   0xC00004BC</code></pre><p>这就是pte的地址。pte是一个32位的双字变量。其内容如下：</p><pre><code>kd&gt; dd 0xc00004bc L1c00004bc  09de9067</code></pre><p>pte数值是0x09DE9067。其由两个字段组成。</p><ul><li>pte的低12位是状态标志（status flags）。在这种情况下，这些标志位等于0x067–或者二进制的0y000001100111.对于状态标志位的解释，可以查看!pte指令参考页。</li><li>pte的高20位等于pte的页框号pfn。在这种情况下，pfn是0x09DE9.</li></ul><p>物理页上的第一个物理地址是pfn乘以0x1000（即左移12位）。字节索引就是页上的偏移。因此，查找的物理地址就是0x09DE9000+0x980&#x3D;0x09DE9980。与之前的计算方式获取的结果一致。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大多数调试器命令都是用虚拟地址而非物理地址作为输出及输出参数。然而，也同时存在物理地址起作用的场景。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="windbg官方文档翻译" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/windbg%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="windbg" scheme="https://bbbccvbvv.github.io/tags/windbg/"/>
    
    <category term="convert virtual address to physical address" scheme="https://bbbccvbvv.github.io/tags/convert-virtual-address-to-physical-address/"/>
    
  </entry>
  
  <entry>
    <title>windbg标准调试技巧-读写内存（4）：访问局部变量</title>
    <link href="https://bbbccvbvv.github.io/2023/08/07/windbg_debug_technique_reading_and_writing_memory_4/"/>
    <id>https://bbbccvbvv.github.io/2023/08/07/windbg_debug_technique_reading_and_writing_memory_4/</id>
    <published>2023-08-07T10:20:00.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>与全局变量相同，局部变量也存储于符号文件中。更加一致的是，调试器也将局部变量的名称解释为地址。可以安装与全局变量相同的方式进行读写操作。但是，如果需要向命令指定某个符号是本地符号，请在符号前面添加美元符号($)和感叹号(!)，例如$!var。</p><span id="more"></span><p>Visual Studio和WinDbg提供了使用者可以使用（附加到命令上）的用户接口元素查看和编辑全局变量。可以参考《在Visual Studio查看和编辑内存及寄存器》和《在WinDbg查看和编辑全局变量》两章。</p><p>除此之外，也可以使用如下的方式展示、修改及使用局部变量：</p><ul><li>dv（展示局部变量display local variable）命令展示了全部局部变量的名称和数值。</li><li>!for_each_local扩展使得使用者可以重复运行一条指令，每一个针对一个局部变量。</li></ul><p>然而，在局部变量与全局变量之间还存在着一个主要的不同之处。应用程序运行时，局部变量的含义依赖于程序计数器的位置，因为局部变量的作用于仅仅局限于被定义的函数内部。</p><p>调试器依据局部上下文（local context）环境解释局部变量。默认情况下，该上下文与程序计数器的位置相匹配。但是调试器也可以改变上下文。想获取更多与局部上下文相关的信息可以参考《局部上下文》章节。</p><p>当局部上下文环境改变后，局部窗口（local window）立即更新以反应局部变量的新集合。dv命令也展示了新的变量。所有的这些变量名称通过之前描述的内存指令被正确解释。用户可以读写这些变量。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;与全局变量相同，局部变量也存储于符号文件中。更加一致的是，调试器也将局部变量的名称解释为地址。可以安装与全局变量相同的方式进行读写操作。但是，如果需要向命令指定某个符号是本地符号，请在符号前面添加美元符号($)和感叹号(!)，例如$!var。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="windbg官方文档翻译" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/windbg%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="windbg" scheme="https://bbbccvbvv.github.io/tags/windbg/"/>
    
    <category term="access local variables" scheme="https://bbbccvbvv.github.io/tags/access-local-variables/"/>
    
  </entry>
  
  <entry>
    <title>windbg标准调试技巧-读写内存（3）：访问全局变量</title>
    <link href="https://bbbccvbvv.github.io/2023/08/04/windbg_debug_technique_reading_and_writing_memory_3/"/>
    <id>https://bbbccvbvv.github.io/2023/08/04/windbg_debug_technique_reading_and_writing_memory_3/</id>
    <published>2023-08-04T11:30:00.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>全局变量的名称存储在应用程序编译时创建的符号文件中。调试器将全局变量的名称解释为一个虚拟地址。任何接受地址作为参数的命令都可以接受变量名称作为参数。因此，可以使用在之前的《通过虚拟地址访问内存》章节中描述的全部指令读写全局变量。</p><span id="more"></span><p>除此之外，也可以使用?（计算表达式evaluate expression）指令展示与符号相关的地址。</p><p>Visual Studio和WinDbg提供了使用者可以使用（附加到命令上）的用户接口元素查看和编辑全局变量。可以参考《在Visual Studio查看和编辑内存及寄存器》和《在WinDbg查看和编辑全局变量》两章。</p><p>思考下面的例子。假设用户想要检查一个32位整数类型的全局变量MyCounter，同时假设默认进制是10进制。</p><p>也可以获取变量地址并展示如下：</p><pre><code> 0:000&gt; ? MyCounter Evaluate expression: 1244892 = 0012fedc0:000&gt; dd 0x0012fedc L1 0012fedc  00000052</code></pre><p>第一条命令输出告诉使用者MyCounter的地址是0x0012FEDC。也可以使用d*（展示内存display memory）命令在这个地址上展示一个双字（也可以使用1244892，即该地址的十进制版本，然而，多数c语言程序员更倾向于使用0x0012FEDC）。第二条指令告诉使用者MyCounter的数值是0x52（即十进制下的82）.</p><p>也可以使用如下指令实现上述过程</p><pre><code>0:000&gt; dd MyCounter L1 0012fedc  00000052</code></pre><p>可使用如下指令将MyCounter的数值改为十进制的83.</p><pre><code>0:000&gt; ed MyCounter 83 </code></pre><p>这个示例使用了十进制输入，因为十进制格式对于一个整数来说更加自然。<br>然而，d*命令的输出仍然是以16进制格式展示的。</p><pre><code>0:000&gt; dd MyCounter L1 0012fedc  00000053</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;全局变量的名称存储在应用程序编译时创建的符号文件中。调试器将全局变量的名称解释为一个虚拟地址。任何接受地址作为参数的命令都可以接受变量名称作为参数。因此，可以使用在之前的《通过虚拟地址访问内存》章节中描述的全部指令读写全局变量。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="windbg官方文档翻译" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/windbg%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="windbg" scheme="https://bbbccvbvv.github.io/tags/windbg/"/>
    
    <category term="access global variables" scheme="https://bbbccvbvv.github.io/tags/access-global-variables/"/>
    
  </entry>
  
  <entry>
    <title>windbg标准调试技巧-读写内存（2）：通过物理地址访问内存</title>
    <link href="https://bbbccvbvv.github.io/2023/08/03/windbg_debug_technique_reading_and_writing_memory_2/"/>
    <id>https://bbbccvbvv.github.io/2023/08/03/windbg_debug_technique_reading_and_writing_memory_2/</id>
    <published>2023-08-03T12:30:00.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>为了从物理地址中读取参数，可以使用!db、!dc、!dd、!dp、!du和!dw等扩展命令。</p><p>向物理地址中写入数据，可以使用!eb和!ed扩展命令。</p><p>fp（fill physical memory填充物理内存）指令向物理内存范围内写入了模板值，不停重复，知道内存被完全填充。</p><p>当在内核模式中使用windbg时，可以在windbg的内存窗口中直接进行物理内存的读写操作。</p><p>要在物理内存中搜索一段数据或一系列数据，请使用 !search 扩展命令。</p><p>想要查看更多与物理地址相关的信息，可以查看转换虚拟地址到物理地址这一章节。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为了从物理地址中读取参数，可以使用!db、!dc、!dd、!dp、!du和!dw等扩展命令。&lt;/p&gt;
&lt;p&gt;向物理地址中写入数据，可以使用!eb和!ed扩展命令。&lt;/p&gt;
&lt;p&gt;fp（fill physical memory填充物理内存）指令向物理内存范围内写入了模板值，不</summary>
      
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="windbg官方文档翻译" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/windbg%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="windows" scheme="https://bbbccvbvv.github.io/tags/windows/"/>
    
    <category term="windbg" scheme="https://bbbccvbvv.github.io/tags/windbg/"/>
    
    <category term="standard debugging techniques" scheme="https://bbbccvbvv.github.io/tags/standard-debugging-techniques/"/>
    
    <category term="reading and writng memory" scheme="https://bbbccvbvv.github.io/tags/reading-and-writng-memory/"/>
    
    <category term="physical address" scheme="https://bbbccvbvv.github.io/tags/physical-address/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】OpenSSL环境变量OPENSSL_ia32cap详解</title>
    <link href="https://bbbccvbvv.github.io/2023/07/24/openssl_env_variable_openssl_ia32cap/"/>
    <id>https://bbbccvbvv.github.io/2023/07/24/openssl_env_variable_openssl_ia32cap/</id>
    <published>2023-07-24T03:30:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-名称"><a href="#1-名称" class="headerlink" title="1 名称"></a>1 名称</h1><p>OPENSSL_ia32cap：x86[_64]架构处理器能力向量（processor capabilities vector）</p><span id="more"></span><h1 id="2-概要"><a href="#2-概要" class="headerlink" title="2 概要"></a>2 概要</h1><pre><code>env OPENSSL_ia32cap=... &lt;application&gt;</code></pre><h1 id="3-描述"><a href="#3-描述" class="headerlink" title="3 描述"></a>3 描述</h1><p>OpenSSL支持一系列的x86[_64]指令集扩展。在以EAX&#x3D;1作为输入值运行CPUID指令之后，这些扩展由处理器返回的位于EDX:ECX寄存器对能力向量的各个位表示（详情可参考Intel Application Note #241618）。这些向量在工具包初始化时被复制到内存中，被用来选择不同的代码路径以在一系列处理器之间提供最佳性能。在撰写本文时，以下位很重要：</p><ul><li>第4位：表示时间戳计数器（Time-Stamp Counter）的存在；</li><li>第19位：表示CLFLUSH（flush cache line缓存线清除操作码指令）指令可用；</li><li>第20位：由Intel保留，用于在RC4代码路径中进行选择；</li><li>第23位：表示MMX（Multi Media eXtension，多媒体扩展指令集）支持；</li><li>第24位：FXSR（FidelityFX™ Super Resolution）位，表示支持XMM寄存器；</li><li>第25位：表示支持SSE（streaming simd extensions流式单指令多数据扩展）；</li><li>第26位：表示支持SSE2；</li><li>第28位：支持超线程（Hyperthreading），用于区分具有共享缓存的核心；</li><li>第30位：由 Intel 保留，特指 Intel CPU；</li><li>第33位：表明可以使用PCLMULQDQ（Carry-Less Multiplication Quadword，是对两个GF(2^128)域上的多项式相乘）指令；</li><li>第41位：表明支持SSSE3和补充SSE3；</li><li>第43位：表明支持AMD XOP（非AMD cpu上强制设置为0）；</li><li>第54位：表明支持MOVBE（复制源操作数的数据，交换字节后，移动数据）指令；</li><li>第57位：表明支持AES-NI指令集（高级加密标准指令集，或称英特尔高级加密标准新指令，目的是改进应用程序使用高级加密标准（AES）执行加密和解密的速度）扩展；</li><li>第58位：XSAVE位，缺少该位与MOVBE结合用于识别Atom Silvermont 核心；</li><li>第59位：OSXSAVE位，表明支持YMM寄存器；</li><li>第60位：表明支持AVX（X86指令集的SSE延伸架构）扩展；</li><li>第62位：表明支持RDRAND（用于从芯片上的硬件随机数生成器中获取随机数）指令；</li></ul><p>例如，在32位应用程序上下文环境中将第26位清0，则在运行时会禁用crypto库里的高性能SSE2代码，将第24位清0将会禁用SSE2代码操作128位MMX寄存器组。如果目标OpenSSL应用程序运行在SSE2兼容的cpu上，但是操作系统却没有启用XMM寄存器，则必须执行后者将第24位清0。一般情况下，功能向量的地址通过OPENSSL_ia32cap_loc()函数暴露给应用程序，但并非全部情况下都是如此。现在唯一可以影响功能检测的方法就是在目标程序启动前，设置OPENSSL_ia32cap环境变量。例如，在Intel P4处理器中，设置env OPENSSL_ia32cap&#x3D;0x16980010 apps&#x2F;openssl，或者设置env OPENSSL_ia32cap&#x3D;~0x1000000 apps&#x2F;openssl都可以取得预期的效果。也可以重新配置no-sse2选项，并重新编译工具包。</p><p>不太直观的就是将第28位清零，或者在环境变量中设置为~0x10000000。事实是，它不是从CPUID输出逐字复制的，而是经过调整以反映数据缓存是否实际上在逻辑核心之间共享。这反过来又会影响是否应用针对缓存定时攻击的昂贵对策的决定，尤其是在AES汇编器模块中。</p><p>通过以EAX&#x3D;7和ECX&#x3D;0作为输入值获取CPUID返回的EBX数值，功能向量可以进一步扩展。下面的位很重要：</p><ul><li>第64+3位：表明支持BMI1（Bit Manipulation Instructions位操作指令）指令，例如ANDN（第一源操作数取反后与第二源操作数按位与操作，结果保存在目标操作数中）；</li><li>第64+5位：表明支持AVX2指令；</li><li>第64+8位：表明支持BMI2指令，如MULX和RORX；</li><li>第64+16位：表明支持AVX512F扩展；</li><li>第64+17位：表明支持AVX512DQ扩展；</li><li>第64+18位：表明支持RDSEED指令；</li><li>第64+19位：表明支持ADCX和ADOX指令；</li><li>第64+21位：表明支持VPMADD52[LH]UQ指令，又名AVX512IFMA扩展；</li><li>第64+29位：表明支持SHA扩展；</li><li>第64+30位：表明支持AVX512BW扩展；</li><li>第64+31位：表明支持AVX512VL扩展；</li><li>第64+41位：表明支持VAES扩展；</li><li>第64+42位：表明支持VPCLMULQDQ扩展；</li></ul><p>要控制此扩展功能，请在设置OPENSSL_ia32cap环境变量时使用:作为分隔符。例如，分配:~0x20将禁用AVX2代码路径，而:0-禁用所有后AVX扩展。</p><h1 id="4-返回值"><a href="#4-返回值" class="headerlink" title="4 返回值"></a>4 返回值</h1><p>不可用</p><p>原文地址：<a href="https://www.openssl.org/docs/man3.1/man3/OPENSSL_ia32cap.html" title="OPENSSL_ia32cap">https://www.openssl.org/docs/man3.1/man3/OPENSSL_ia32cap.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-名称&quot;&gt;&lt;a href=&quot;#1-名称&quot; class=&quot;headerlink&quot; title=&quot;1 名称&quot;&gt;&lt;/a&gt;1 名称&lt;/h1&gt;&lt;p&gt;OPENSSL_ia32cap：x86[_64]架构处理器能力向量（processor capabilities vector）&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="OpenSSL" scheme="https://bbbccvbvv.github.io/tags/OpenSSL/"/>
    
    <category term="OPENSSL_ia32cap" scheme="https://bbbccvbvv.github.io/tags/OPENSSL-ia32cap/"/>
    
  </entry>
  
  <entry>
    <title>windbg标准调试技巧-读写内存（1）：通过虚拟地址访问内存</title>
    <link href="https://bbbccvbvv.github.io/2023/07/19/windbg_debug_technique_reading_and_writing_memory_1/"/>
    <id>https://bbbccvbvv.github.io/2023/07/19/windbg_debug_technique_reading_and_writing_memory_1/</id>
    <published>2023-07-19T11:30:00.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>在调试过程中可以通过使用多个指令来访问内存或内存区域。visual studio和windbg提供命令行命令时，也提供了用户图形界面，用户可以用图形界面来查看和编辑内存。详情可以参考windbg帮助文档中的在visual studio中查看和编辑内存和寄存器，以及在windbg中查看和编辑内存两个章节。</p><span id="more"></span><p>以下命令可以读取与写入多种格式的内存。这些屙屎包含了16字节、字格式（单字、双字、四字、八字格式）、整数格式（short、long、quad、unsigned格式）、浮点数格式（10字节、16字节、32字节、64字节实数格式）以及ascii字符格式。</p><ul><li>d*（展示内存display memory）指令会展示特定内存或内驱区域的内容。</li><li>e*（输入数值enter values）指令向特定的内存地址写入数值。</li></ul><p>也可以使用如下指令处理更加特定的数据类型：</p><ul><li>dt（展示类型display type）指令会检索多种数据类型并展示被当前正在调试的应用程序锁创建出来的数据结构。改名了用途广泛并拥有多种变体及可选配置项。</li><li>ds（展示字符串display string）指令展示了STRING、ANSI_STRING和UNICODE_STRING数据结构。</li><li>dl（展示链表display linked list）指令追踪并展示链表。</li><li>d*s（展示字格式和符号display words and symbols）指令检索可能包含符号信息的双字或四字结构，之后展示对应的数据及符号信息。</li><li>!address扩展指令展示位于特定地址的内存属性信息。</li></ul><p>可以使用如下指令来进行内存范围操作：</p><ul><li>m（移动内存move memory）指令将一个内存范围的内容移到另外一个中。</li><li>f（填充内存fill mempry）指令向内存范围中写入指定的样式，后续重复该操作直到内存范围被全部填满。</li><li>c（比较内存compare memory）指令比较两个内存范围的内容；</li><li>s（搜索内存search memory）指令在一个内存范围内搜索指定格式的内容、或者搜索内存范围内的任一ascii或unicode编码；</li><li>.holdmem（保存并比较内存hold and compare memory）指令将一个内存范围与另外一个进行比较。</li></ul><p>在大多数场景下，这些命令以当前的进制解释其参数。因此，如果当前的进制不是16，那么需要在16进制地址前增加0x表示其为16进制。然而，命令的展示输出通常是16进制的，不按照当前进制进行展示。内存窗口以10进制展示了整数与实数以16进制展示其他类型的参数。</p><p>可使用n（设置数字基数set number base）指令改变默认的进制。为快速将数字由一个进制转换为另外一个进制，可使用？（计算表达式evaluate expression）指令或者.format（展示数字格式show number formats）指令。</p><p>当进行用户模式调试时，虚拟地址的含义是当前进程决定的。当你进行内核模式调试时，虚拟地址的含义可以被调试器控制。更多内容，可参考进程上下文（process context）章节。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在调试过程中可以通过使用多个指令来访问内存或内存区域。visual studio和windbg提供命令行命令时，也提供了用户图形界面，用户可以用图形界面来查看和编辑内存。详情可以参考windbg帮助文档中的在visual studio中查看和编辑内存和寄存器，以及在windbg中查看和编辑内存两个章节。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="windbg官方文档翻译" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/windbg%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="windows" scheme="https://bbbccvbvv.github.io/tags/windows/"/>
    
    <category term="windbg" scheme="https://bbbccvbvv.github.io/tags/windbg/"/>
    
    <category term="standard debugging techniques" scheme="https://bbbccvbvv.github.io/tags/standard-debugging-techniques/"/>
    
    <category term="reading and writng memory" scheme="https://bbbccvbvv.github.io/tags/reading-and-writng-memory/"/>
    
    <category term="virtual address" scheme="https://bbbccvbvv.github.io/tags/virtual-address/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】libvirt虚拟机xml配置文件格式（9）CPU model and topology</title>
    <link href="https://bbbccvbvv.github.io/2022/11/15/domain_xml_format9_cpu_model_topology/"/>
    <id>https://bbbccvbvv.github.io/2022/11/15/domain_xml_format9_cpu_model_topology/</id>
    <published>2022-11-15T10:10:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>原文网址：<a href="https://libvirt.org/formatdomain.html#id8" title="Domain XML format">https://libvirt.org/formatdomain.html#id8</a></p><span id="more"></span><h1 id="NUMA-Node-Tuning"><a href="#NUMA-Node-Tuning" class="headerlink" title="NUMA Node Tuning"></a>NUMA Node Tuning</h1><pre><code>&lt;domain&gt;  ...  &lt;numatune&gt;    &lt;memory mode=&quot;strict&quot; nodeset=&quot;1-4,^3&quot;/&gt;    &lt;memnode cellid=&quot;0&quot; mode=&quot;strict&quot; nodeset=&quot;1&quot;/&gt;    &lt;memnode cellid=&quot;2&quot; mode=&quot;preferred&quot; nodeset=&quot;2&quot;/&gt;  &lt;/numatune&gt;  ...&lt;/domain&gt;</code></pre><h2 id="numatune"><a href="#numatune" class="headerlink" title="numatune"></a>numatune</h2><p>可选元素项numatune提供了如何通过控制虚拟机进程的NUMA策略对NUMA主机的性能进行调度。注意，仅支持QEMU。自0.9.3起。</p><h2 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h2><p>可选元素项memory指明了如何对NUMA主机的虚拟机进程进行内存分配。其包含多个可选属性项。属性项mode的可用值包含interleave、strict、preferred和restrictive，默认设置为strict。restrictive指明使用系统默认策略，仅有cgroups被用来限制内存节点，在memnode元素中将mode设置为restrictive。属性项nodeset指明了numa节点，其与vcpu元素项的cpuset属性项使用相同的语法。属性项placement（自0.9.12起）可被用来表明虚拟机进程的内存放置模式，其值可以为static或auto，是vcpu的placement的默认值，如果指定了nodeset则默认值为static。auto表明虚拟机进程只会从查询numad返回的咨询节点中集中分配内存，属性nodeset的值在指定auto的情况下将会被忽略。如果vcpu的placement设置为auto，且numatune未指定，则numatune的placement设置为auto，mode设置为strict。自0.9.3起。参阅 virDomainSetNumaParameters获取该元素的更多信息。</p><h2 id="memnode"><a href="#memnode" class="headerlink" title="memnode"></a>memnode</h2><p>可选元素项memnode可以为每个虚拟机的numa节点指定内存分配策略。对于没有memnode元素的哪些节点，memory元素的默认值将会被使用。属性项cellid寻址应用设置的虚拟机NUMA节点。属性项mode和nodeset与memory元素中的对应值具有相同的含义和语法。设置与自动placement不兼容。qemu自1.2.7起。</p><h1 id="Block-I-x2F-O-Tuning"><a href="#Block-I-x2F-O-Tuning" class="headerlink" title="Block I&#x2F;O Tuning"></a>Block I&#x2F;O Tuning</h1><pre><code>&lt;domain&gt;  ...  &lt;blkiotune&gt;    &lt;weight&gt;800&lt;/weight&gt;    &lt;device&gt;      &lt;path&gt;/dev/sda&lt;/path&gt;      &lt;weight&gt;1000&lt;/weight&gt;    &lt;/device&gt;    &lt;device&gt;      &lt;path&gt;/dev/sdb&lt;/path&gt;      &lt;weight&gt;500&lt;/weight&gt;      &lt;read_bytes_sec&gt;10000&lt;/read_bytes_sec&gt;      &lt;write_bytes_sec&gt;10000&lt;/write_bytes_sec&gt;      &lt;read_iops_sec&gt;20000&lt;/read_iops_sec&gt;      &lt;write_iops_sec&gt;20000&lt;/write_iops_sec&gt;    &lt;/device&gt;  &lt;/blkiotune&gt;  ...&lt;/domain&gt;</code></pre><h2 id="blkiotune"><a href="#blkiotune" class="headerlink" title="blkiotune"></a>blkiotune</h2><p>可选元素项blkiotune为虚拟机提供了调节Blkio cgroup可调参数的能力。如果忽略该设置项，则其默认由操作系统提供。自0.8.8起。</p><h2 id="weight"><a href="#weight" class="headerlink" title="weight"></a>weight</h2><p>可选元素项weight是虚拟机的全部i&#x2F;o负载。该值的范围是100-1000.在2.6.39内核后，该值的范围是10-1000.</p><h2 id="device"><a href="#device" class="headerlink" title="device"></a>device</h2><p>虚拟机可能又有多个device元素项，以便深入调节虚拟机正在使用的每一个主机块设备的权重。注意多个磁盘（可参阅Hard drives, floppy disks, CDROMs章节）可能共享同一个主机块设备，如果他们被相同的主机文件系统中的文件备份，这也是为什么使用全局作用域的调节参数而非相关的每一个虚拟机磁盘设备的原因（与磁盘定义中的iotune元素项相反（可参阅Hard drives, floppy disks, CDROMs章节），而iotune元素项适用于单个独立的磁盘）。每一个device元素项有两个强制的子元素项，path描述了设备的绝对路径，而weight给出了设备的相对权重，权重范围是100-1000.在2.6.39版本内核之后，该值的范围变为10-1000.自0.9.8起。除此之外，也可使用如下的可选子元素项：</p><h3 id="read-bytes-sec"><a href="#read-bytes-sec" class="headerlink" title="read_bytes_sec"></a>read_bytes_sec</h3><p>以字节为单位的每秒可读吞吐量。自1.2.2起。</p><h3 id="write-bytes-sec"><a href="#write-bytes-sec" class="headerlink" title="write_bytes_sec"></a>write_bytes_sec</h3><p>以字节为单位的每秒可写吞吐量。自1.2.2起。</p><h3 id="read-iops-sec"><a href="#read-iops-sec" class="headerlink" title="read_iops_sec"></a>read_iops_sec</h3><p>每秒i&#x2F;o读操作限制。自1.2.2起。</p><h3 id="write-iops-sec"><a href="#write-iops-sec" class="headerlink" title="write_iops_sec"></a>write_iops_sec</h3><p>每秒i&#x2F;o写操作限制。自1.2.2起。</p><h1 id="Resource-partitioning"><a href="#Resource-partitioning" class="headerlink" title="Resource partitioning"></a>Resource partitioning</h1><p>虚拟机管理程序可能允许将虚拟机放入资源分区，也可能嵌套所述分区。resource元素将与资源分区相关的配置项组织在一起。当前其支持partition子元素项，该子元素项的内容定义了放置虚拟机的资源分区的绝对路径。如果没有列出任何分区，虚拟机将会被放到默认分区中。应用程序或管理员有责任确保分区在虚拟机启动之前就已存在。只有默认分区（适用于特定虚拟机管理程序）可以默认假定已经存在。</p><pre><code>...&lt;resource&gt;  &lt;partition&gt;/virtualmachines/production&lt;/partition&gt;&lt;/resource&gt;...</code></pre><p>资源分区当前在qemu和lxc中受到支持，在所有已安装的控制器中将分区路径映射到cgroups目录。自1.0.5起。</p><h1 id="Fibre-Channel-VMID"><a href="#Fibre-Channel-VMID" class="headerlink" title="Fibre Channel VMID"></a>Fibre Channel VMID</h1><p>FC SAN可以提供多个依赖于VMID的QoS等级和访问控制功能。它还可以收集每个虚拟机的遥测数据，这些数据可用于增强虚拟机的IO性能。可以通过fibrechannel元素项的appid属性项进行配置。该属性项包含了简单的字符串（最大128字节），内核可使用该属性项创建VMID。</p><pre><code>...&lt;resource&gt;  &lt;fibrechannel appid=&#39;userProvidedID&#39;/&gt;&lt;/resource&gt;...</code></pre><p>使用该特征项要求支持光纤通道的硬件，内核编译时配置有 CONFIG_BLK_CGROUP_FC_APPID选项，且nvme_fc内核模块已加载。自7.7.0起。</p><p>本章节描述了用来代表作用域的xml文件格式，根据运行的作用于种类的格式变化，有一些可选配置项用来加载文件。对于特定虚拟机的细节可以查看<br><a href="https://libvirt.org/drivers.html">相关文件</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文网址：&lt;a href=&quot;https://libvirt.org/formatdomain.html#id8&quot; title=&quot;Domain XML format&quot;&gt;https://libvirt.org/formatdomain.html#id8&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="虚拟化" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="kvm" scheme="https://bbbccvbvv.github.io/tags/kvm/"/>
    
    <category term="libvirt" scheme="https://bbbccvbvv.github.io/tags/libvirt/"/>
    
    <category term="虚拟机xml配置文件" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BAxml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
    <category term="翻译" scheme="https://bbbccvbvv.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="CPU model and topology" scheme="https://bbbccvbvv.github.io/tags/CPU-model-and-topology/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】libvirt虚拟机xml配置文件格式（8）NUMA Node Tuning、Block I/O Tuning、Resource partitioning、Fibre Channel VMID</title>
    <link href="https://bbbccvbvv.github.io/2022/11/14/domain_xml_format8_block_io_tuning_resource_partitioning_fibre_channel_vmid/"/>
    <id>https://bbbccvbvv.github.io/2022/11/14/domain_xml_format8_block_io_tuning_resource_partitioning_fibre_channel_vmid/</id>
    <published>2022-11-14T08:10:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>原文网址：<a href="https://libvirt.org/formatdomain.html#id8" title="Domain XML format">https://libvirt.org/formatdomain.html#id8</a></p><span id="more"></span><h1 id="NUMA-Node-Tuning"><a href="#NUMA-Node-Tuning" class="headerlink" title="NUMA Node Tuning"></a>NUMA Node Tuning</h1><pre><code>&lt;domain&gt;  ...  &lt;numatune&gt;    &lt;memory mode=&quot;strict&quot; nodeset=&quot;1-4,^3&quot;/&gt;    &lt;memnode cellid=&quot;0&quot; mode=&quot;strict&quot; nodeset=&quot;1&quot;/&gt;    &lt;memnode cellid=&quot;2&quot; mode=&quot;preferred&quot; nodeset=&quot;2&quot;/&gt;  &lt;/numatune&gt;  ...&lt;/domain&gt;</code></pre><h2 id="numatune"><a href="#numatune" class="headerlink" title="numatune"></a>numatune</h2><p>可选元素项numatune提供了如何通过控制虚拟机进程的NUMA策略对NUMA主机的性能进行调度。注意，仅支持QEMU。自0.9.3起。</p><h2 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h2><p>可选元素项memory指明了如何对NUMA主机的虚拟机进程进行内存分配。其包含多个可选属性项。属性项mode的可用值包含interleave、strict、preferred和restrictive，默认设置为strict。restrictive指明使用系统默认策略，仅有cgroups被用来限制内存节点，在memnode元素中将mode设置为restrictive。属性项nodeset指明了numa节点，其与vcpu元素项的cpuset属性项使用相同的语法。属性项placement（自0.9.12起）可被用来表明虚拟机进程的内存放置模式，其值可以为static或auto，是vcpu的placement的默认值，如果指定了nodeset则默认值为static。auto表明虚拟机进程只会从查询numad返回的咨询节点中集中分配内存，属性nodeset的值在指定auto的情况下将会被忽略。如果vcpu的placement设置为auto，且numatune未指定，则numatune的placement设置为auto，mode设置为strict。自0.9.3起。参阅 virDomainSetNumaParameters获取该元素的更多信息。</p><h2 id="memnode"><a href="#memnode" class="headerlink" title="memnode"></a>memnode</h2><p>可选元素项memnode可以为每个虚拟机的numa节点指定内存分配策略。对于没有memnode元素的哪些节点，memory元素的默认值将会被使用。属性项cellid寻址应用设置的虚拟机NUMA节点。属性项mode和nodeset与memory元素中的对应值具有相同的含义和语法。设置与自动placement不兼容。qemu自1.2.7起。</p><h1 id="Block-I-x2F-O-Tuning"><a href="#Block-I-x2F-O-Tuning" class="headerlink" title="Block I&#x2F;O Tuning"></a>Block I&#x2F;O Tuning</h1><pre><code>&lt;domain&gt;  ...  &lt;blkiotune&gt;    &lt;weight&gt;800&lt;/weight&gt;    &lt;device&gt;      &lt;path&gt;/dev/sda&lt;/path&gt;      &lt;weight&gt;1000&lt;/weight&gt;    &lt;/device&gt;    &lt;device&gt;      &lt;path&gt;/dev/sdb&lt;/path&gt;      &lt;weight&gt;500&lt;/weight&gt;      &lt;read_bytes_sec&gt;10000&lt;/read_bytes_sec&gt;      &lt;write_bytes_sec&gt;10000&lt;/write_bytes_sec&gt;      &lt;read_iops_sec&gt;20000&lt;/read_iops_sec&gt;      &lt;write_iops_sec&gt;20000&lt;/write_iops_sec&gt;    &lt;/device&gt;  &lt;/blkiotune&gt;  ...&lt;/domain&gt;</code></pre><h2 id="blkiotune"><a href="#blkiotune" class="headerlink" title="blkiotune"></a>blkiotune</h2><p>可选元素项blkiotune为虚拟机提供了调节Blkio cgroup可调参数的能力。如果忽略该设置项，则其默认由操作系统提供。自0.8.8起。</p><h2 id="weight"><a href="#weight" class="headerlink" title="weight"></a>weight</h2><p>可选元素项weight是虚拟机的全部i&#x2F;o负载。该值的范围是100-1000.在2.6.39内核后，该值的范围是10-1000.</p><h2 id="device"><a href="#device" class="headerlink" title="device"></a>device</h2><p>虚拟机可能又有多个device元素项，以便深入调节虚拟机正在使用的每一个主机块设备的权重。注意多个磁盘（可参阅Hard drives, floppy disks, CDROMs章节）可能共享同一个主机块设备，如果他们被相同的主机文件系统中的文件备份，这也是为什么使用全局作用域的调节参数而非相关的每一个虚拟机磁盘设备的原因（与磁盘定义中的iotune元素项相反（可参阅Hard drives, floppy disks, CDROMs章节），而iotune元素项适用于单个独立的磁盘）。每一个device元素项有两个强制的子元素项，path描述了设备的绝对路径，而weight给出了设备的相对权重，权重范围是100-1000.在2.6.39版本内核之后，该值的范围变为10-1000.自0.9.8起。除此之外，也可使用如下的可选子元素项：</p><h3 id="read-bytes-sec"><a href="#read-bytes-sec" class="headerlink" title="read_bytes_sec"></a>read_bytes_sec</h3><p>以字节为单位的每秒可读吞吐量。自1.2.2起。</p><h3 id="write-bytes-sec"><a href="#write-bytes-sec" class="headerlink" title="write_bytes_sec"></a>write_bytes_sec</h3><p>以字节为单位的每秒可写吞吐量。自1.2.2起。</p><h3 id="read-iops-sec"><a href="#read-iops-sec" class="headerlink" title="read_iops_sec"></a>read_iops_sec</h3><p>每秒i&#x2F;o读操作限制。自1.2.2起。</p><h3 id="write-iops-sec"><a href="#write-iops-sec" class="headerlink" title="write_iops_sec"></a>write_iops_sec</h3><p>每秒i&#x2F;o写操作限制。自1.2.2起。</p><h1 id="Resource-partitioning"><a href="#Resource-partitioning" class="headerlink" title="Resource partitioning"></a>Resource partitioning</h1><p>虚拟机管理程序可能允许将虚拟机放入资源分区，也可能嵌套所述分区。resource元素将与资源分区相关的配置项组织在一起。当前其支持partition子元素项，该子元素项的内容定义了放置虚拟机的资源分区的绝对路径。如果没有列出任何分区，虚拟机将会被放到默认分区中。应用程序或管理员有责任确保分区在虚拟机启动之前就已存在。只有默认分区（适用于特定虚拟机管理程序）可以默认假定已经存在。</p><pre><code>...&lt;resource&gt;  &lt;partition&gt;/virtualmachines/production&lt;/partition&gt;&lt;/resource&gt;...</code></pre><p>资源分区当前在qemu和lxc中受到支持，在所有已安装的控制器中将分区路径映射到cgroups目录。自1.0.5起。</p><h1 id="Fibre-Channel-VMID"><a href="#Fibre-Channel-VMID" class="headerlink" title="Fibre Channel VMID"></a>Fibre Channel VMID</h1><p>FC SAN可以提供多个依赖于VMID的QoS等级和访问控制功能。它还可以收集每个虚拟机的遥测数据，这些数据可用于增强虚拟机的IO性能。可以通过fibrechannel元素项的appid属性项进行配置。该属性项包含了简单的字符串（最大128字节），内核可使用该属性项创建VMID。</p><pre><code>...&lt;resource&gt;  &lt;fibrechannel appid=&#39;userProvidedID&#39;/&gt;&lt;/resource&gt;...</code></pre><p>使用该特征项要求支持光纤通道的硬件，内核编译时配置有 CONFIG_BLK_CGROUP_FC_APPID选项，且nvme_fc内核模块已加载。自7.7.0起。</p><p>本章节描述了用来代表作用域的xml文件格式，根据运行的作用于种类的格式变化，有一些可选配置项用来加载文件。对于特定虚拟机的细节可以查看<br><a href="https://libvirt.org/drivers.html">相关文件</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文网址：&lt;a href=&quot;https://libvirt.org/formatdomain.html#id8&quot; title=&quot;Domain XML format&quot;&gt;https://libvirt.org/formatdomain.html#id8&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="虚拟化" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="kvm" scheme="https://bbbccvbvv.github.io/tags/kvm/"/>
    
    <category term="libvirt" scheme="https://bbbccvbvv.github.io/tags/libvirt/"/>
    
    <category term="虚拟机xml配置文件" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BAxml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
    <category term="翻译" scheme="https://bbbccvbvv.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="NUMA Node Tuning" scheme="https://bbbccvbvv.github.io/tags/NUMA-Node-Tuning/"/>
    
    <category term="Block I/O Tuning" scheme="https://bbbccvbvv.github.io/tags/Block-I-O-Tuning/"/>
    
    <category term="Resource partitioning" scheme="https://bbbccvbvv.github.io/tags/Resource-partitioning/"/>
    
    <category term="Fibre Channel VMID" scheme="https://bbbccvbvv.github.io/tags/Fibre-Channel-VMID/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】libvirt虚拟机xml配置文件格式（7）Memory Allocation、Memory Backing和Memory Tuning</title>
    <link href="https://bbbccvbvv.github.io/2022/11/10/domain_xml_format7_memory_allocation/"/>
    <id>https://bbbccvbvv.github.io/2022/11/10/domain_xml_format7_memory_allocation/</id>
    <published>2022-11-10T03:56:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>原文网址：<a href="https://libvirt.org/formatdomain.html#id8" title="Domain XML format">https://libvirt.org/formatdomain.html#id8</a></p><span id="more"></span><h1 id="Memory-Allocation"><a href="#Memory-Allocation" class="headerlink" title="Memory Allocation"></a>Memory Allocation</h1><pre><code>&lt;domain&gt;  ...  &lt;maxMemory slots=&#39;16&#39; unit=&#39;KiB&#39;&gt;1524288&lt;/maxMemory&gt;  &lt;memory unit=&#39;KiB&#39;&gt;524288&lt;/memory&gt;  &lt;currentMemory unit=&#39;KiB&#39;&gt;524288&lt;/currentMemory&gt;  ...&lt;/domain&gt;</code></pre><h2 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h2><p>boot时虚拟机的最大分配内存。内存分配包含了在启动时或在之后热插拔的全部可能的额外内存设备。该值的单位由可选属性项unit设置，默认以KiB为单位（kibibytes，2^10或1024字节块）。有效的单位还有b或byte代表字节，KB代表kilobytes（10^3或1000字节），k或KiB代表kibibytes（1024字节）。MB代表megabytes（10^6或1000000字节），M或MiB代表 mebibytes（2^20或1048576字节），GB代表gigabytes（10^9或1000000000字节），T或TiB代表tebibytes（2^40或1099511627776字节）.然而，该值会被libvirt四舍五入到最近的kibibytes，也可能进一步四舍五入到虚拟机管理程序支持的粒度。一些虚拟机管理程序也会强制设置一个最小值，例如4000KiB。这种情况下，虚拟机配置的numa的memory元素会被忽略。如果发生crash，可选属性项dumpCore可用来控制是否将虚拟机内存包含在生成的coredump文件中（属性值为on和off）。unit自0.9.11起，dumpCore自0.10.2起（仅限于qemu）。</p><h2 id="maxMemory"><a href="#maxMemory" class="headerlink" title="maxMemory"></a>maxMemory</h2><p>运行时虚拟机的最大内存分配。被numa的memory元素或者numa cell大小配置的初始内存可通过内存热插拔方式增长到该元素限制的最大内存大小。unit属性项与memory中的同名属性项表现完全一致。slots属性项指定了将内存添加到虚拟机时可用slot的数量。数量上下限与虚拟机管理程序有关。注意由于内存对齐的限制，通过内存条热插拔所获得的完整内存大小可能无法达到该元素的设置值。自1.2.14起在qemu中支持。</p><h2 id="currentMemory"><a href="#currentMemory" class="headerlink" title="currentMemory"></a>currentMemory</h2><p>虚拟机真实分配的内存。该值小于最大分配数值，允许动态扩充虚拟机内存。如果未设置该项，则默认与memory元素具有同样的数值设置。unit属性项与memory中的unit作用一致。</p><h1 id="Memory-Backing"><a href="#Memory-Backing" class="headerlink" title="Memory Backing"></a>Memory Backing</h1><pre><code>&lt;domain&gt;  ...  &lt;memoryBacking&gt;    &lt;hugepages&gt;      &lt;page size=&quot;1&quot; unit=&quot;G&quot; nodeset=&quot;0-3,5&quot;/&gt;      &lt;page size=&quot;2&quot; unit=&quot;M&quot; nodeset=&quot;4&quot;/&gt;    &lt;/hugepages&gt;    &lt;nosharepages/&gt;    &lt;locked/&gt;    &lt;source type=&quot;file|anonymous|memfd&quot;/&gt;    &lt;access mode=&quot;shared|private&quot;/&gt;    &lt;allocation mode=&quot;immediate|ondemand&quot; threads=&#39;8&#39;/&gt;    &lt;discard/&gt;  &lt;/memoryBacking&gt;  ...&lt;/domain&gt;</code></pre><p>可选元素项memoryBacking包含多个影响主机内存页备份虚拟内存的元素项。</p><h2 id="hugepages"><a href="#hugepages" class="headerlink" title="hugepages"></a>hugepages</h2><p>该元素项告知虚拟机管理程序虚拟机使用大页而非通常的主机内存页大小进行内存分配。自1.2.5起。可以为每个numa节点详尽的设置大页。page元素项被引入。其包含一个强制属性项size用于指定具体使用哪些大页（在支持不同大小大页的系统中尤其有用）。size属性项的默认单位是kilobytes（1024的整数倍）。如果想要使用不同的单位，可使用可选属性项unit。对于numa系统，可选的nodeset属性可能会派上用场，因为它将给定虚拟机的NUMA节点与某些大页大小相关联。在某些例子中，除了4#节点之外的其他numa节点都使用了1G大小的大页。相关语法可以查看NUMA Node Tuning章节。</p><h2 id="nosharepages"><a href="#nosharepages" class="headerlink" title="nosharepages"></a>nosharepages</h2><p>告知虚拟机管理程序虚拟机禁用共享内存页（内存合并，ksm）。自1.0.6起。</p><h2 id="locked"><a href="#locked" class="headerlink" title="locked"></a>locked</h2><p>当虚拟机管理程序支持并设置相关数值后，虚拟机内存页将会在主机内存中锁定，而且主机也不会将其换出，这在某些工况下如实时场景中是十分必要的。对于QEMU&#x2F;KVM虚拟机，qemu进程自身使用的内存也会被锁定；与虚拟机内存不同，libvirt无法提前获取相应内存的数量，所以必须移除对于锁定内存的限制。因此，启用该可选元素项存在潜在的安全风险；当主机内存耗尽时主机无法从虚拟机回复内存，这就意味着大量的虚拟机将会造成大量内存被锁定，主机上会遭受到拒绝服务攻击。因为该原因，除非确实需要否则不建议使用该元素项；即便如此，强烈推荐为特定环境的内存分配设置 hard_limit属性项（参阅Memory Tuning章节），这可以有效的缓解上述描述的风险的发生。自1.0.6起。</p><h2 id="source"><a href="#source" class="headerlink" title="source"></a>source</h2><p>使用type属性项，可提供“file”以利用文件内存备份或保持默认的”anonymous”。自4.10.0起，也可选择memfd备份。（仅限于QEMU&#x2F;KVM）</p><h2 id="access"><a href="#access" class="headerlink" title="access"></a>access</h2><p>使用mode属性项，指明内存是shared还是private。该元素会被每个numa节点的memAccess元素覆盖。</p><h2 id="allocation"><a href="#allocation" class="headerlink" title="allocation"></a>allocation</h2><p>使用可选属性项mode，通过提供”immediate”或”ondemand”参数指明何时进行内存分配。自8.2.0起。也可以通过threads属性设置虚拟机管理程序用来进行内存分配的线程数量。</p><h2 id="discard"><a href="#discard" class="headerlink" title="discard"></a>discard</h2><p>当虚拟机管理程序支持并设置该元素时，在虚拟机关机之前（或当DIMM模块被拔出时）内存内容被丢弃。注意这仅仅只是一个优化项，并不保证在所有场景下都会起作用（例如虚拟机管理程序crash时）。自4.4.0起（仅限于QEMU&#x2F;KVM）。</p><h1 id="Memory-Tuning"><a href="#Memory-Tuning" class="headerlink" title="Memory Tuning"></a>Memory Tuning</h1><pre><code>&lt;domain&gt;  ...  &lt;memtune&gt;    &lt;hard_limit unit=&#39;G&#39;&gt;1&lt;/hard_limit&gt;    &lt;soft_limit unit=&#39;M&#39;&gt;128&lt;/soft_limit&gt;    &lt;swap_hard_limit unit=&#39;G&#39;&gt;2&lt;/swap_hard_limit&gt;    &lt;min_guarantee unit=&#39;bytes&#39;&gt;67108864&lt;/min_guarantee&gt;  &lt;/memtune&gt;  ...&lt;/domain&gt;</code></pre><h2 id="memtune"><a href="#memtune" class="headerlink" title="memtune"></a>memtune</h2><p>可选元素项memtune提供与虚拟机内存调度参数相关的细节描述。如果忽略该项设置，则默认由操作系统提供默认值。对于QEMU&#x2F;KVM，应用于qemu进程的参数被看做一个整体。因此，对其进行计数时，需要加上虚拟机ram、虚拟机显卡ram和qemu自身的一些内存。最后一点很难确定具体数值，因此需要猜想与尝试。对于每个可调参数，可以使用与memory相同的值来指定输入时数字所使用的单位。为了向后兼容，输出始终以KiB为单位。unit自0.9.11起。全部*_limit参数的可能值在0到VIR_DOMAIN_MEMORY_PARAM_UNLIMITED的范围内。</p><h2 id="hard-limit"><a href="#hard-limit" class="headerlink" title="hard_limit"></a>hard_limit</h2><p>可选元素项hard_limit是虚拟机可使用的最大内存。该值的单位是kibibytes（1024字节的块）。qemu和kvm的使用者清冽建议不要设置相关限制项，因为如果虚拟机运行过少则虚拟机可能被内核关闭，决定进程运行所需的内存是一个无法决定的问题；也就是说，如果因工况需要已在 Memory Backing中设置了locked属性，您必须考虑部署的具体细节，并确定一个足够大的hard_limit值，以支持您的虚拟机的内存需求，但是该值足够小也可以保护主机以避免虚拟机锁定全部的内存。</p><h2 id="soft-limit"><a href="#soft-limit" class="headerlink" title="soft_limit"></a>soft_limit</h2><p>可选元素项soft_limit就是内存争用期间强制设置的内存限制。该值的单位是kibibytes（1024字节块）。</p><h2 id="swap-hard-limit"><a href="#swap-hard-limit" class="headerlink" title="swap_hard_limit"></a>swap_hard_limit</h2><p>可选元素项swap_hard_limit就是加上交互内存swap后虚拟机可食用的最大内存。该值的单位是kibibytes（1024字节块）。该值应大于hard_limit的设置值。</p><h2 id="min-guarantee"><a href="#min-guarantee" class="headerlink" title="min_guarantee"></a>min_guarantee</h2><p>可选元素项min_guarantee就是应保证的虚拟机最小分配内存。该值的单位是kibibytes（1024字节块）。该元素仅被VMware ESX和OpenVZ支持。</p><p>本章节描述了用来代表作用域的xml文件格式，根据运行的作用于种类的格式变化，有一些可选配置项用来加载文件。对于特定虚拟机的细节可以查看<br><a href="https://libvirt.org/drivers.html">相关文件</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文网址：&lt;a href=&quot;https://libvirt.org/formatdomain.html#id8&quot; title=&quot;Domain XML format&quot;&gt;https://libvirt.org/formatdomain.html#id8&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="虚拟化" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="kvm" scheme="https://bbbccvbvv.github.io/tags/kvm/"/>
    
    <category term="libvirt" scheme="https://bbbccvbvv.github.io/tags/libvirt/"/>
    
    <category term="虚拟机xml配置文件" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BAxml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
    <category term="翻译" scheme="https://bbbccvbvv.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="Memory Allocation" scheme="https://bbbccvbvv.github.io/tags/Memory-Allocation/"/>
    
    <category term="Memory Backing" scheme="https://bbbccvbvv.github.io/tags/Memory-Backing/"/>
    
    <category term="Memory Tuning" scheme="https://bbbccvbvv.github.io/tags/Memory-Tuning/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】libvirt虚拟机xml配置文件格式（6）CPU Tuning</title>
    <link href="https://bbbccvbvv.github.io/2022/11/04/domain_xml_format_CPU-tuning/"/>
    <id>https://bbbccvbvv.github.io/2022/11/04/domain_xml_format_CPU-tuning/</id>
    <published>2022-11-04T06:35:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>原文网址：<a href="https://libvirt.org/formatdomain.html#id8" title="Domain XML format">https://libvirt.org/formatdomain.html#id8</a></p><span id="more"></span><pre><code>&lt;domain&gt;  ...  &lt;cputune&gt;    &lt;vcpupin vcpu=&quot;0&quot; cpuset=&quot;1-4,^2&quot;/&gt;    &lt;vcpupin vcpu=&quot;1&quot; cpuset=&quot;0,1&quot;/&gt;    &lt;vcpupin vcpu=&quot;2&quot; cpuset=&quot;2,3&quot;/&gt;    &lt;vcpupin vcpu=&quot;3&quot; cpuset=&quot;0,4&quot;/&gt;    &lt;emulatorpin cpuset=&quot;1-3&quot;/&gt;    &lt;iothreadpin iothread=&quot;1&quot; cpuset=&quot;5,6&quot;/&gt;    &lt;iothreadpin iothread=&quot;2&quot; cpuset=&quot;7,8&quot;/&gt;    &lt;shares&gt;2048&lt;/shares&gt;    &lt;period&gt;1000000&lt;/period&gt;    &lt;quota&gt;-1&lt;/quota&gt;    &lt;global_period&gt;1000000&lt;/global_period&gt;    &lt;global_quota&gt;-1&lt;/global_quota&gt;    &lt;emulator_period&gt;1000000&lt;/emulator_period&gt;    &lt;emulator_quota&gt;-1&lt;/emulator_quota&gt;    &lt;iothread_period&gt;1000000&lt;/iothread_period&gt;    &lt;iothread_quota&gt;-1&lt;/iothread_quota&gt;    &lt;vcpusched vcpus=&#39;0-4,^3&#39; scheduler=&#39;fifo&#39; priority=&#39;1&#39;/&gt;    &lt;iothreadsched iothreads=&#39;2&#39; scheduler=&#39;batch&#39;/&gt;    &lt;cachetune vcpus=&#39;0-3&#39;&gt;      &lt;cache id=&#39;0&#39; level=&#39;3&#39; type=&#39;both&#39; size=&#39;3&#39; unit=&#39;MiB&#39;/&gt;      &lt;cache id=&#39;1&#39; level=&#39;3&#39; type=&#39;both&#39; size=&#39;3&#39; unit=&#39;MiB&#39;/&gt;      &lt;monitor level=&#39;3&#39; vcpus=&#39;1&#39;/&gt;      &lt;monitor level=&#39;3&#39; vcpus=&#39;0-3&#39;/&gt;    &lt;/cachetune&gt;    &lt;cachetune vcpus=&#39;4-5&#39;&gt;      &lt;monitor level=&#39;3&#39; vcpus=&#39;4&#39;/&gt;      &lt;monitor level=&#39;3&#39; vcpus=&#39;5&#39;/&gt;    &lt;/cachetune&gt;    &lt;memorytune vcpus=&#39;0-3&#39;&gt;      &lt;node id=&#39;0&#39; bandwidth=&#39;60&#39;/&gt;    &lt;/memorytune&gt;  &lt;/cputune&gt;  ...&lt;/domain&gt;</code></pre><h1 id="cputune"><a href="#cputune" class="headerlink" title="cputune"></a>cputune</h1><p>可选元素项cputune为虚拟机提供与cpu可调参数相关的细节设置。注意：对于qemu驱动而言，可选的vcpupin和emulatorpin绑定设置需要考虑模拟器启动和NUMA限制后再进行设置。这就意味着主机的其他物理cpu在这段时间内会被虚拟机使用，这也可以从virsh cpu-stats的输出中反映出来。自0.9.0起。</p><h1 id="vcpupin"><a href="#vcpupin" class="headerlink" title="vcpupin"></a>vcpupin</h1><p>可选元素项vcpupin指明了虚拟机的vCPU将会被绑定到主机的哪一个物理CPU上。如果忽略该设置项，vcpu元素的cpuset属性项也没有设置，则vcpu会默认绑定到全部的物理cpu上。其包含两个所需的属性项，属性项vcpu指明了vcpu id，属性项cpuset与vcpu元素的cpuset属性项是完全一致的。qemu自0.9.0起被支持，xen自0.9.1起被支持。</p><h1 id="emulatorpin"><a href="#emulatorpin" class="headerlink" title="emulatorpin"></a>emulatorpin</h1><p>可选元素项emulatorpin元素指明了主机的拿个物理cpu是模拟器，这是不包含虚拟机的vcpu和iothreads绑定的cpu的子集。如果忽略该项设置，也没有设置vcpu的cpuset属性项，模拟器将会默认绑定到全部的物理cpu上。emulatorpin包含了一个必须的属性项cpuset用于指明要绑定到哪一个物理cpu中。</p><h1 id="iothreadpin"><a href="#iothreadpin" class="headerlink" title="iothreadpin"></a>iothreadpin</h1><p>可选元素项iothreadpin指明了IOThreads将会被绑定到哪一个物理cpu上。如果忽略该设置，且vcpu元素项的cpuset属性项也没有设置，IOThreads将会默认绑定到全部的物理cpu上。这里存在两个必须的属性项，属性项iothread指明了IOThread ID，属性项cpuset指明了绑定的物理cpu。可查看IOThreads Allocation章节查看iothread的有效值。自1.2.9起。</p><h1 id="shares"><a href="#shares" class="headerlink" title="shares"></a>shares</h1><p>可选元素项shares指明了虚拟机的比例加权份额。如果忽略该项设置，默认使用操作系统提供的默认值。注意，这个值没有单位，是建立在其他虚拟机设置上的相对量度。一个设置为2048的虚拟机将会相对另一个设置为1024的虚拟机得到两倍长的cpu时间。这个值得范围是2-262144.自0.9.0起。</p><h1 id="period"><a href="#period" class="headerlink" title="period"></a>period</h1><p>可选元素项period指明了执行间隔（单位：毫秒）。在该元素项内，虚拟机的每一个vcpu都不允许消耗超过配额的运行时间。该值的范围是1000-1000000.设置为0则意味着未设置数值。qemu自0.9.4起支持，lxc自0.9.10起支持。</p><h1 id="quota"><a href="#quota" class="headerlink" title="quota"></a>quota</h1><p>可选元素项quota指定了最大允许带宽（单位：毫秒）。quota设置为负值的虚拟机表明对于其vcpu线程具有无限制的带宽，即其不受带宽控制。该值的范围是1000-17592186044415或小于0.quota为0意味着未设置数值。可使用该特征确保所有的vcpu以相同速度运行。qemu自0.9.4起支持，lxc自0.9.10起支持。</p><h1 id="global-period"><a href="#global-period" class="headerlink" title="global_period"></a>global_period</h1><p>可选元素项global_period指定整个虚拟机的强制CFS调度程序间隔（单位：微秒），与强制每个vCPU间隔的period形成对比。该值的范围是1000-1000000.global_period设置为0意味着未设置数值。qemu自1.3.3起支持。</p><h1 id="global-quota"><a href="#global-quota" class="headerlink" title="global_quota"></a>global_quota</h1><p>可选元素项global_quota指明了全虚拟机在周期时间内的最大允许带宽（单位：毫秒）。global_quota设置为负值的虚拟机表明虚拟机具有无限制的带宽，即其不受带宽控制。该值的范围是1000-17592186044415或小于0.global_quota为0意味着未设置数值。qemu自1.3.3起支持。</p><h1 id="emulator-period"><a href="#emulator-period" class="headerlink" title="emulator_period"></a>emulator_period</h1><p>可选元素项emulator_period指明了强制间隔（单位：毫秒）。使用emulator_period设置，则虚拟机的模拟器线程（包括vcpu）不允许消耗超过emulator_quota的运行时间。该值的范围是1000-1000000.为0意味着未设置数值。qemu自0.10.0起支持.</p><h1 id="emulator-quota"><a href="#emulator-quota" class="headerlink" title="emulator_quota"></a>emulator_quota</h1><p>可选元素项emulator_quota指明了虚拟机模拟器线程（包括vcpu）最大允许带宽（单位：毫秒）。带有负值emulator_quota设置的虚拟机的模拟器线程（包括vcpu）拥有无限带宽，即其不受带宽控制。值范围是1000-17592186044415或小于0.quota设置为0意味着未设置值。qemu自0.10.0起支持.</p><h1 id="iothread-period"><a href="#iothread-period" class="headerlink" title="iothread_period"></a>iothread_period</h1><p>可选元素项iothread_period指明了IOThreads的强制间隔（单位：毫秒）。使用iothread_period，虚拟机的每一个IOThreads不允许消耗超过iothread_quota设置的运行时间。该值的范围是1000-1000000.设置为0意味着未设置该值。自2.1.0起支持qemu。</p><h1 id="iothread-quota"><a href="#iothread-quota" class="headerlink" title="iothread_quota"></a>iothread_quota</h1><p>可选元素项iothread_quota指明了IOThreads的最大允许带宽（单位：毫秒）。iothread_quota为负值的虚拟机表明虚拟机IOThreads具有无限带宽，即其不受带宽控制。该值的范围是1000-17592186044415或小于0.设置为0意味着未设置该值。可使用该特征确保全部IOThreads以相同速度运行。自2.1.0起支持qemu。</p><h1 id="vcpusched-x2F-iothreadsched-x2F-emulatorsched"><a href="#vcpusched-x2F-iothreadsched-x2F-emulatorsched" class="headerlink" title="vcpusched&#x2F;iothreadsched&#x2F;emulatorsched"></a>vcpusched&#x2F;iothreadsched&#x2F;emulatorsched</h1><p>可选元素项vcpusched、iothreadsched和emulatorsched分别指明了特定vcpu、iothread和模拟器线程的调度类型（值为batch、idle、fifo和rr）。对于vcpusched和iothreadsched，属性项vcpus和iothreads选择了该设置适用于哪些vCPUs&#x2F;IOThreads，其余的设置为默认值。元素项emulatorsched不具有该属性。vcpus的有效值为0到虚拟机中设置的vcpu数量减一。iothreads的有效值在IOThreads Allocation章节中有过描述。如果未定义iothreadids，然后libvirt将IOThreads编号从1到虚拟机可用的iothreads进行计数。对于实时调度（fifo、rr），也需指定优先级（非实时调度可忽略）。优先级的范围依赖于主机内核（通常为1-99）。自1.2.13起。emulatorsched自5.3.0起。</p><h1 id="cachetune（自4-1-0起）"><a href="#cachetune（自4-1-0起）" class="headerlink" title="cachetune（自4.1.0起）"></a>cachetune（自4.1.0起）</h1><p>可选元素项cachetune使用主机上的restctrl控制cpu缓存分配。是否支持此功能可以从一些限制（如最小尺寸和所需粒度）的功能中获取。必需的属性项vcpus指定了本次分配适用于哪一个vcpu。一个vcpu只能是一个cachetune元素分配项的成员。cachetune指定的vCPU可以与memorytune 中的vCPU相同，但不允许重复指定。可选的、仅输出的id属性唯一标识缓存。支持以下子元素：</p><h2 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h2><p>该可选元素项控制cpu缓存分配并具有以下属性项：</p><h3 id="level"><a href="#level" class="headerlink" title="level"></a>level</h3><p>用于分配的主机缓存等级。</p><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>用于分配的主机缓存id。</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>分配的类型。code代表指令，data代表数据。both则同时代表两者。当前分配类型只能与主机支持的类型保持一致，意味着不能在启用cdp（指令、数据优先级）的主机上使用both类型。</p><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>分配区域大小。默认值以字节为单位，但是unit属性项可用来缩放该值。</p><h3 id="unit-可选"><a href="#unit-可选" class="headerlink" title="unit(可选)"></a>unit(可选)</h3><p>如果unit设置为KiB、MiB、GiB或TiB（在Memory Allocation中的memory元素中描述），则size的默认值为字节。</p><h2 id="monitor（自4-10-0起）"><a href="#monitor（自4-10-0起）" class="headerlink" title="monitor（自4.10.0起）"></a>monitor（自4.10.0起）</h2><p>可选元素项monitor为当前缓存分配创建缓存管理器并拥有如下所需属性：</p><h3 id="level-1"><a href="#level-1" class="headerlink" title="level"></a>level</h3><p>monitor所属的主机缓存等级。</p><h3 id="vcpus"><a href="#vcpus" class="headerlink" title="vcpus"></a>vcpus</h3><p>vcpu列出了monitor的适用范围。一个monitor的vcpu列表只能是相关分配的vcpu列表的一部分。默认的管理器与相关的分配具有相同的vcpu列表。对于非默认monitor，不允许重复定义vcpu。</p><h1 id="memorytune（自4-7-0起）"><a href="#memorytune（自4-7-0起）" class="headerlink" title="memorytune（自4.7.0起）"></a>memorytune（自4.7.0起）</h1><p>可选元素项memorytune可使用主机上的resctrl控制内存带宽分配。是否支持此功能可以从一些限制（如最小尺寸和所需粒度）功能中获取。必需的属性项vcpus指定了本次分配适用于哪一个vcpu。一个vcpu只能是一个memorytune元素分配项的成员。memorytune指定的vCPU可以与cachetune中的vCPU相同，但不允许重复指定。支持以下子元素：</p><h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><p>该元素控制cpu内存带宽分配，拥有以下属性。</p><h3 id="id-1"><a href="#id-1" class="headerlink" title="id"></a>id</h3><p>分配内存带宽的主机节点id。</p><h3 id="bandwidth"><a href="#bandwidth" class="headerlink" title="bandwidth"></a>bandwidth</h3><p>节点中用于分配的内存带宽。该值默认以百分比为单位。</p><p>本章节描述了用来代表作用域的xml文件格式，根据运行的作用于种类的格式变化，有一些可选配置项用来加载文件。对于特定虚拟机的细节可以查看<br><a href="https://libvirt.org/drivers.html">相关文件</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文网址：&lt;a href=&quot;https://libvirt.org/formatdomain.html#id8&quot; title=&quot;Domain XML format&quot;&gt;https://libvirt.org/formatdomain.html#id8&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="虚拟化" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="kvm" scheme="https://bbbccvbvv.github.io/tags/kvm/"/>
    
    <category term="libvirt" scheme="https://bbbccvbvv.github.io/tags/libvirt/"/>
    
    <category term="虚拟机xml配置文件" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BAxml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
    <category term="翻译" scheme="https://bbbccvbvv.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="CPU Tuning" scheme="https://bbbccvbvv.github.io/tags/CPU-Tuning/"/>
    
  </entry>
  
  <entry>
    <title>_access函数32bit和64bit编译差异</title>
    <link href="https://bbbccvbvv.github.io/2022/10/20/access_usage/"/>
    <id>https://bbbccvbvv.github.io/2022/10/20/access_usage/</id>
    <published>2022-10-20T07:00:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近，在进行软件开发工作中遇到了一个问题，觉得比较有趣，在此进行以下记录。</p><p>问题比较简单，需要检查windows系统下的C:\Windows\System32路径下是否存在特定的用户文件（dll格式）。在这里使用_access函数（C运行库函数）对文件进行检查，该函数主要用于检查文件或目录是否存在及其对应的读写权限。但是开发完成后，在自检过程中却发现使用_access函数无法达到预期，主要表现为文件已存在，但是函数返回结果却表明文件不存在。如果换用win32 API函数PathFileExistsA却正常，文件存在于对应目录。本文即对_access函数的异常进行分析。</p><span id="more"></span><h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><p>win32函数访问没问题，而使用C语言库函数存在问题，即系统调用没问题，主要问题应该出现在C语言库上。而最简单的修改项就是编译环境修改，之前为了兼容性考虑，代码选择的编译环境为32位，因此将编译环境改为64位。此时，_access函数正常执行，返回了符合预期的结果。</p><p>因此，针对这一点进行分析，最终在微软官网上找到相关说明，链接如下：<a href="https://learn.microsoft.com/en-us/windows/win32/winprog64/file-system-redirector?from_wecom=1" title="【Microsoft】文件系统重定向">https://learn.microsoft.com/en-us/windows/win32/winprog64/file-system-redirector?from_wecom&#x3D;1</a>；</p><p>微软在64位操作系统上，为64位应用程序保留了%windir%\System32（通常就是C:\Windows\System32）路径。因为通常情况下，32位dll和64位dll的文件名称完全相同，因此64位dll也保存在System32路径下，而32位dll则被保存在其他路径。这就使得64位操作系统下的32位应用程序访问对应dll时，直接访问%windir%\System32路径是错误的，因此微软为64位系统下的32位程序通过访问%windir%\System32路径做了重定向。而32位要想真正访问%windir%\System32路径，就可以使用%windir%\Sysnative路径替代，也可以使用Wow64DisableWow64FsRedirection函数禁用文件重定向功能。</p><p>示例程序：</p><pre><code>#include  &lt;io.h&gt;#include  &lt;stdio.h&gt;#include  &lt;stdlib.h&gt;#include &lt;Windows.h&gt;#include &lt;iostream&gt;#include &quot;Shlwapi.h&quot;#include &lt;errhandlingapi.h &gt;int main( void )&#123;    char *file_path = &quot;C:\\Windows\\System32\\test.dll&quot;;    char *file_path1 = &quot;C:\\Windows\\Sysnative\\test.dll&quot;;    // Check for existence.    printf_s( &quot;1.access system32.\n&quot;);    if( (_access( file_path, 0 )) != -1 )    &#123;        printf_s( &quot;File %s is exists.\n&quot;, file_path);    &#125;    else    &#123;        printf_s( &quot;File %s isn&#39;t exists.\n&quot;, file_path);    &#125;    printf_s( &quot;2.access sysnative.\n&quot;);    if( (_access( file_path1, 0 )) != -1 )    &#123;        printf_s( &quot;File %s is exists.\n&quot;, file_path1);    &#125;    else    &#123;        printf_s( &quot;File %s isn&#39;t exists.\n&quot;, file_path1);    &#125;    PVOID OldValue = NULL;    //  Disable redirection immediately prior to the native API function call.    printf_s( &quot;3.Disable Redirection.\n&quot;);    bool flag = Wow64DisableWow64FsRedirection(&amp;OldValue);    printf(&quot;Wow64DisableWow64FsRedirection return value is %d.\n&quot;, flag);    if (!flag)    &#123;        DWORD dw = GetLastError();        printf(&quot;Errorcode is %d.\n&quot;, dw);    &#125;    if( (_access( file_path, 0 )) != -1 )    &#123;        printf_s( &quot;File %s is exists.\n&quot;, file_path);    &#125;    else    &#123;        printf_s( &quot;File %s isn&#39;t exists.\n&quot;, file_path);    &#125;    return 0;&#125;</code></pre><p>在32位编译环境下输出如下：</p><pre><code>1.access system32.File C:\Windows\System32\test.dll isn&#39;t exists.2.access sysnative.File C:\Windows\Sysnative\test.dll is exists.3.Disable Redirection.Wow64DisableWow64FsRedirection return value is 1.File C:\Windows\System32\test.dll is exists.</code></pre><p>（1）C:\Windows\System32路径无法直接访问；</p><p>（2）C:\Windows\Sysnative路径会被重定位到C:\Windows\System32；</p><p>（3）Wow64DisableWow64FsRedirection函数返回1代表函数正常运行，此后再使用C:\Windows\System32路径，则无重定向操作，获取到了正确的结果；</p><p>在64位编译环境下输出如下：</p><pre><code>1.access system32.File C:\Windows\System32\test.dll is exists.2.access sysnative.File C:\Windows\Sysnative\test.dll isn&#39;t exists.3.Disable Redirection.Wow64DisableWow64FsRedirection return value is 0.Errorcode is 1.File C:\Windows\System32\test.dll is exists.</code></pre><p>（1）C:\Windows\System32路径可以直接访问；</p><p>（2）C:\Windows\Sysnative路径不会被重定位到C:\Windows\System32；</p><p>（3）Wow64DisableWow64FsRedirection函数返回0代表函数异常运行，但不影响后续使用C:\Windows\System32路径获取正确的结果；</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>_access函数在32bit和64bit编译环境下输出结果存在差异，主要原因即为64位windows操作系统下，%windir%\System32被保留给了对应的64位应用程序，而32位应用程序访问%windir%\System32路径时就会被重定向到系统指定的其他路径上。而使用32bit编译环境最终生成的是32位应用程序，因此对应路径被重定向，直接访问%windir%\System32路径下的文件时就会出现异常。</p><p>因此建议在64位操作系统中使用64位的应用程序，而非32位的应用程序，虽然64位操作系统兼容32位应用程序，而32位操作系统不兼容64位应用程序，因此32位具有更广泛的兼容性。</p><p>如果不确定目标程序运行环境或程序存在运行于两种系统的使用场景，则在使用文件访问相关函数时：</p><p>（1）直接使用win32函数PathFileExistsA；</p><p>（2）使用_access函数前，先使用Wow64DisableWow64FsRedirection函数禁用文件重定向功能；</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>（1）<a href="https://learn.microsoft.com/en-us/windows/win32/winprog64/file-system-redirector?from_wecom=1" title="【Microsoft】文件系统重定向">https://learn.microsoft.com/en-us/windows/win32/winprog64/file-system-redirector?from_wecom&#x3D;1</a>；<br>（2）<a href="https://learn.microsoft.com/en-us/windows/win32/api/wow64apiset/nf-wow64apiset-wow64disablewow64fsredirection?from_wecom=1" title="【Microsoft】Wow64DisableWow64FsRedirection函数">https://learn.microsoft.com/en-us/windows/win32/api/wow64apiset/nf-wow64apiset-wow64disablewow64fsredirection?from_wecom&#x3D;1</a>；<br>（3）<a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/access-waccess?view=msvc-170&from_wecom=1" title="【Microsoft】_access函数">https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/access-waccess?view=msvc-170&from_wecom&#x3D;1</a>；<br>（4）<a href="https://learn.microsoft.com/en-us/windows/win32/api/shlwapi/nf-shlwapi-pathfileexistsa?from_wecom=1" title="【Microsoft】PathFileExistsA函数">https://learn.microsoft.com/en-us/windows/win32/api/shlwapi/nf-shlwapi-pathfileexistsa?from_wecom&#x3D;1</a>；</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近，在进行软件开发工作中遇到了一个问题，觉得比较有趣，在此进行以下记录。&lt;/p&gt;
&lt;p&gt;问题比较简单，需要检查windows系统下的C:\Windows\System32路径下是否存在特定的用户文件（dll格式）。在这里使用_access函数（C运行库函数）对文件进行检查，该函数主要用于检查文件或目录是否存在及其对应的读写权限。但是开发完成后，在自检过程中却发现使用_access函数无法达到预期，主要表现为文件已存在，但是函数返回结果却表明文件不存在。如果换用win32 API函数PathFileExistsA却正常，文件存在于对应目录。本文即对_access函数的异常进行分析。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="C语言" scheme="https://bbbccvbvv.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="_access函数" scheme="https://bbbccvbvv.github.io/tags/access%E5%87%BD%E6%95%B0/"/>
    
    <category term="编译环境" scheme="https://bbbccvbvv.github.io/tags/%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/"/>
    
    <category term="文件检查" scheme="https://bbbccvbvv.github.io/tags/%E6%96%87%E4%BB%B6%E6%A3%80%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】libvirt虚拟机xml配置文件格式（5）IOThreads Allocation</title>
    <link href="https://bbbccvbvv.github.io/2022/10/19/domain_xml_format_IOThreads-Allocation/"/>
    <id>https://bbbccvbvv.github.io/2022/10/19/domain_xml_format_IOThreads-Allocation/</id>
    <published>2022-10-19T09:36:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>原文网址：<a href="https://libvirt.org/formatdomain.html#id8" title="Domain XML format">https://libvirt.org/formatdomain.html#id8</a></p><p>IOThreads是支持磁盘设备的专用事件循环线程，用于执行块I&#x2F;O请求，以提高可伸缩性，尤其是在具有许多LUN的SMP主机&#x2F;客户机上。自1.2.8起（仅限于QEMU）。</p><span id="more"></span><pre><code>&lt;domain&gt;  ...  &lt;iothreads&gt;4&lt;/iothreads&gt;  ...&lt;/domain&gt;&lt;domain&gt;  ...  &lt;iothreadids&gt;    &lt;iothread id=&quot;2&quot;/&gt;    &lt;iothread id=&quot;4&quot;/&gt;    &lt;iothread id=&quot;6&quot;/&gt;    &lt;iothread id=&quot;8&quot; thread_pool_min=&quot;2&quot; thread_pool_max=&quot;32&quot;/&gt;  &lt;/iothreadids&gt;  &lt;defaultiothread thread_pool_min=&quot;8&quot; thread_pool_max=&quot;16&quot;/&gt;  ...&lt;/domain&gt;</code></pre><h1 id="iothreads"><a href="#iothreads" class="headerlink" title="iothreads"></a>iothreads</h1><p>此可选元素的内容定义要分配给虚拟机以供支持的目标存储设备使用的 IOThread数量。每一个主机CPU只有1个或2个IOThread。可能有多个受支持的设备分配给每个IOThread。自1.2.8起。</p><h1 id="iothreadids"><a href="#iothreadids" class="headerlink" title="iothreadids"></a>iothreadids</h1><p>可选的iothreadids元素提供了为虚拟机专门定义IOThread ID的能力。默认情况下，IOThread ID 是从1到为虚拟机定义的iothreads的数量顺序编号的。id属性项用于定义IOThread ID。id属性项必须是一个大于0的正整数。如果定义的iothreadids少于为虚拟机定义的iothreads，则libvirt将从1开始按顺序填充iothreadids，避免任何预定义的id。如果iothreadids大于为虚拟机定义的iothreads，iothreads的值将会相应调整。自1.2.15起。该元素有两个可选属性项thread_pool_min和thread_pool_max用于定义给定IOThread工作线程的上下限。前者可能是0，后者绝不会为0.自8.5.0起。</p><h1 id="defaultiothread"><a href="#defaultiothread" class="headerlink" title="defaultiothread"></a>defaultiothread</h1><p>该元素代表了虚拟机管理程序内部的默认事件循环，为指定特定IOThread的I&#x2F;O请求会被该循环处理。该元素可设置thread_pool_min和thread_pool_max属性项，指定了默认事件循环工作线程的上下限数量。模拟器可能是多线程的并按需生成所谓的工作线程。通常两个属性项都不会去设置（使得模拟器使用其自身的默认值），除非模拟器在实时工作负载中运行，因此无法承受生成新工作线程所需时间的不可预测性。自8.5.0起。</p><p>本章节描述了用来代表作用域的xml文件格式，根据运行的作用于种类的格式变化，有一些可选配置项用来加载文件。对于特定虚拟机的细节可以查看<br><a href="https://libvirt.org/drivers.html">相关文件</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文网址：&lt;a href=&quot;https://libvirt.org/formatdomain.html#id8&quot; title=&quot;Domain XML format&quot;&gt;https://libvirt.org/formatdomain.html#id8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;IOThreads是支持磁盘设备的专用事件循环线程，用于执行块I&amp;#x2F;O请求，以提高可伸缩性，尤其是在具有许多LUN的SMP主机&amp;#x2F;客户机上。自1.2.8起（仅限于QEMU）。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="虚拟化" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="kvm" scheme="https://bbbccvbvv.github.io/tags/kvm/"/>
    
    <category term="libvirt" scheme="https://bbbccvbvv.github.io/tags/libvirt/"/>
    
    <category term="虚拟机xml配置文件" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BAxml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
    <category term="翻译" scheme="https://bbbccvbvv.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="IOThreads Allocation" scheme="https://bbbccvbvv.github.io/tags/IOThreads-Allocation/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】libvirt虚拟机xml配置文件格式（4）CPU Allocation</title>
    <link href="https://bbbccvbvv.github.io/2022/09/05/domain_xml_format_CPU-Allocation/"/>
    <id>https://bbbccvbvv.github.io/2022/09/05/domain_xml_format_CPU-Allocation/</id>
    <published>2022-09-05T11:01:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>原文网址：<a href="https://libvirt.org/formatdomain.html#id8" title="Domain XML format">https://libvirt.org/formatdomain.html#id8</a></p><span id="more"></span><pre><code>&lt;domain&gt;  ...  &lt;vcpu placement=&#39;static&#39; cpuset=&quot;1-4,^3,6&quot; current=&quot;1&quot;&gt;2&lt;/vcpu&gt;  &lt;vcpus&gt;    &lt;vcpu id=&#39;0&#39; enabled=&#39;yes&#39; hotpluggable=&#39;no&#39; order=&#39;1&#39;/&gt;    &lt;vcpu id=&#39;1&#39; enabled=&#39;no&#39; hotpluggable=&#39;yes&#39;/&gt;  &lt;/vcpus&gt;  ...&lt;/domain&gt;</code></pre><h1 id="vcpu"><a href="#vcpu" class="headerlink" title="vcpu"></a>vcpu</h1><p>该元素定义了分配给客户机操作系统的虚拟cpu的最大数量，该值范围为1到虚拟机管理器支持的最大数量之间。</p><h2 id="cpuset"><a href="#cpuset" class="headerlink" title="cpuset"></a>cpuset</h2><p>可选属性cpuset是以逗号分隔的物理CPU编号列表，默认情况下虚拟机进程和虚拟CPU可以固定到对应编号的物理CPU上。（注意：虚拟机进程和虚拟cpu的绑定（pinning）策略可以由cputune分别指定。如果cputune的属性项emulatorpin被设置，则vcpu指定的cpuset将会被忽略。对于vcpupin指定的虚拟cpu，cpuset制定的cpuset也会被忽略。vcpupin未指定的虚拟cpu，每一个都会被绑定到cpuset指定的物理cpu上）。列表中的每一个元素可以是一个单独的cpu编号、cpu编号范围或是插入符号后跟要从先前范围中排除的CPU编号。自0.4.4版本起支持。</p><h2 id="current"><a href="#current" class="headerlink" title="current"></a>current</h2><p>可选属性current可用于指定是否应启用少于最大数量的虚拟CPU。从 0.8.5开始。</p><h2 id="placement"><a href="#placement" class="headerlink" title="placement"></a>placement</h2><p>可选属性placement可用来表明虚拟机进程的cpu布局模式。该值可为static或auto，但是如果指定了cpuset，则默认numatune的placement设置为static。使用auto表示虚拟机进程将通过查询numa固定到咨询节点集，如果指定了属性cpuset的值，则将被忽略。如果cpuset和placement都没有指定或placement设置为static，但是cpuset为指定，则虚拟机进程将会被绑定到所有的可用物理cpu上。自0.9.11起（仅限于QEMU和KVM）。</p><h1 id="vcpus"><a href="#vcpus" class="headerlink" title="vcpus"></a>vcpus</h1><p>vcpus元素项运行控制单个vCPU的状态。id属性项指定了libvirt在其他地方使用的vCPU id，例如vCPU绑定、调度程序信息和NUMA分配。请注意，在某些情况下，客户机中看到的vCPU ID可能与libvirt ID不同。有效ID 从0到vcpu元素设置的最大vCPU计数减 1。enabled属性项允许控制vCPU的状态。有效值为yes和no。hotpluggable控制在引导开机时启用CPU是否可以热插拔和热拔出给定的vCPU。请注意，所有禁用的vCPU必须是可热插拔的。有效值为yes和no。order允许指定在线vCPU的顺序。对于需要一次插入多个vCPU的虚拟机管理器&#x2F;平台，该顺序可能会在需要一次启用的所有 vCPU上重复。顺序不强制指定。然后以任意顺序添加vCPU。如果使用了顺序信息，它必须用于所有在线vCPU。虚拟机管理器可能在单一操作期间清理或更新顺序信息。请注意，虚拟机管理器可能会创建不同于引导vCPU的热插拔vCPU，因此可能需要进行特殊初始化。虚拟机管理器可能要求启动时启用的不可热插拔的vCPU在开始时从ID 0开始聚集。可能还需要vCPU 0始终存在且不可热插拔。请注意，可能需要为单个CPU提供状态以支持可寻址的 vCPU热插拔，并且此功能可能不受所有虚拟机管理器的支持。QEMU要求实现以下条件。vCPU 0需启用并设置为不可热插拔。在PPC64上，同样需要启用同一内核中的vCPU。引导开机时存在的所有非热插拔CPU都需要在vCPU 0 之后进行分组。自2.2.0起（仅限于QEMU）。</p><p>本章节描述了用来代表作用域的xml文件格式，根据运行的作用于种类的格式变化，有一些可选配置项用来加载文件。对于特定虚拟机的细节可以查看<br><a href="https://libvirt.org/drivers.html">相关文件</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文网址：&lt;a href=&quot;https://libvirt.org/formatdomain.html#id8&quot; title=&quot;Domain XML format&quot;&gt;https://libvirt.org/formatdomain.html#id8&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="虚拟化" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="kvm" scheme="https://bbbccvbvv.github.io/tags/kvm/"/>
    
    <category term="libvirt" scheme="https://bbbccvbvv.github.io/tags/libvirt/"/>
    
    <category term="虚拟机xml配置文件" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BAxml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
    <category term="翻译" scheme="https://bbbccvbvv.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="CPU Allocation" scheme="https://bbbccvbvv.github.io/tags/CPU-Allocation/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】libvirt虚拟机xml配置文件格式（3）SMBIOS System Information</title>
    <link href="https://bbbccvbvv.github.io/2022/09/02/domain_xml_format_SMBIOS-System-Information/"/>
    <id>https://bbbccvbvv.github.io/2022/09/02/domain_xml_format_SMBIOS-System-Information/</id>
    <published>2022-09-02T09:00:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>原文网址：<a href="https://libvirt.org/formatdomain.html#id8" title="Domain XML format">https://libvirt.org/formatdomain.html#id8</a></p><p>一些虚拟机管理器运行控制呈现给客户机的系统信息（例如虚拟机管理器可以填充SMBIOS并通过客户机的dmidecode指令进行检查）。可选元素项sysinfo包含了所有此类信息。自0.8.7版本起。</p><span id="more"></span><pre><code>...&lt;os&gt;  &lt;smbios mode=&#39;sysinfo&#39;/&gt;  ...&lt;/os&gt;&lt;sysinfo type=&#39;smbios&#39;&gt;  &lt;bios&gt;    &lt;entry name=&#39;vendor&#39;&gt;LENOVO&lt;/entry&gt;  &lt;/bios&gt;  &lt;system&gt;    &lt;entry name=&#39;manufacturer&#39;&gt;Fedora&lt;/entry&gt;    &lt;entry name=&#39;product&#39;&gt;Virt-Manager&lt;/entry&gt;    &lt;entry name=&#39;version&#39;&gt;0.9.4&lt;/entry&gt;  &lt;/system&gt;  &lt;baseBoard&gt;    &lt;entry name=&#39;manufacturer&#39;&gt;LENOVO&lt;/entry&gt;    &lt;entry name=&#39;product&#39;&gt;20BE0061MC&lt;/entry&gt;    &lt;entry name=&#39;version&#39;&gt;0B98401 Pro&lt;/entry&gt;    &lt;entry name=&#39;serial&#39;&gt;W1KS427111E&lt;/entry&gt;  &lt;/baseBoard&gt;  &lt;chassis&gt;    &lt;entry name=&#39;manufacturer&#39;&gt;Dell Inc.&lt;/entry&gt;    &lt;entry name=&#39;version&#39;&gt;2.12&lt;/entry&gt;    &lt;entry name=&#39;serial&#39;&gt;65X0XF2&lt;/entry&gt;    &lt;entry name=&#39;asset&#39;&gt;40000101&lt;/entry&gt;    &lt;entry name=&#39;sku&#39;&gt;Type3Sku1&lt;/entry&gt;  &lt;/chassis&gt;  &lt;oemStrings&gt;    &lt;entry&gt;myappname:some arbitrary data&lt;/entry&gt;    &lt;entry&gt;otherappname:more arbitrary data&lt;/entry&gt;  &lt;/oemStrings&gt;&lt;/sysinfo&gt;&lt;sysinfo type=&#39;fwcfg&#39;&gt;  &lt;entry name=&#39;opt/com.example/name&#39;&gt;example value&lt;/entry&gt;  &lt;entry name=&#39;opt/com.coreos/config&#39; file=&#39;/tmp/provision.ign&#39;/&gt;&lt;/sysinfo&gt;...</code></pre><p>sysinfo元素包含一个强制属性项type决定了子元素的布局，支持值如下：</p><h1 id="smbios"><a href="#smbios" class="headerlink" title="smbios"></a>smbios</h1><p>子元素调用特定的SMBIOS值，如果被用在os元素（参照Operating system booting）的smbios子元素间的连接上，将会影响客户机。sysinfo 的每个子元素命名一个SMBIOS块，并且在这些元素中可以是描述块内字段的条目元素列表。识别以下块和条目：</p><h2 id="bios"><a href="#bios" class="headerlink" title="bios"></a>bios</h2><p>这是SMBIOS的块0，条目名称来自：</p><ul><li>vender：BIOS供应商名称</li><li>version：BIOS版本</li><li>date：BIOS发行日期。如果提供了该元素项，则会改为mm&#x2F;dd&#x2F;yy或mm&#x2F;dd&#x2F;yyyy的格式。如果字符串的年部分只有两个数字，则将会假定为19yy年。</li></ul><h2 id="system"><a href="#system" class="headerlink" title="system"></a>system</h2><p>这是SMBIOS的块1，条目名称来自：</p><ul><li>manufacturer：BIOS制造商</li><li>product：产品名称</li><li>version：产品版本</li><li>serial：序列号</li><li>uuid：统一唯一标识符。如果该条目与顶层的uuid的一起设定，则两个元素值必须相同</li><li>sku：识别特定配置的sku编号</li><li>family：识别特定计算机所属的家族系列</li></ul><h2 id="baseBoard"><a href="#baseBoard" class="headerlink" title="baseBoard"></a>baseBoard</h2><p>这是SMBIOS的块2.该元素项可以重复多次用以描述所有的基板（base board）；然而，并不是所有的虚拟机管理器都支持该元素项重复。该元素项有下列的子元素项：</p><ul><li>manufacturer：BIOS的制造商</li><li>product：产品名称</li><li>version：产品版本号</li><li>serial：序列号</li><li>asset：资产标签</li><li>location：机箱内的位置</li></ul><p><strong>注意：bios、system和baseBoard块的错误条目会被忽略，而不会报错。除了uuid验证和日期格式检查之外，所有值都作为字符串传递给虚拟机管理器驱动程序。</strong></p><h2 id="chassis"><a href="#chassis" class="headerlink" title="chassis"></a>chassis</h2><p>自4.1.0起支持。SMBIOS的块3，条目名称来自：</p><ul><li>manufacturer：机箱的制造商</li><li>version：机箱的版本号</li><li>serial：序列号</li><li>asset：资产标签</li><li>sku：sku编号</li></ul><h2 id="oemStrings"><a href="#oemStrings" class="headerlink" title="oemStrings"></a>oemStrings</h2><p>SMBIOS的块11.该元素项只出现一次，却有多个entry子元素项，每一个都提供随机字符串数据。对于entry提供的数据并没有任何限制，如果数据打算由客户机中的应用程序使用，建议使用应用程序名称作为字符串中的前缀。（自4.1.0起支持）</p><h1 id="fwcfg"><a href="#fwcfg" class="headerlink" title="fwcfg"></a>fwcfg</h1><p>一些虚拟机管理器提供统一的方法来调整固件如何配置自身，或者可能包含要为客户机操作系统安装的表，例如引导顺序、ACPI、SMBIOS等。</p><p>如果允许用户自定义自己的配置blob（config blob）。在QEMU的例子中，然后这些出现在domain的sysfs下（如果客户机内核启用FW_CFG_SYSFS配置项），即&#x2F;sys&#x2F;firmware&#x2F;qemu_fw_cfg路径下。注意，这些值适用于<os/>下的<smbios/>模式。自6.5.0起支持。</p><p><strong>注意：由于数据槽数量有限，强烈建议不要使用fwcfg，而应使用 <oemStrings/>。</strong></p><pre><code>&lt;sysinfo type=&#39;fwcfg&#39;&gt;  &lt;entry name=&#39;opt/com.example/name&#39;&gt;example value&lt;/entry&gt;  &lt;entry name=&#39;opt/com.example/config&#39; file=&#39;/tmp/provision.ign&#39;/&gt;&lt;/sysinfo&gt;</code></pre><p>sysinfo元素项拥有多个entry子元素。每一个元素都有强制的name属性，它定义了blob的名称，并且必须以opt&#x2F;开头，并且为了避免与其他名称冲突，建议采用opt&#x2F;$RFQDN&#x2F;$name形式，其中$RFQDN是控制的反向完全限定域名。之后，元素项也可以包含相应数值（直接设置blob值），或者file属性项（从file中设置blob值）。</p><p>本章节描述了用来代表作用域的xml文件格式，根据运行的作用于种类的格式变化，有一些可选配置项用来加载文件。对于特定虚拟机的细节可以查看<br><a href="https://libvirt.org/drivers.html">相关文件</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文网址：&lt;a href=&quot;https://libvirt.org/formatdomain.html#id8&quot; title=&quot;Domain XML format&quot;&gt;https://libvirt.org/formatdomain.html#id8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一些虚拟机管理器运行控制呈现给客户机的系统信息（例如虚拟机管理器可以填充SMBIOS并通过客户机的dmidecode指令进行检查）。可选元素项sysinfo包含了所有此类信息。自0.8.7版本起。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="虚拟化" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="kvm" scheme="https://bbbccvbvv.github.io/tags/kvm/"/>
    
    <category term="libvirt" scheme="https://bbbccvbvv.github.io/tags/libvirt/"/>
    
    <category term="虚拟机xml配置文件" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BAxml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
    <category term="翻译" scheme="https://bbbccvbvv.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="SMBIOS System Information" scheme="https://bbbccvbvv.github.io/tags/SMBIOS-System-Information/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】libvirt虚拟机xml配置文件格式（2）Operating system booting</title>
    <link href="https://bbbccvbvv.github.io/2022/08/31/domain_xml_format_Operating-system-booting/"/>
    <id>https://bbbccvbvv.github.io/2022/08/31/domain_xml_format_Operating-system-booting/</id>
    <published>2022-08-31T11:00:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>原文网址：<a href="https://libvirt.org/formatdomain.html#id8" title="Domain XML format">https://libvirt.org/formatdomain.html#id8</a></p><p>这里有很多不同的方法用来引导操作系统开机，每一个都有优点与缺点。</p><span id="more"></span><h1 id="BIOS-bootloader"><a href="#BIOS-bootloader" class="headerlink" title="BIOS bootloader"></a>BIOS bootloader</h1><p>支持全虚拟化（full virtualization）的虚拟机管理程序可以通过BIOS引导开机。在这种情况下，BIOS存在开机顺序优先级（软盘floppy、硬盘harddisk、光盘cdrom、网络network）决定到哪里去获取&#x2F;查找开机镜像（boot image）。</p><pre><code>&lt;!-- Xen with fullvirt loader --&gt;&lt;!-- 使用全虚拟化加载器的Xen--&gt;...&lt;os&gt;  &lt;type&gt;hvm&lt;/type&gt;  &lt;loader&gt;/usr/lib/xen/boot/hvmloader&lt;/loader&gt;  &lt;boot dev=&#39;hd&#39;/&gt;&lt;/os&gt;...&lt;!-- QEMU with default firmware, serial console and SMBIOS --&gt;&lt;!-- 使用默认的硬件、串行控制台和SMBIOS的QEMU--&gt;...&lt;os&gt;  &lt;type&gt;hvm&lt;/type&gt;  &lt;boot dev=&#39;cdrom&#39;/&gt;  &lt;bootmenu enable=&#39;yes&#39; timeout=&#39;3000&#39;/&gt;  &lt;smbios mode=&#39;sysinfo&#39;/&gt;  &lt;bios useserial=&#39;yes&#39; rebootTimeout=&#39;0&#39;/&gt;&lt;/os&gt;...&lt;!-- QEMU with UEFI manual firmware and secure boot --&gt;&lt;!-- 使用UEFI手动固件和安全启动的QEMU--&gt;...&lt;os&gt;  &lt;type&gt;hvm&lt;/type&gt;  &lt;loader readonly=&#39;yes&#39; secure=&#39;yes&#39; type=&#39;pflash&#39;&gt;/usr/share/OVMF/OVMF_CODE.fd&lt;/loader&gt;  &lt;nvram template=&#39;/usr/share/OVMF/OVMF_VARS.fd&#39;&gt;/var/lib/libvirt/nvram/guest_VARS.fd&lt;/nvram&gt;  &lt;boot dev=&#39;hd&#39;/&gt;&lt;/os&gt;...&lt;!-- QEMU with UEFI manual firmware, secure boot and with NVRAM type &#39;file&#39;--&gt;&lt;!-- 使用UEFI手动固件、安全启动和NVRAM类型文件的QEMU--&gt;...&lt;os&gt;  &lt;type&gt;hvm&lt;/type&gt;  &lt;loader readonly=&#39;yes&#39; secure=&#39;yes&#39; type=&#39;pflash&#39;&gt;/usr/share/OVMF/OVMF_CODE.fd&lt;/loader&gt;  &lt;nvram type=&#39;file&#39; template=&#39;/usr/share/OVMF/OVMF_VARS.fd&#39;&gt;    &lt;source file=&#39;/var/lib/libvirt/nvram/guest_VARS.fd&#39;/&gt;  &lt;/nvram&gt;  &lt;boot dev=&#39;hd&#39;/&gt;&lt;/os&gt;...&lt;!-- QEMU with UEFI manual firmware, secure boot and with network backed NVRAM&#39;--&gt;&lt;!-- 使用UEFI手动固件、安全启动和网络支持的NVRAM的QEMU--&gt;...&lt;os&gt;  &lt;type&gt;hvm&lt;/type&gt;  &lt;loader readonly=&#39;yes&#39; secure=&#39;yes&#39; type=&#39;pflash&#39;&gt;/usr/share/OVMF/OVMF_CODE.fd&lt;/loader&gt;  &lt;nvram type=&#39;network&#39;&gt;    &lt;source protocol=&#39;iscsi&#39; name=&#39;iqn.2013-07.com.example:iscsi-nopool/0&#39;&gt;      &lt;host name=&#39;example.com&#39; port=&#39;6000&#39;/&gt;      &lt;auth username=&#39;myname&#39;&gt;        &lt;secret type=&#39;iscsi&#39; usage=&#39;mycluster_myname&#39;/&gt;      &lt;/auth&gt;    &lt;/source&gt;  &lt;/nvram&gt;  &lt;boot dev=&#39;hd&#39;/&gt;&lt;/os&gt;...&lt;!-- QEMU with automatic UEFI firmware and secure boot --&gt;&lt;!-- 使用自动UEFI固件和安全启动的QEMU--&gt;...&lt;os firmware=&#39;efi&#39;&gt;  &lt;type&gt;hvm&lt;/type&gt;  &lt;loader secure=&#39;yes&#39;/&gt;  &lt;boot dev=&#39;hd&#39;/&gt;&lt;/os&gt;...&lt;!-- QEMU with automatic UEFI stateless firmware for AMD SEV --&gt;&lt;!-- 使用适用于AMD SEV的自动UEFI无状态固件的QEMU--&gt;...&lt;os firmware=&#39;efi&#39;&gt;  &lt;type&gt;hvm&lt;/type&gt;  &lt;loader stateless=&#39;yes&#39;/&gt;  &lt;boot dev=&#39;hd&#39;/&gt;&lt;/os&gt;...</code></pre><h2 id="firmware固件"><a href="#firmware固件" class="headerlink" title="firmware固件"></a>firmware固件</h2><p>firmware属性项允许管理程序自动填充<loader/>和<nvram/>元素，通过选择的固件可以使能启用一些必须的特征项。可接受的值为bios和efi。选择过程扫描在特定位置的描述已安装固件镜像的文件，使用最具体的一个填充domain的需求。选择的位置（从通用到最具体的一个）如下：</p><ul><li>&#x2F;usr&#x2F;share&#x2F;qemu&#x2F;firmware</li><li>&#x2F;etc&#x2F;qemu&#x2F;firmware</li><li>$XDG_CONFIG_HOME&#x2F;qemu&#x2F;firmware</li></ul><p>对于更多信息，可以参考QEMU代码库中的docs&#x2F;interop&#x2F;firmware.json描述的固件元数据规范。常规用户可不关心这一点。从libvirt 5.2.0（仅限于QEMU和KVM）版本开始。</p><p>对于VMware客户机，当客户机使用UEFI时则必须设置为efi，使用BIOS时可以不设置。从libvirt 5.3.0（VMware ESX和Workstation&#x2F;Player）版本开始。</p><h2 id="type类型"><a href="#type类型" class="headerlink" title="type类型"></a>type类型</h2><p>type属性项指明了在虚拟机中启动的操作系统的类型。</p><ul><li>hvm表明操作系统被设计用来在裸机（bare metal）上运行，因此需要全虚拟化。</li><li>linux（糟糕的命名）表明是一个支持Xen 3虚拟机管理程序客户机ABI的操作系统。</li><li>【可选】arch表明了需要虚拟化的CPU架构。</li><li>【可选】machine表明了机器类型。</li></ul><p>xml功能（Capabilities XML）章节描述了允许值得详细信息。大多数虚拟机管理程序的驱动程序都省略了arch的设置，则所在主机host的架构就会被选择。对于test、ESX和VMWare虚拟机管理程序驱动程序，在x86_64主机上通常会选择i686架构。从libvirt 0.0.1版本开始提供支持。</p><h2 id="firmware固件-1"><a href="#firmware固件-1" class="headerlink" title="firmware固件"></a>firmware固件</h2><p>从libvirt 7.2.0版本开始仅对QEMU&#x2F;KVM提供支持。</p><p>当使用固件自动选择功能时，固件中存在不同的可用特征。特征列表限制了为虚拟机自动选择的固件。特征列表也可以通过使用0或更多的feature元素进行指定。选择硬件时，libvirt只会考虑列表中的特征，忽略其他特征项。</p><h3 id="feature"><a href="#feature" class="headerlink" title="feature"></a>feature</h3><p>强制属性列表：</p><ul><li><p>enabled：可用值为<strong>yes</strong>和<strong>no</strong>，告诉libvirt在自动选择固件时是否要启用或禁用对应特征项</p></li><li><p>name：特征项名称，特征值如下表所示：</p><ul><li><p>enrolled-keys:选择的nvram模板是否有默认证书注册。带有安全启动（Secure Boot）特征的固件如果没有注册密钥，将会以无签名二进制文件成功开机。仅针对带有安全启动（Secure Boot）特征的固件进行校验。</p></li><li><p>secure-boot:固件是否实现UEFI安全启动（Secure Boot）特征。</p></li></ul></li></ul><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>可选配置项loader标签指的是固件blob，通过绝对路径指定，被用来辅助domain创建过程。该标签为Xen全虚拟化domain使用，也被用来为QEMU&#x2F;KVM domain设置QEMU BIOS文件路径。Xen自libvirt 0.1.0版本后被支持，QEMU&#x2F;KVM自libvirt 0.9.12版本后被支持。该元素有两个可选的属性项：readonly（可用值为yes或no）表明镜像是可写的还是只读的。第二个属性项type可用值为rom和pflash。其告诉虚拟机管理程序文件应该被映射到客户机内存的什么位置上。例如，如果loader的路径指向一个UEFI镜像，type就应该是pflash。此外，一些固件会实现安全启动（Secure Boot）功能。属性项secure可以向虚拟机管理程序表明固件是否兼容安全启动（Secure Boot）功能。它不能用于在固件中启用或禁用功能本身。自libvirt 2.1.0版本后被支持.如果loader被标记为只读（read-only），之后在UEFI环境下，其会假定这里存在一个可用的可写NVRAM。在某些情况下，loader更倾向于在无 NVRAM环境下运行，在关机时丢弃任何配置变化。stateless标识（自libvirt 8.6.0版本后被支持）可被用来控制这种行为，如果设置为n，o则NVRAM将永远不会被创建。</p><h2 id="nvram"><a href="#nvram" class="headerlink" title="nvram"></a>nvram</h2><p>一些UEFI固件可能想要使用一个非易失性存储器去保存一些变量。在主机中，这表示为一个文件，文件的绝对路径被保存在这一元素中。此外，当domain启动时，libvirt复制在qemu.conf中定义的所谓的主NVRAM存储文件。如果必要的话，template属性可用于配置文件中主NVRAM存储的每个域的覆盖映射。对于非持久性domain，如果NVRAM文件已由libvirt创建，则它会被留下，并且管理程序有责任保存和删除文件（如果需要持久保存）。自1.2.8起。</p><p>自8.5.0版本起，该元素拥有type属性项（可用值为file、block和network）。在这种情况下，NVRAM存储器被<source>子元素使用和disk源相同的语法进行阐述。详情可参阅Hard drives, floppy disks, CDROMs章节。</p><p>注意：network支持的NVRAM不是从template中实例化的，因此使用者需人为提供一个可用的NVRAM镜像。</p><p>如果loader被标记为stateless，则提供该元素是无效的。</p><h2 id="boot"><a href="#boot" class="headerlink" title="boot"></a>boot</h2><p>dev属性项使用fd、hd、cdrom和network等值。用于指定下一个要考虑的引导设备。boot元素可以重复多次以安装用于轮流尝试的引导设备优先级列表。多个相同类型的设备根据它们的目标进行排序，同时保留总线的顺序。在define完domain后，libvirt返回XML配置（通过virDomainGetXMLDesc）列出已排好序的设备。排序完成之后，第一个设备被标记为可引导的（bootable）。配置为从“hd”引导且分配有vdb、hda、vda和hdc磁盘的域将从vda引导启动（排序列表为vda、vdb、hda、hdc）。类似的带有hdc、vda、vdb和hda磁盘的domain竟会从hda（磁盘排序为：hda、hdc、vda和vdb）引导启动。以所需方式进行配置将会十分麻烦，这就是引入每个设备引导元素的原因，也是提供对引导顺序的完全控制的首选方式。boot元素和每个设备引导元素是互斥的。boot元素自0.1.3起提供支持，per-device boot自0.8.8起提供支持。</p><h2 id="smbios"><a href="#smbios" class="headerlink" title="smbios"></a>smbios</h2><p>如何填充客户机中可见的SMBIOS信息。mode属性项必须被指定，其值为emulate（虚拟机管理程序生成所有值）、host（从主机的SMBIOS值中复制除UUID之外的全部Block 0 和Block 1；virConnectGetSysinfo函数调用可以被用来查看哪些值被复制）或sysinfo（使用 SMBIOS System Information元素中的值）。如果未制定，则虚拟机管理程序默认使用。从0.8.7版本起提供支持。</p><p>到目前为止，BIOS&#x2F;UEFI配置旋钮足够通用，可以由大多数（不是全部）固件实现。然而，从现在开始，并不是每一个单项配置都对所有固件起作用。例如，rebootTimeout对UEFI无作用，useserial可能对不产生输出到串行行的BIOS固件有影响等等。此外，固件经常不能导出其功能以便libvirt（或使用者）进行检查。固件功能的集合会随着新版本而发生变化。因此，建议用户在生产中依赖它们之前尝试他们使用的设置。</p><h2 id="bootmenu"><a href="#bootmenu" class="headerlink" title="bootmenu"></a>bootmenu</h2><p>在客户机启动时是否启用交互式引导菜单提示。enable属性项可以是yes或no。如果没有指明，虚拟机见识程序默认使用该功能。自0.8.3版本提供支持。额外的属性项timeout指明需要多少毫秒等待启动菜单，直到它超时。允许的值是 [0, 65535] 范围内的数字，除非 enable 设置为“yes”，否则该属性项会被忽略。自1.2.8版本提供支持。</p><h2 id="bios"><a href="#bios" class="headerlink" title="bios"></a>bios</h2><p>该元素属性项useserial可用值为yes或no。该属性项启用或禁用串行图形适配器（Serial Graphics Adapter）功能，该功能可以使得用户在串口上看到BIOS信息。因此，需定义串口。自0.9.4版本起。自0.10.2版本起（仅限于QEMU）。还有另外一个属性项rebootTimeout，当引导启动失败时，该属性想决定是否重启以及间隔多长时间后再次尝试引导启动。该值以毫秒为单位，最大值为65535，特殊值-1禁用重启功能。</p><h1 id="Host-bootloader"><a href="#Host-bootloader" class="headerlink" title="Host bootloader"></a>Host bootloader</h1><p>采用半虚拟化的管理程序通常不会模拟BIOS，而是主机负责启动操作系统引导。在主机中使用pseudo-bootloader提供接口以便为客户机选择一个内核。一个例子便是Xen的pygrub。而Bhyve虚拟机管理程序也使用主机bootloader方式，bhyveload或grub-bhyve。</p><h2 id="bootloader"><a href="#bootloader" class="headerlink" title="bootloader"></a>bootloader</h2><p>bootloader提供了主机操作系统中引导加载程序可执行文件的完全限定路径。运行bootloader选择要引导的内核。引导加载程序所需的输出取决于使用的管理程序。自0.1.1起。</p><h2 id="bootloader-args"><a href="#bootloader-args" class="headerlink" title="bootloader_args"></a>bootloader_args</h2><p>可选配置项bootloader_args允许将命令行参数传递给bootloader。自0.2.3起。</p><h1 id="Direct-kernel-boot"><a href="#Direct-kernel-boot" class="headerlink" title="Direct kernel boot"></a>Direct kernel boot</h1><p>安装一个新的客户机操作系统时，直接从存储在主机操作系统中的内核和 initrd引导通常很有用，可以将命令行参数直接传递给安装程序。该功能可在半虚拟化和全虚拟化客户机中使用。</p><pre><code>...&lt;os&gt;  &lt;type&gt;hvm&lt;/type&gt;  &lt;loader&gt;/usr/lib/xen/boot/hvmloader&lt;/loader&gt;  &lt;kernel&gt;/root/f8-i386-vmlinuz&lt;/kernel&gt;  &lt;initrd&gt;/root/f8-i386-initrd&lt;/initrd&gt;  &lt;cmdline&gt;console=ttyS0 ks=http://example.com/f8-i386/os/&lt;/cmdline&gt;  &lt;dtb&gt;/root/ppc.dtb&lt;/dtb&gt;  &lt;acpi&gt;    &lt;table type=&#39;slic&#39;&gt;/path/to/slic.dat&lt;/table&gt;  &lt;/acpi&gt;&lt;/os&gt;...</code></pre><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>该属性项与之前在BIOS bootloader中的描述有相同的语义。</p><h2 id="loader-1"><a href="#loader-1" class="headerlink" title="loader"></a>loader</h2><p>该属性项与之前在BIOS bootloader中的描述有相同的语义。</p><h2 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h2><p>该属性项指明了主机中内核镜像的全限定路径。</p><h2 id="initrd"><a href="#initrd" class="headerlink" title="initrd"></a>initrd</h2><p>该属性项指明了主机中ramdisk镜像（可选项）的全限定路径。</p><h2 id="cmdline"><a href="#cmdline" class="headerlink" title="cmdline"></a>cmdline</h2><p>该属性项指明了引导启动时传递给内核（或安装程序）的参数。这经常被用来指定备用主控制台（或串口）、安装媒体源&#x2F;kickstart 文件。</p><h2 id="dtb"><a href="#dtb" class="headerlink" title="dtb"></a>dtb</h2><p>该元素项指明了主机中的设备树二进制（device tree binary，dtb）镜像的全限定路径。从1.0.4版本起提供支持。</p><h2 id="acpi"><a href="#acpi" class="headerlink" title="acpi"></a>acpi</h2><p>table元素包含了ACPI（Advanced Configuration and Power Interface，高级配置和电源接口）表。type属性项包含ACPI表类型（当前只有slic被支持）。自1.3.5支持QEMU。自5.9.0支持Xen。</p><h1 id="Container-boot"><a href="#Container-boot" class="headerlink" title="Container boot"></a>Container boot</h1><p>当使用基于虚拟化的容器引导启动一个虚拟机时，可不使用内核&#x2F;引导镜像，使用init元素指定init二进制文件的路径。默认无参数加载。为指明初始化参数，使用initarg参数项，根据需要重复多次。如果设置了cmdline元素，将会被用来提供一个&#x2F;proc&#x2F;cmdline的替代项，但是却不会影响初始化参数（init argv）。</p><p>使用initenv元素设置环境变量，一个元素代表一个变量。</p><p>使用initdir元素为初始化设置特定的工作目录。</p><p>以给定的用户或用户组运行初始化命令，分别使用inituser或initgroup。两个元素可以被用来提供用户id或用户名称。使用**a+**前缀用户或组ID将强制将其视为数值。如果没有该项，它将首先作为用户名或组名进行尝试。</p><pre><code>&lt;os&gt;  &lt;type arch=&#39;x86_64&#39;&gt;exe&lt;/type&gt;  &lt;init&gt;/bin/systemd&lt;/init&gt;  &lt;initarg&gt;--unit&lt;/initarg&gt;  &lt;initarg&gt;emergency.service&lt;/initarg&gt;  &lt;initenv name=&#39;MYENV&#39;&gt;some value&lt;/initenv&gt;  &lt;initdir&gt;/my/custom/cwd&lt;/initdir&gt;  &lt;inituser&gt;tester&lt;/inituser&gt;  &lt;initgroup&gt;1000&lt;/initgroup&gt;&lt;/os&gt;</code></pre><p>如果想要使用用户命名空间，设置idmap属性项。uid和gid元素有3个属性项：</p><ul><li><p>start：容器的第一个用户ID。其值为0.</p></li><li><p>target：容器的第一个用户ID将会映射到主机中的目标用户ID。</p></li><li><p>count：映射到主机中的用户的容器用户数量。</p>  <idmap>    <uid start='0' target='1000' count='10'/>    <gid start='0' target='1000' count='10'/>  </idmap></li></ul><p>本章节描述了用来代表作用域的xml文件格式，根据运行的作用于种类的格式变化，有一些可选配置项用来加载文件。对于特定虚拟机的细节可以查看<br><a href="https://libvirt.org/drivers.html">相关文件</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文网址：&lt;a href=&quot;https://libvirt.org/formatdomain.html#id8&quot; title=&quot;Domain XML format&quot;&gt;https://libvirt.org/formatdomain.html#id8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里有很多不同的方法用来引导操作系统开机，每一个都有优点与缺点。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="虚拟化" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="kvm" scheme="https://bbbccvbvv.github.io/tags/kvm/"/>
    
    <category term="libvirt" scheme="https://bbbccvbvv.github.io/tags/libvirt/"/>
    
    <category term="虚拟机xml配置文件" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BAxml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
    <category term="翻译" scheme="https://bbbccvbvv.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="Operating system booting" scheme="https://bbbccvbvv.github.io/tags/Operating-system-booting/"/>
    
  </entry>
  
</feed>
