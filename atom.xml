<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>怀德维宁</title>
  
  <subtitle>大邦维屏，大宗维翰。怀德维宁，宗子维城。</subtitle>
  <link href="https://bbbccvbvv.github.io/atom.xml" rel="self"/>
  
  <link href="https://bbbccvbvv.github.io/"/>
  <updated>2024-11-04T03:47:58.364Z</updated>
  <id>https://bbbccvbvv.github.io/</id>
  
  <author>
    <name>杨维宁</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>因磁盘空间变化引发的windows虚拟内存机制分析验证</title>
    <link href="https://bbbccvbvv.github.io/2024/11/04/20241104-windows_virtual_memory_experiment/"/>
    <id>https://bbbccvbvv.github.io/2024/11/04/20241104-windows_virtual_memory_experiment/</id>
    <published>2024-11-04T12:56:10.000Z</published>
    <updated>2024-11-04T03:47:58.364Z</updated>
    
    <content type="html"><![CDATA[<p>在工单处理过程中，遇到了一起异常事件，客户在虚拟机重启后发现业务文件丢失（对应文件夹内仅保留了一个dll文件，其他文件被删除），而且重启后系统的磁盘空间增加，因此客户怀疑windows系统或者存储存在问题。后经过分析，发现客户的虚拟机在重启前存在很高的内存压力，在系统日志中可以发现虚拟内存不足的警告事件，因此认为：</p><span id="more"></span><p>（1）业务文件丢失应为被删除的原因，怀疑是使用者操作时误删，dll因为被使用所以无法删除被保留，其他的文件被删除，而由于所需的其他文件已经被加载到内存，系统业务仍然正常运行；</p><p>（2）windows重启后磁盘可用空间增加是windows虚拟机内存机制，在内存负载较高时主动占用多余的磁盘空间供内存使用，重启后对应磁盘空间被释放，因此造成重启后磁盘可用空间增加；</p><p>现在针对第二点进行windows虚拟内存机制的验证。</p><h1 id="验证流程"><a href="#验证流程" class="headerlink" title="验证流程"></a>验证流程</h1><h2 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h2><p>初始状态下，D盘保存有分页文件（大小为17G），虚拟机的总计可提交内存为33G（符合预期，物理内存16G+非农业文件17G）。</p><p>此时已提交内存大小为8.2g，可提交内存大小为33g，d盘的可用空间为187.1g，分页文件大小为17G</p><p><img src="/images/windows_virtual_memory_experiment/1.png"></p><p><img src="/images/windows_virtual_memory_experiment/2.png"></p><h2 id="申请大量内存"><a href="#申请大量内存" class="headerlink" title="申请大量内存"></a>申请大量内存</h2><p>进行内存压测，申请40G的内存</p><p>此时已提交内存大小为47g，可提交内存大小为53g，d盘的可用空间为166.27g，分页文件大小为36G</p><p>备注：进程进行内存申请时，一般使用malloc相关函数，申请后虽然可以看到已提交内存增大，但是实际上系统并未在此时实际分配，只有在业务使用memset等函数对内存进行写入时，内存才会被真正分配，在测试时需要注意这一点。</p><p><img src="/images/windows_virtual_memory_experiment/3.png"></p><p><img src="/images/windows_virtual_memory_experiment/4.png"></p><h2 id="释放申请内存"><a href="#释放申请内存" class="headerlink" title="释放申请内存"></a>释放申请内存</h2><p>将申请的40g内存释放</p><p>此时已提交内存大小为6.7g，可提交内存大小为38.2g，d盘的可用空间为181.87g，分页文件大小为22.2G</p><p>备注：everything的文件大小显示异常，分页文件实际大小可通过文件属性页获得。</p><p><img src="/images/windows_virtual_memory_experiment/5.png"></p><p><img src="/images/windows_virtual_memory_experiment/6.png"></p><h1 id="验证结论"><a href="#验证结论" class="headerlink" title="验证结论"></a>验证结论</h1><table><thead><tr><th>时间</th><th>已提交内存</th><th>可提价内存</th><th>分页文件大小</th><th>分页文件磁盘分区可用容量</th></tr></thead><tbody><tr><td>初始</td><td>8.2（0）</td><td>33（0）</td><td>17（0）</td><td>187.1（0）</td></tr><tr><td>申请40g内存</td><td>47（+38.8）</td><td>53（+20）</td><td>36（+19）</td><td>166.27（-20.83）</td></tr><tr><td>释放40g内存</td><td>6.7（-1.5）</td><td>38.2（+5.2）</td><td>22.2（+5.2）</td><td>181.87（-5.23）</td></tr></tbody></table><p>根据上述测试可知：</p><p>（1）在用户使用内存超过windows的可提交内存后，如果情况允许（分页文件所处的磁盘中存在可用空间），那么windows系统会对分页文件进行扩容进而增大windows的可提交内存（示例中的可提交内存总量从33g增加到了53g），而与此同时d盘的可用空间减小了20g左右，其数值与windows可用内存的增加值正好符合。因此可以认为windows在适当的情况下（内存负载过高可提交内存不足、分页文件设置允许进行扩容、分页文件所处磁盘分区存在剩余空间可供扩容使用），会自动使用磁盘空间作为虚拟机内存以供程序使用，直观表现为可提交内存与分页文件增加，磁盘分区可用空间减小，增加与减小的容量大致相同；</p><p>（2）在内存使用高峰过去后，windows会对之前的分页文件进行缩容操作，释放之前分配的过多磁盘空间，但是不一定会完全恢复到初始状态；</p><p>（3）windows基于分页文件的虚拟内存机制看起来比其他系统的固定大小的交互分区更为灵活，因此非专业人士不建议手动修改分页文件的相关设置，使用windows的默认配置策略即可；</p><p>（4）因为windows基于分页文件的虚拟内存机制，因此如果想在不增加物理内存的情况下改善系统内存使用情况，建议可以将分页文件设置在存储性能较高的磁盘上（例如选择ssd而非hhd磁盘分区存储分页文件），并在对应的磁盘分区上保留足够的磁盘空间，使得系统可以在内存负载较高时使用磁盘空间满足业务需求；</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在工单处理过程中，遇到了一起异常事件，客户在虚拟机重启后发现业务文件丢失（对应文件夹内仅保留了一个dll文件，其他文件被删除），而且重启后系统的磁盘空间增加，因此客户怀疑windows系统或者存储存在问题。后经过分析，发现客户的虚拟机在重启前存在很高的内存压力，在系统日志中可以发现虚拟内存不足的警告事件，因此认为：&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="windows" scheme="https://bbbccvbvv.github.io/tags/windows/"/>
    
    <category term="虚拟内存" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
    <category term="分页文件" scheme="https://bbbccvbvv.github.io/tags/%E5%88%86%E9%A1%B5%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>windows系统内存参数分析</title>
    <link href="https://bbbccvbvv.github.io/2024/11/01/20241101-windows_memory_para_analyze/"/>
    <id>https://bbbccvbvv.github.io/2024/11/01/20241101-windows_memory_para_analyze/</id>
    <published>2024-11-01T10:56:10.000Z</published>
    <updated>2024-11-01T06:46:52.708Z</updated>
    
    <content type="html"><![CDATA[<p>现代操作系统普遍采用了虚拟机内存机制以扩展用户或程序可使用的最大内存值，但是不同的系统有不同的内存管理机制，因此适用于某一系统的术语在另一系统上可能并不是同一概念。本文旨在对于windows系统中内存相关的参数进行解析，使得使用者可以对于windows的内存相关参数有一个清晰的理解。</p><span id="more"></span><p>在windows系统中，内存的相关数据可以通过以下四种方法查看：</p><p>（1）任务管理器；</p><p>（2）资源监视器；</p><p>（3）systeminfo；</p><p>（4）procexp；</p><p>下面分别介绍在这四种方法中看到的内存各项参数的具体含义：</p><h1 id="任务管理器内存参数"><a href="#任务管理器内存参数" class="headerlink" title="任务管理器内存参数"></a>任务管理器内存参数</h1><p>一般对windows系统当前运行情况进行查看时，任务管理器都是第一选择。在任务管理器的性能界面上，可以选择内存进行系统内存信息的查看。</p><p><img src="/images/windows_memory_para_analyze/1.png"></p><p>自上而下对相关参数进行介绍：</p><p>（1）内存：16GB</p><p>实际的物理内存，在真实物理机中，就是主板上内存插槽中全部内存条的总容量，在虚拟机中，就是创建虚拟机时配置的内存大小。在系统运行过程中，该参数一般不会发生改变。但是虚拟机具有动态调整内存的功能，因此实际上虚拟机中的该参数是会发生变化的。</p><p>（2）使用中（已压缩）：7.5GB（470MB）</p><p>当前正在被操作系统和正在运行的程序使用的物理内存。包括已分配但是未必正在活跃使用的内存。<br>出现的”已压缩”字样，它指的是操作系统对内存页进行了压缩。这是一种操作系统级别的优化技术，旨在减少内存使用量并提高系统性能。<br>内存压缩通常在系统资源紧张时才会被启用，并且操作系统会根据系统负载和内存需求来自动调整内存压缩的程度。在正常情况下，内存压缩对大多数用户和应用程序不会产生明显的性能下降。然而，在某些情况下，例如对于特定的高性能应用程序或需要大量内存带宽的工作负载，可能会出现轻微的性能影响。</p><pre><code>#关闭内存压缩，重启生效Disable-MMAgent -mc#开启内存压缩，重启生效Enable-MMAgent -mc#查看当前内存压缩状态Get-mmagent </code></pre><p>（3）可用：8.4GB</p><p>表示当前操作系统可用于分配给新进程或应用程序的物理内存，可用内存是系统当前未被使用的内存。<br>初次看到这个参数，可能有的用户会产生一种错觉：只要可用内存不为0，则计算机当前运行情况良好。这种观点是不正确的，windows系统内存的占用关键是看已提交内存的使用率，而可用内存仅代表内存当前未被使用，不代表内存未被分配出去。而这部分内存可被其他进程使用的前提是可以被置换到磁盘上的分页文件中，如果分页文件已满，则这些内存也无法被其他进程使用。</p><p>（4）为硬件保留的内存：0.5MB</p><p>表示由硬件设备保留的物理内存，通常由系统BIOS或UEFI分配。<br>物理内存&#x3D;使用中内存 + 可用内存 + 为硬件保留的内存；</p><p>（5）已提交：9.8&#x2F;33.0GB</p><p>表示已分配的物理内存和虚拟内存的总和，已提交的内存包括当前正在使用的内存和保留的内存空间。<br>左边（9.8G）：当前运行的所有程序总共已经向操作系统申请的内存空间<br>右边（33G）：当前运行的所有程序总共可以向操作系统申请的内存空间</p><p>（6）已缓存：8.4GB</p><p>显示文件系统缓存占用的物理内存。文件系统缓存有助于提高文件访问速度，缓存最近访问过的文件。</p><p>（7）分页缓冲池：770MB</p><p>内核使用的内存池，存储可以交换到磁盘的数据。</p><p>（8）非分页缓冲池：810MB</p><p>内核使用的内存池，存储不可以交换到磁盘的数据。</p><h1 id="资源监视器内存参数"><a href="#资源监视器内存参数" class="headerlink" title="资源监视器内存参数"></a>资源监视器内存参数</h1><p><img src="/images/windows_memory_para_analyze/2.png"></p><h2 id="进程内存参数"><a href="#进程内存参数" class="headerlink" title="进程内存参数"></a>进程内存参数</h2><p>（1）提交：表示已经被分配给进程和系统使用的虚拟内存大小。已提交内存包括物理内存（RAM）和交换文件（Pagefile）中的空间，用于存储进程的代码、数据以及操作系统的内核数据。</p><p>（2）工作集：进程所占用的总物理内存。但是这个值是由两部分组成, 即 专用工作集 （即专用内存）+ 共享工作集（即可共享内存）；</p><p>（3）可共享：该进程和别的进程共享的内存量；</p><p>（4）专用：进程独占的物理内存；</p><pre><code>（1）工作集，即在物理内存中的数据的集合；（2）工作集 = 专用内存 + 共享内存；（3）将所有的 &quot;工作集&quot; 相加后的值会大于任务管理器中内存占用的百分比，因为百分比对共享内存进行排重了，即共享内存会在不同进程中被重复计算；（4）&quot;提交大小&quot; 和 &quot;工作集&quot; 是两个层面的概念，大部分活跃进程的 &quot;工作集&quot; 会大于 &quot;提交大小&quot;，而大部分非活跃的进程 &quot;工作集&quot; 会小于 &quot;提交大小&quot;，但是两者没有绝对关系；</code></pre><h2 id="物理内存参数"><a href="#物理内存参数" class="headerlink" title="物理内存参数"></a>物理内存参数</h2><p>物理内存大小为16G，内部分为了以下几个部分：</p><p>（1）为硬件保留的内存（1MB）：专门为硬件（如显卡、BIOS等）保留的内存，通常在系统启动时由硬件设备直接占用，用户无法访问。</p><p>（2）正在使用（7732MB）：当前正在被操作系统和正在运行的程序使用的物理内存；</p><p>（3）已修改（20MB）：被修改的内存页，但是修改并未写回到磁盘，写回操作完成后这部分内存才能用于其他用途；</p><p>（4）备用（8614MB）：包含未使用的缓存数据和代码的内存；</p><p>（5）可用（17MB）：不包含任何有价值数据，以及当进程、驱动程序、操作系统需要更多的内存时优先使用的内存；</p><p>实际上的可用内存（8631MB）&#x3D; 备用内存（8614MB）+ 可用内存（17MB），而当系统内存负载过高时，也可以看到可用内存急剧减少。</p><p>缓存：当文件被打开时，系统会把文件保存在缓存中，方便下次迅速读写。Windows 2008 R2及以后版本，对这个缓存的使用也做了限制，有一部分物理内存不会被缓存使用，保证系统即使在缓存过大的时候，也有可用物理内存，满足程序使用需求。</p><h1 id="systeminfo内存参数"><a href="#systeminfo内存参数" class="headerlink" title="systeminfo内存参数"></a>systeminfo内存参数</h1><p><img src="/images/windows_memory_para_analyze/3.png"></p><p>（1）Total Physical Memory：16383MB</p><p>对应任务管理器中的总物理内存，即实际的物理内存。在真实物理机中，就是主板上内存插槽中全部内存条的总容量。</p><p>（2）Available Physical Memory：8634MB</p><p>对应任务管理器中的可用内存，表示当前操作系统可用于分配给新进程或应用程序的物理内存，可用内存是系统当前未被使用的内存。</p><p>（3）Virtual Memory：Max Size：33791MB</p><p>对应任务管理器中的可提交内存，表示已分配的物理内存和虚拟内存的总和。</p><p>（4）Virtual Memory：Available：23778MB</p><p>可提交内存与已提交内存之差，表示当前运行的所有程序还可以向操作系统申请的内存空间。</p><p>（5）Virtual Memory：In Use：10013MB</p><p>对应任务管理器中的已提交内存，表示当前运行的所有程序总共已经向操作系统申请的内存空间。</p><p>（6）Page File Location</p><p>分页文件的位置，windows通过分页文件机制提供了远超物理内存大小的虚拟机内存。<br>如下图所示，在windows系统的高级设置-性能选项中可以修改分页文件的设置（文件位置及文件大小）。名称虚拟内存是一个不太准确的标题，忽略即可。</p><p><img src="/images/windows_memory_para_analyze/4.png"></p><h1 id="procexp内存参数"><a href="#procexp内存参数" class="headerlink" title="procexp内存参数"></a>procexp内存参数</h1><p><img src="/images/windows_memory_para_analyze/5.png"></p><p>procexp显示相比较上述的途径更加全面，主要包含提交内存、物理内存、内核内存（分页缓冲池和非分页缓冲池），相关参数都已经在前面有过介绍，这里不再赘述。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>（1）决定windows系统当前真实内存负载的参数是任务管理器界面的已提交内存，该数值越大，代表系统内部当前各项进程申请的内存资源越多，如果已提交内存远大于真实物理内存，代表一大部分文件被置换到了分页文件中，进行进程切换时可能会有卡断发生；</p><p>（2）资源监视器的物理内存参数真实反应了系统当前物理内存的分配使用情况，该界面的可用内存（备用+可用）越小，代表此时系统的内存压力越大；</p><p>（3）反应进程真实物理内存使用的是其工作集，尤其是工作集中的专用内存，这部分内存表示该进程独占的物理内存，在系统内存压力过大时，可以手动关闭专用内存占用较多的进程；</p><p>（4）驱动有时也会发生内存泄漏，但是相关信息无法通过上述的工具看到，这时可以使用微软提供的poolmon工具进行分析，使用方法可在网络进行搜索；</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://learn.microsoft.com/zh-cn/troubleshoot/windows-client/performance/introduction-to-the-page-file">https://learn.microsoft.com/zh-cn/troubleshoot/windows-client/performance/introduction-to-the-page-file</a><br><a href="https://answers.microsoft.com/zh-hans/windows/forum/all/windows/e1a6c144-26e1-4c1a-af27-c5c90fd60308?page=2">https://answers.microsoft.com/zh-hans/windows/forum/all/windows/e1a6c144-26e1-4c1a-af27-c5c90fd60308?page=2</a><br><a href="https://blog.51cto.com/markwin/91907">https://blog.51cto.com/markwin/91907</a><br><a href="https://cloud.tencent.com/developer/article/1924864">https://cloud.tencent.com/developer/article/1924864</a><br><a href="https://www.pcoic.com/system/windows/4785.html">https://www.pcoic.com/system/windows/4785.html</a><br><a href="https://docs.freebsd.org/en/articles/vm-design/#allen-briggs-qa">https://docs.freebsd.org/en/articles/vm-design/#allen-briggs-qa</a><br><a href="https://www.itprotoday.com/cloud-computing/the-memory-optimization-hoax">https://www.itprotoday.com/cloud-computing/the-memory-optimization-hoax</a><br><a href="https://www.zhihu.com/question/43714216/answer/1164044678">https://www.zhihu.com/question/43714216/answer/1164044678</a><br><a href="https://github.com/cw1997/memory-allocation-test">https://github.com/cw1997/memory-allocation-test</a><br><a href="https://www.cnblogs.com/oboth-zl/p/17168468.html">https://www.cnblogs.com/oboth-zl/p/17168468.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;现代操作系统普遍采用了虚拟机内存机制以扩展用户或程序可使用的最大内存值，但是不同的系统有不同的内存管理机制，因此适用于某一系统的术语在另一系统上可能并不是同一概念。本文旨在对于windows系统中内存相关的参数进行解析，使得使用者可以对于windows的内存相关参数有一个清晰的理解。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="windows" scheme="https://bbbccvbvv.github.io/tags/windows/"/>
    
    <category term="内存" scheme="https://bbbccvbvv.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>windows救援模式下设置完全内存转储</title>
    <link href="https://bbbccvbvv.github.io/2024/10/23/20241023-windows_set_full_memory_dump_in_rescue/"/>
    <id>https://bbbccvbvv.github.io/2024/10/23/20241023-windows_set_full_memory_dump_in_rescue/</id>
    <published>2024-10-23T10:56:10.000Z</published>
    <updated>2024-10-23T11:42:27.012Z</updated>
    
    <content type="html"><![CDATA[<p>在windows系统遇到异常时，往往会触发自带的异常转储机制，将问题现场进行保存，方便事后使用对应的dmp文件进行分析。但是系统默认的设置为核心内存转储，即只转储问题时刻的部分关键内存信息，但是系统的判断并不总是正确的，因此很可能便会造成dmp因为部分关键内存信息没有被保存而无法精确定位问题。</p><span id="more"></span><p>尤其是在遇到开机相关的异常问题时，由于无法正常进入系统，因此只能依靠dmp进行分析。但是如果系统没有进行转储设置或者设置的不是完全内存转储，就会造成没有合适的dmp用来分析定位问题。这时如果能够修改为完全内存转储，再通过外部注入中断（例如kvm环境下的inject-nmi）主动触发转储机制，就可以获得比较完整的异常现场信息，以便进行问题定位分析。下面就介绍如何在救援模式下进行windows转储设置的相关修改：</p><p>（0）进入救援模式中，将问题windows的磁盘挂载到救援机上，异常机的系统盘会被分配一个盘符（根据救援机和异常机的磁盘挂载情况不同发生变化，在本次演示中，异常机的系统盘盘符为E）；</p><p>（1）打开windows注册表（regedit），选择HKEY_LOCAL_MACHINE条目（dump相关信息保存在该条目下，因此选择将异常机的注册表也挂载在该条目下）：</p><p><img src="/images/windows_set_full_memory_dump_in_rescue/1.png"></p><p>（2）点击文件（file），选择加载配置单元（load hive）；</p><p><img src="/images/windows_set_full_memory_dump_in_rescue/2.png"></p><p>（3）选择异常机的system注册表配置单元（异常机系统盘的windows\System32\config\SYSTEM文件，在本文中具体路径是E:\windows\System32\config\SYSTEM）；</p><p><img src="/images/windows_set_full_memory_dump_in_rescue/3.png"></p><p>（4）为加载的注册表配置单元起一个名称与其他注册表项进行区分（在本文中命名为aaa）；</p><p><img src="/images/windows_set_full_memory_dump_in_rescue/4.png"></p><p><img src="/images/windows_set_full_memory_dump_in_rescue/5.png"></p><p>（5）在虚拟机内可能存在多个controlset，因此需要在注册表中查找虚拟机启动时真实加载的controlset，查看aaa下的select注册表项（在本文中可以看到default默认值为1，代表系统启动时加载的是controlset001，因此修改controlset001，也可以对全部的controlset进行相同的改动）；</p><p><img src="/images/windows_set_full_memory_dump_in_rescue/6.png"></p><p><img src="/images/windows_set_full_memory_dump_in_rescue/7.png"></p><p>（6）修改aaa\ControlSet001\Control\CrashControl路径下的CrashControl，将其值改为1；</p><p><img src="/images/windows_set_full_memory_dump_in_rescue/8.png"></p><p>（7）修改aaa\ControlSet001\Control\SESSION MANAGER\MEMORY路径下的PagingFiles，将其值改为”C:\pagefile.sys 8600 8600”（配置的分页文件大小需要比内存大小要大，否则会转储失败，因为异常机的内存为8g，因此配置了8600，一般4g配置4300即可）（另外需保证异常机的系统盘可用空间不小于配置的分页文件大小，不然内存转储也会失败）；</p><p><img src="/images/windows_set_full_memory_dump_in_rescue/9.png"></p><p>这样配置修改就完成了，后续就可以通过主动触发中断的方式获取完全内存转储的dmp文件了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在windows系统遇到异常时，往往会触发自带的异常转储机制，将问题现场进行保存，方便事后使用对应的dmp文件进行分析。但是系统默认的设置为核心内存转储，即只转储问题时刻的部分关键内存信息，但是系统的判断并不总是正确的，因此很可能便会造成dmp因为部分关键内存信息没有被保存而无法精确定位问题。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="windows" scheme="https://bbbccvbvv.github.io/tags/windows/"/>
    
    <category term="转储设置" scheme="https://bbbccvbvv.github.io/tags/%E8%BD%AC%E5%82%A8%E8%AE%BE%E7%BD%AE/"/>
    
    <category term="救援模式" scheme="https://bbbccvbvv.github.io/tags/%E6%95%91%E6%8F%B4%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>windbg手动添加非官方pdb文件进行调试</title>
    <link href="https://bbbccvbvv.github.io/2024/07/25/windbg_add_pdb_file_manually/"/>
    <id>https://bbbccvbvv.github.io/2024/07/25/windbg_add_pdb_file_manually/</id>
    <published>2024-07-25T13:33:20.000Z</published>
    <updated>2024-10-14T12:10:18.588Z</updated>
    
    <content type="html"><![CDATA[<p>在使用windbg分析windows产生的dmp异常转储文件时，常常需要使用到相关应用的pdb文件，否则就只能看到粗略的模块，却不能看到具体的函数执行内容。而微软的官方pdb服务器可以下载到windows相关的pdb文件，对于非官方的程序或驱动，就需要调试者自己去查找并进行设置。本文就如何在使用windbg调试dmp时，如何手动添加非官方的pdb文件进行描述，希望能够帮助遇到该问题的开发者。</p><span id="more"></span><p>笔者最近在分析一个dmp文件，从其stack中可以看到，异常发生时涉及到了一个第三方程序netkvm，查询资料发现这是一个开源的第三方网络驱动，主要用于虚拟机。由于初始时只有微软的相关pdb文件，因此在stack中只能看到netkvm的模块名称，却无法准确判断具体的异常函数。</p><p><img src="/images/windbg_add_pdb_file_manually/1.png"></p><p>因为netkvm是开源的驱动文件，因此很容易在社区中找到了所需的sys和pdb文件，但是直接将对应的文件放入到笔者设置的本地symbol路径下，并重新reload并没有效果，那么问题应该是文件路径不对，windbg没有识别相关的文件，因此需要获取windbg加载pdb的详细路径。</p><p>使用“.reload &#x2F;f netkvm.sys”指令尝试加载相关的模块，可以看到windbg异常输出如下：</p><p><img src="/images/windbg_add_pdb_file_manually/2.png"></p><p>从上述报错信息可以看到，windbg尝试从“d:\symbols\netkvm.sys\61A8F2E22e000”路径加载netkvm.sys文件，从“d:\symbols\netkvm.pdb\E2CD669467F24AFB9856B5AF63BB298B2”路径加载netkvm.pdb文件。因此解决方法也很简单，创建指定的文件目录，并把所需的文件放入到指定的路径下，并使用“.reload”指令重新加载pdb文件.</p><p><img src="/images/windbg_add_pdb_file_manually/3.png"></p><p>后查看stack，可以看到netkvm显示了具体的调用函数信息。</p><p><img src="/images/windbg_add_pdb_file_manually/4.png"></p><script src="https://utteranc.es/client.js" repo="bbbccvbvv/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;在使用windbg分析windows产生的dmp异常转储文件时，常常需要使用到相关应用的pdb文件，否则就只能看到粗略的模块，却不能看到具体的函数执行内容。而微软的官方pdb服务器可以下载到windows相关的pdb文件，对于非官方的程序或驱动，就需要调试者自己去查找并进行设置。本文就如何在使用windbg调试dmp时，如何手动添加非官方的pdb文件进行描述，希望能够帮助遇到该问题的开发者。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="windbg" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/windbg/"/>
    
    
    <category term="windows" scheme="https://bbbccvbvv.github.io/tags/windows/"/>
    
    <category term="windbg" scheme="https://bbbccvbvv.github.io/tags/windbg/"/>
    
    <category term="非官方pdb" scheme="https://bbbccvbvv.github.io/tags/%E9%9D%9E%E5%AE%98%E6%96%B9pdb/"/>
    
  </entry>
  
  <entry>
    <title>关于南宋权相现象的一些思考</title>
    <link href="https://bbbccvbvv.github.io/2024/02/27/south_song_leader-20240227/"/>
    <id>https://bbbccvbvv.github.io/2024/02/27/south_song_leader-20240227/</id>
    <published>2024-02-27T11:56:10.000Z</published>
    <updated>2024-02-27T11:57:02.946Z</updated>
    
    <content type="html"><![CDATA[<p>秦朝奠定了三公九卿制度，但先是西汉时，汉武帝建立内朝，剥夺了丞相的定策权利，转而以尚书主管负责内朝的实际运转。</p><span id="more"></span><p>再是东汉时以三公取代丞相的职权，甚至于不再设置丞相，将相权拆分为多份，而实际处理政务、发号施令的机构是尚书台，因此两汉权臣的标配是录尚书事。</p><p>三国时，蜀国丞相只有诸葛亮一人，后面的蒋费二人都没有获得丞相的官职，主要是以大将军身份处理朝政。而东吴的丞相一直存在，但是大多数情况下只是朝局发展的背景板。魏国则在尚书台机构之外，设立了中书监机构，剥夺了尚书的部分职权。</p><p>西晋大体维持了中书尚书和三公的权力架构，但是东晋迫于北方的严峻军事压力又设立了丞相一职，后来的南朝又新增了门下机构用以制衡中书机构。</p><p>隋唐一统天下，最终以三省六部取代三公九卿，完成了制度的又一变革，但是唐末的节度使制度崩坏，而文官的官职分离则是行政制度发展的又一趋势。</p><p>北宋统一了中原及南方后，对制度进行了修正，形成了东西府制度，即代表文官的中书门下和代表武官的枢密院，两院的首长都可以成为宰相。</p><p>由宋神宗和王安石推动的变法运动不仅是致力于政策的实施，同时修正了官制，使得官职分离的现象得到改善。而到了南宋，则出现了北宋从没有出现过的权相，这一现象的产生必然有其深刻的社会历史原因。</p><p>纵观之前的制度建设情况，丞相代表的是以官僚为主的行政权，而皇帝大部分情况下的皇权实质是军权，即皇帝代表的暴力机构与官僚的对抗是政治制度发展变化的主要原因。而之前对于相权的拆分与削弱也可以认为是皇帝代表的军权的衰弱，皇权弱了，如果不削弱对应的相权，那么可能又会出一个王莽了。这个制度在承平年代还能撑得住，换言之，大部分人无所谓其好与不好，只是没有新的出路，凑活着过罢了。但是这个制度一旦面临外部冲击，其自身是十分脆弱的，因为制度改革把大部分情况下不足以更新体制本身，只是隔靴搔痒罢了，更何况皇帝的个人素质大部分情况下连中人之姿都没有，维持一个强力的相权，难道不怕喧宾夺主吗？所以皇权和相权大部分情况下都是臭棋篓子下棋，越下越臭，两者一同衰弱。</p><p>衰弱的封建制度遇到了有活力的社会团体的冲击，自然要先被打个七零八落的。但是官僚制度既然存在必然有其存在的理由，秦皇汉武、唐宗宋祖都是在这个体制的支撑下才成就其事业的。外部冲击下，直观的表现就是战争失利，面临生死存亡的危机，皇帝与官僚也不得不放弃对于武将的压制，因此军队就首先在外部冲击之下变得高效起来，而军队的维持需要消耗物资，越高效的军队对于物资的消耗量也越大，这就要求有一个与之配套的组织生产的机构，即行政官僚。因此中国的历史大致就可以看作是，承平日久，军队和官僚一起摆烂，毕竟军队都烂了，官僚也没必要再保持那么高的行政效率。突遇危机，军队不得不高效，因此行政制度也随之高效运转，一些以前不能突破的禁区突破了，不敢动的规则变更了，整个社会在先军的目标下运行效率逐渐提升。</p><p>因此南宋的权相产生原因便是源于自北宋末年而来的来自于北方的强大军事压力，在这种情况下，往往会有一个所谓的中兴之主，重新驾驭高效的军事及行政机构，完成复兴，并再次衰落。但是很可惜，完颜构不是这样的人（有人辩解九妹比南明强多了，那我就说你都和南明比了，就顺从你吧）。即军事及行政机构复兴后，皇帝没有能力或不愿驾驭相关权力，但是权力天然就会集中，因此作为文官之首的丞相是驾驭这一权力的天然顺位继承人，这就是南宋出现这些权相的原因。</p><p>只是权相可以驾驭这些权力，但是却不具有大义的名分。因此看似权力虽大，但是始终无法突破体制的桎梏，在初期的辉煌之后只能落寞，在体制内缝缝补补。幸而北方的金朝也同步衰落，让其续命若干年，但是面临更加高效的蒙古体制的冲击，必然败下阵来。</p><p>有人说元朝的民族歧视政策，但是九妹的南宋也是有归正人与北人的说法的。纵观历史，宋朝军队只要皇帝不姓赵，其战斗力都是极为强大的，每思至此，免不得一声长叹。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;秦朝奠定了三公九卿制度，但先是西汉时，汉武帝建立内朝，剥夺了丞相的定策权利，转而以尚书主管负责内朝的实际运转。&lt;/p&gt;</summary>
    
    
    
    <category term="历史" scheme="https://bbbccvbvv.github.io/categories/%E5%8E%86%E5%8F%B2/"/>
    
    
    <category term="南宋权相" scheme="https://bbbccvbvv.github.io/tags/%E5%8D%97%E5%AE%8B%E6%9D%83%E7%9B%B8/"/>
    
    <category term="丞相制度" scheme="https://bbbccvbvv.github.io/tags/%E4%B8%9E%E7%9B%B8%E5%88%B6%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】windbg调试0xef异常（1）</title>
    <link href="https://bbbccvbvv.github.io/2024/02/05/windbg_0xef_debug_1/"/>
    <id>https://bbbccvbvv.github.io/2024/02/05/windbg_0xef_debug_1/</id>
    <published>2024-02-05T13:17:00.000Z</published>
    <updated>2024-02-05T13:23:21.938Z</updated>
    
    <content type="html"><![CDATA[<p>停止码0xEF出现的可能原因如下：</p><span id="more"></span>​<p>（1）硬件故障，尤其是内存和磁盘；</p><p>（2）安全软件例如杀毒软件；</p><p>（3）windows自身原因；</p><p>第一个原因是以上三个原因中最普遍的原因，尤其是加载到内存中的程序因为一些未处理的异常而中止自身运行是最典型的情况。之后造成操作系统突然panic并抛出0xEF停止码。另一方面，如果安全软件不信任二进制运行文件并中止其运行。如果对应的程序是critical关键进程（例如scvhost.exe），这会造成灾难性的后果。但是第二种情况较少出现。</p><p>然而，在这篇文章中，我将会将注意力集中到第三个原因上，当启动了影子栈shadow stack功能，并且监测到影子栈与调用栈间存在差异，windows系统会中止运行进程，并进而导致0xEF停止码被抛出。这也是我把windows自身作为0xEF异常产生原因的理由，尽管这种情况也有可能是因为异常的驱动程序或内存引起的。</p><p>如果启用了基于硬件的栈保护，处理器会保持两份调用栈的拷贝，第二份拷贝就是知名的影子栈。该栈旨在控制线程的运行流，如果任一栈的返回地址存在异常，则一个特殊的硬件异常被抛出进而造成进程被windows中止。</p><pre><code>CRITICAL_PROCESS_DIED (ef)        A critical system process diedArguments:Arg1: ffffaf08b56a90c0, Process object or thread objectArg2: 0000000000000000, If this is 0, a process died. If this is 1, a thread died.Arg3: 0000000000000000Arg4: 00000000000000003: kd&gt; knL# Child-SP          RetAddr               Call Site00 ffff8c0a`14b3ed38 fffff801`0ed0d122     nt!KeBugCheckEx01 ffff8c0a`14b3ed40 fffff801`0ec0c7a3     nt!PspCatchCriticalBreak+0x10e02 ffff8c0a`14b3ede0 fffff801`0ea99290     nt!PspTerminateAllThreads+0x17291703 ffff8c0a`14b3ee50 fffff801`0ea9908c     nt!PspTerminateProcess+0xe004 ffff8c0a`14b3ee90 fffff801`0e80f8f8     nt!NtTerminateProcess+0x9c &lt;&lt; Terminate our svchost.exe process which then bugchecks the system05 ffff8c0a`14b3ef00 fffff801`0e800ca0     nt!KiSystemServiceCopyEnd+0x2806 ffff8c0a`14b3f098 fffff801`0e860d9d     nt!KiServiceLinkage07 ffff8c0a`14b3f0a0 fffff801`0e8106a4     nt!KiDispatchException+0x17941d08 ffff8c0a`14b3f8e0 fffff801`0e80e03c     nt!KiFastFailDispatch+0xe409 ffff8c0a`14b3fac0 00007ffc`f18833c6     nt!KiControlProtectionFault+0x2fc &lt;&lt; Throws #CP (Control Protection) exception0a 0000002f`4637f820 000001b1`ae000340     ntdll!RtlpGetActivationContextData+0x520b 0000002f`4637f828 000001b1`ae002480     0x000001b1`ae0003400c 0000002f`4637f830 00000000`00000001     0x000001b1`ae0024800d 0000002f`4637f838 000001b1`000000f0     0x10e 0000002f`4637f840 00000000`00000002     0x000001b1`000000f00f 0000002f`4637f848 00000050`00000000     0x210 0000002f`4637f850 00000000`00000002     0x00000050`0000000011 0000002f`4637f858 00000000`000000f0     0x212 0000002f`4637f860 00000000`00000000     0xf0</code></pre><p>如果检查传递给nt!KiDispatchException函数的第一个参数，就可以看到抛出的异常类型信息。</p><pre><code>07 ffff8c0a14b3f0a0 fffff8010e8106a4 nt!KiDispatchException+17941d (perf)    Parameter[0] = ffff8c0a14b3fa18    Parameter[1] = 0000000000000000    Parameter[2] = ffffffffffffff80    Parameter[3] = 0000002f4637f8203: kd&gt; .exr ffff8c0a14b3fa18ExceptionAddress: 00007ffcf18833c6 (ntdll!RtlpGetActivationContextData+0x0000000000000052)ExceptionCode: c0000409 (Security check failure or stack buffer overrun)ExceptionFlags: 00000001NumberParameters: 1Parameter[0]: 0000000000000039Subcode: 0x39 FAST_FAIL_CONTROL_INVALID_RETURN_ADDRESS Shadow stack violation</code></pre><p>进一步检查异常，当启用了cet（Control-flow Enforcement Technology，控制流执行技术）时，运行调用指令，两个返回地址被压入栈：一个进入了调用栈，另一个进入影子栈。之后当返回指令运行时，会检查并比较两个返回地址，如果两个地址不匹配，则cp异常就会像之前提到的那样被抛出。但是cet仅在使用call调用指令时起作用，当使用压栈指令将地址压栈时，cet不起作用，因此影子栈中也不存在返回地址。考虑到这一点，推荐使用cfg保护的jmp跳转指令。cfg的行为与cet类似，如果发现了异常，则中止违规进程。如果进程是critical关键进程，抛出0xEF停止码。</p><p>参考链接：</p><p>1.<a href="https://techcommunity.microsoft.com/t5/windows-os-platform-blog/developer-guidance-for-hardware-enforced-stack-protection/ba-p/2163340%EF%BC%9B">https://techcommunity.microsoft.com/t5/windows-os-platform-blog/developer-guidance-for-hardware-enforced-stack-protection/ba-p/2163340；</a></p><p>2.<a href="https://learn.microsoft.com/en-us/windows/win32/secbp/control-flow-guard%EF%BC%9B">https://learn.microsoft.com/en-us/windows/win32/secbp/control-flow-guard；</a></p><p>原文链接：<a href="https://bsodtutorials.wordpress.com/2023/12/09/debugging-stop-0xef-critical_process_died/">https://bsodtutorials.wordpress.com/2023/12/09/debugging-stop-0xef-critical_process_died/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;停止码0xEF出现的可能原因如下：&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="windbg" scheme="https://bbbccvbvv.github.io/tags/windbg/"/>
    
    <category term="停止码0xEF" scheme="https://bbbccvbvv.github.io/tags/%E5%81%9C%E6%AD%A2%E7%A0%810xEF/"/>
    
    <category term="bsod" scheme="https://bbbccvbvv.github.io/tags/bsod/"/>
    
  </entry>
  
  <entry>
    <title>《矛盾论》与《实践论》读后感</title>
    <link href="https://bbbccvbvv.github.io/2024/01/23/on_contraction_on_practice/"/>
    <id>https://bbbccvbvv.github.io/2024/01/23/on_contraction_on_practice/</id>
    <published>2024-01-23T04:56:10.000Z</published>
    <updated>2024-01-23T08:09:06.282Z</updated>
    
    <content type="html"><![CDATA[<p>教员曾经说过：“上了大学，不想和工人划等号了，要作工人贵族。就是普通的工人农民每天也在进步。群众是真正的英雄，而我们却是幼稚可笑的，包括我。”。作为一个经历过大学教育的人，一时间竟不知道该如何自称，读书人或知识分子总感觉是臭老九之类的骂人的话，虽然想自称为劳动者，可是感觉又无法表现出来自己的一些特质（仔细想来除了大学好像也没有什么值得称道的特质了），看来自己还是比较虚伪的，还是需要自我检讨。</p><span id="more"></span><p>作为已经而立之年的90后，我这个人在家里人看来有些不省心，一没房，二没车，更不要说婚姻与家庭了，因此父母总是有些抱怨。本人在闲暇时间也是总在思考，自己当前的生活状态的原因是什么，推到自己的经历与性格肯定是主要原因，但是好像只讲自己的性格又有些片面。人是社会性的人，我自然与父母有不同的时代经历与三观，但是人要考虑自身，同时也需要来考虑其身处的时代。但是如果将一切都推给时代，又颇有些怨天尤人的无能狂怒，好像时代变化了就没有现在的这些问题了。这是有可能的，但是这又是不科学的，事物总在变化发展之中，旧的矛盾消失，新的矛盾出现，妄图通过某一项或多项的举动就能一劳永逸，这是不现实的。因此我就尝试从先哲的思想中学习相关的方法论，以期可以帮助分析自己现在遇到的问题，或者也可以说是逃到知识的海洋里以忘却现实的烦扰。但是需要记住，逃避只是一时，事情总会发展到你逃无可逃的地步，当你对自身有了一定的认知时，就需要结合理论进行实践，否则就只能是一个嘴强王者了。</p><p>选择《矛盾论》与《实践论》的主要原因是我很敬佩教员。90后的青年（貌似40还可以算作青年，我这也不算装嫩了）对于他的态度是不断变化的。就我个人而言，在我出生成长的年代，对于前三十年的否定是社会的主流意识形态，记得小时候看到的书及文章，有揭露cv黑暗的，有展示国军抗日功绩的，当时年少的我对于他的态度是很激烈的，37都不太认同，更是幻想要不是他，说不定提前30年就过上好日子了。仔细想来这种态度确实在我们那一代人里还是比较有市场的，具体问题具体分析、实事求是的态度很多成年人或大人物都无法做到，更何况我们这些小孩子呢。</p><p>孩子大多不具有辨别材料真伪的能力，因此社会的主流意识形态便会不自觉地占领孩子们的大脑，并在很长一段时间内产生影响。但是中国的教育又与其他国家存在区别，虽然中国的教育存在问题，但是像政治课这种统治阶级基础课却是义务教育阶段的必修课，这在其他国家还是很少见的。毕竟不是哪个统治阶级都乐意把血淋淋的现实呈现在人民面前，而人民也往往轻易的放弃了自己的权力，在青少年间普及政治教育更像是一项吃力不讨好的举动。对于统治阶级，人民中头脑清醒的人越多就越不好管，刁民就越多。而对于青少年，枯燥的知识远不如其他学科吸引人，更像是被灌输。可是有趣的是，青少年意识到自己被灌输，意识到自己被统治，这正是开设相关课程的目的所在。</p><p>对于我而言，初中时开设的政治课讲了一些阶级与国家的概念，印象最深的一句就是“国家是阶级统治的工具”，当时年少轻狂，觉得社会存在一些黑暗现象，因此这句话就十分符合个人胃口，可作为对于现实的控诉理由。当时学的阶级、国家、国家暴力机器等等观点，虽然是以灌输式的方法强行记下来的，但是这些观点却在以后的岁月里总是不断浮现，现实教育了自己这些观点的普遍性与泛用性。因此学生期间有多么厌恶思政，进入社会后就多么同意保留这些课程。</p><p>重读在这两篇文章后，突然发现其中的观点大部分都在大学的相关思政课上学过了，《矛盾论》的基本观点在教材上都有，而《实践论》则着重提了理性认识与感性认识，但是却缺失了社会实践的相关描述（也可能是我学的不好，忘记了）。我的学校是一所工科学校，我也是工科专业，本科生的思政课一直持续到了大三，当时的思政课老师我还有些印象，印象最深的自然是她给了我高分（虽然可能是我在之前的课堂活动上有些出风头，强辩而非专业辩论积累了一定的表现分），另外就是她说之前都是工科生治国，当时却有一个她的校友（我们学校隔壁）进入了长老团，因此这可能代表一些社会趋势的变化，但是现在看来变化也不是很大，不是每个文科生都能像教员那样的。</p><p>结合自身的一些经历，发现自己的社会实践主要是生产活动，其他的社会实践好像都没有参与，不知道写博客算不算是文学艺术创作，应该是不算的。而这个生产活动也只是雇佣劳动，并没有掌握生产资料，连高级打工仔都不算，就是底层的码农。7年的时间下来，对于资本主义雇佣劳动关系理解更深了，因此对于某些事物的态度也更为悲观了。不过脾气确实好了很多，也可以认为是被社会打平了棱角，但是总归来说都是自己的选择罢了。记得之前高中毕业时，曾经寄语：不要成为自己厌恶的那些人。可以说做到了，但是也没有成为自己想要成为的那些人，总归来说，还是一个不是那么坏的人，一个不给社会添麻烦的人。</p><p>现实不是文学创作，矛盾与知行的理论也不是教员首先提出，我记得道家就有过一句话：反者，道之动，与矛盾的变化发展观点就有着异曲同工之妙，而王阳明的知行合一也可以看作是认知与实践的一个很好的注解。但是正如后世的道家与心学无法深入贯彻先哲的学说，如今的我在读了教员的理论后，也不见得就可以立即拿来指导生活实践，但是我会努力朝着这个方向实践，分析自己，总结经验，争取成为一个真实的人，一个有用的人，一个热爱劳动的人，一个有益于人民的人。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;教员曾经说过：“上了大学，不想和工人划等号了，要作工人贵族。就是普通的工人农民每天也在进步。群众是真正的英雄，而我们却是幼稚可笑的，包括我。”。作为一个经历过大学教育的人，一时间竟不知道该如何自称，读书人或知识分子总感觉是臭老九之类的骂人的话，虽然想自称为劳动者，可是感觉又无法表现出来自己的一些特质（仔细想来除了大学好像也没有什么值得称道的特质了），看来自己还是比较虚伪的，还是需要自我检讨。&lt;/p&gt;</summary>
    
    
    
    <category term="哲学" scheme="https://bbbccvbvv.github.io/categories/%E5%93%B2%E5%AD%A6/"/>
    
    
    <category term="《矛盾论》" scheme="https://bbbccvbvv.github.io/tags/%E3%80%8A%E7%9F%9B%E7%9B%BE%E8%AE%BA%E3%80%8B/"/>
    
    <category term="《实践论》" scheme="https://bbbccvbvv.github.io/tags/%E3%80%8A%E5%AE%9E%E8%B7%B5%E8%AE%BA%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Windows系统tscon工具概述</title>
    <link href="https://bbbccvbvv.github.io/2023/12/22/windows_tool_tscon/"/>
    <id>https://bbbccvbvv.github.io/2023/12/22/windows_tool_tscon/</id>
    <published>2023-12-22T12:15:41.000Z</published>
    <updated>2024-01-02T13:04:15.607Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到了一个使用tscon工具解决windows远程链接断开后部分应用随之中断的案例，因此对tscon产生了一些好奇，这里就总结一下tscon工具的功能及使用方法。<br>在微软的官方文档上（<a href="https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/tscon">tscon</a>）可以看到该工具的一些描述，因此结合该文档对tscon工具进行描述。</p><span id="more"></span>​<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>该工具用来连接到远程桌面会话主机服务器上的另一个会话。<br>备注：必须拥有“完全控制”访问权限或“连接”特殊访问权限才能连接到另一个会话（即使用该工具的账号需具有较高的权限）</p><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p>Windows server服务器，即Windows Server 2022、Windows Server 2019、Windows Server 2016、Windows Server 2012 R2、Windows Server 2012。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><pre><code>tscon &#123;&lt;sessionID&gt; | &lt;sessionname&gt;&#125; [/dest:&lt;sessionname&gt;] [/password:&lt;pw&gt; | /password:*] [/v]</code></pre><p>参数详解如下：</p><ul><li><sessionID>：指定要连接到的会话的 ID。 如果你使用可选的 &#x2F;dest:<sessionname> 参数，则还可以指定当前会话的名称。</li><li><sessionname>：指定要连接到的会话的名称</li><li>&#x2F;dest:<sessionname>：指定当前会话的名称。 连接到新会话时，此会话将断开连接。 还可以使用此参数将其他用户的会话连接到一个不同的会话。</li><li>&#x2F;password:<pw>：指定拥有你要连接到的会话的用户的密码。 当进行连接的用户不拥有会话时，需要提供此密码。</li><li>&#x2F;password:*：提示输入拥有你要连接到的会话的用户的密码。</li><li>&#x2F;v：显示有关正在执行的操作的信息。</li><li>&#x2F;?：在命令提示符下显示帮助。</li></ul><p>备注：<br>（1）如果未在 &#x2F;password 参数中指定密码，并且目标会话属于当前用户以外的用户，则此命令将失败。<br>（2）你无法连接到控制台会话。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>（1）若要连接到当前远程桌面服务会话主机服务器上的会话 12，并断开当前会话的连接，请键入：</p><pre><code>tscon 12</code></pre><p>(2)若要使用密码 mypass 连接到当前远程桌面服务会话主机服务器上的会话 23，并断开当前会话的连接，请键入：</p><pre><code>tscon 23 /password:mypass</code></pre><p>（3）若要将名为 TERM03 的会话连接到名为 TERM05 的会话，然后断开会话 TERM05 的连接，请键入：</p><pre><code>tscon TERM03 /v /dest:TERM05</code></pre><h2 id="复杂脚本分析"><a href="#复杂脚本分析" class="headerlink" title="复杂脚本分析"></a>复杂脚本分析</h2><p>当使用远程桌面连接到远程计算机时，关闭远程桌面将会锁定计算机并显示登录界面，在锁定模式下，计算机不会有GUI图形界面，因此所有正在运行和即将调度的GUI任务都会失败。<br>为避免GUI任务失败，可以使用tscon组件实现从远程桌面断开连接，tscon会把控制权返还给远程计算机上的原始本地会话，这样就绕过了登录界面。远程计算机上的全部程序（包含GUI图形任务在内）都会继续正常运行。</p><pre><code>for /f &quot;skip=1 tokens=3&quot; %%s in (&#39;query user %USERNAME%&#39;) do (%windir%\System32\tscon.exe %%s /dest:console)</code></pre><p>该脚本的运行逻辑如下：<br>1.查询以用户名%USERNAME%登录的全部会话；<br>2.使用”skip&#x3D;1 tokens&#x3D;3”语法过滤掉查询结果的首行（标题行），并选取第3列（session ID）作为输出值；<br>3.遍历筛选过的全部会话id，使用tscon将会话的控制钱返还给计算机上的原始本地会话（console），依此实现断开连接，但是绕过登录界面，保持会话内的全部任务可以后续继续执行；</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>1.<a href="https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/tscon%EF%BC%9B">https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/tscon；</a><br>2.<a href="https://support.smartbear.com/testcomplete/docs/testing-with/running/via-rdp/keeping-computer-unlocked.html%EF%BC%9B">https://support.smartbear.com/testcomplete/docs/testing-with/running/via-rdp/keeping-computer-unlocked.html；</a><br>3.<a href="https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/for%EF%BC%9B">https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/for；</a><br>4.<a href="https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/query-user%EF%BC%9B">https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/query-user；</a><br>​</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近看到了一个使用tscon工具解决windows远程链接断开后部分应用随之中断的案例，因此对tscon产生了一些好奇，这里就总结一下tscon工具的功能及使用方法。&lt;br&gt;在微软的官方文档上（&lt;a href=&quot;https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/tscon&quot;&gt;tscon&lt;/a&gt;）可以看到该工具的一些描述，因此结合该文档对tscon工具进行描述。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="tscon" scheme="https://bbbccvbvv.github.io/tags/tscon/"/>
    
    <category term="windows会话" scheme="https://bbbccvbvv.github.io/tags/windows%E4%BC%9A%E8%AF%9D/"/>
    
    <category term="微软官方工具" scheme="https://bbbccvbvv.github.io/tags/%E5%BE%AE%E8%BD%AF%E5%AE%98%E6%96%B9%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>windbg标准调试技巧-读写内存（5）：将虚拟地址转换为物理地址</title>
    <link href="https://bbbccvbvv.github.io/2023/08/07/windbg_debug_technique_reading_and_writing_memory_5/"/>
    <id>https://bbbccvbvv.github.io/2023/08/07/windbg_debug_technique_reading_and_writing_memory_5/</id>
    <published>2023-08-07T10:30:00.000Z</published>
    <updated>2023-12-29T02:38:41.469Z</updated>
    
    <content type="html"><![CDATA[<p>大多数调试器命令都是用虚拟地址而非物理地址作为输出及输出参数。然而，也同时存在物理地址起作用的场景。</p><span id="more"></span><p>这里有两种方式将虚拟地址转换为物理地址：使用!vtop扩展或使用!pte扩展。</p><p>#1 使用!vtop进行地址转换</p><ol><li><p>确保在16禁止之下进行操作。如果必要的话，通过N 16指令设置当前环境为16进制；</p></li><li><p>确定地址的字节索引。该数字等同于虚拟地址的低12位。因此，虚拟地址0x0012f980的字节索引为0x980；</p></li><li><p>通过使用!process扩展确定地址的字典进制：</p><pre><code> kd&gt; !process 0 0 **** NT ACTIVE PROCESS DUMP **** .... PROCESS ff779190  SessionId: 0  Cid: 04fcPeb: 7ffdf000  ParentCid: 0394 DirBase: 098fd000  ObjectTable: e1646b30 TableSize:   8. Image: MyApp.exe</code></pre></li><li><p>决定目录基址的页框号。这只是没有三个尾随十六进制零的目录基址。在本例中，目录基址为0x098FD000，因此页框号为0x098FD。</p></li><li><p>使用!vtop扩展。该扩展的第一个参数是页框号。!vtop的第二个参数就是问题中的虚拟地址：</p><p> kd&gt; !vtop 98fd 12f980<br> Pdi 0 Pti 12f<br> 0012f980 09de9000 pfn(09de9)</p></li></ol><p>最后一行中展示的第二个数字是物理页的起始物理地址。</p><ol start="6"><li>在页的开始出加上地址的字节索引：0x09DE9000 + 0x980 &#x3D; 0x09DE9980。这就是目标物理地址。</li></ol><p>也可以通过显示每个地址的内存来验证此计算是否正确完成。!d*扩展显示指定物理地址处的内存：</p><pre><code>kd&gt; !dc 9de9980# 9de9980 6d206e49 726f6d65 00120079 0012f9f4 In memory.......# 9de9990 0012f9f8 77e57119 77e8e618 ffffffff .....q.w...w....# 9de99a0 77e727e0 77f6f13e 77f747e0 ffffffff .&#39;.w&gt;..w.G.w....# 9de99b0 .....</code></pre><p>d*（展示内存）质量使用虚拟地址作为其参数：</p><pre><code>kd&gt; dc 12f9800012f980  6d206e49 726f6d65 00120079 0012f9f4  In memory.......0012f990  0012f9f8 77e57119 77e8e618 ffffffff  .....q.w...w....0012f9a0  77e727e0 77f6f13e 77f747e0 ffffffff  .&#39;.w&gt;..w.G.w....0012f9b0  .....</code></pre><p>因为结果相同，这就表明物理地址0x09DE9980确实代表了虚拟地址0x0012F980。</p><p>#2 使用!pte进行地址转换</p><p>假设客户正在调查属于MyApp.exe进程的虚拟地址0x0012F980。在使用!pte扩展指令获取其对应的物理地址过程中，操作如下：</p><ol><li><p>确保子啊16进制下进行运算。如果有必要，通过N 16指令设置当前环境为16进制；</p></li><li><p>获取地址的字节索引。该数字等同于虚拟地址的低12位。因此，虚拟地址0x0012f980的字节索引为0x980；</p></li><li><p>将进程上下文环境设置到目标进程中：</p><pre><code> kd&gt; !process 0 0 **** NT ACTIVE PROCESS DUMP **** .... PROCESS ff779190  SessionId: 0  Cid: 04fcPeb: 7ffdf000  ParentCid: 0394 DirBase: 098fd000  ObjectTable: e1646b30  TableSize:   8. Image: MyApp.exe  kd&gt; .process /p ff779190 Implicit process is now ff779190 .cache forcedecodeuser done</code></pre></li><li><p>使用!pte指令时以虚拟地址作为参数。输出信息以两列形式展示出来。左边的一列描述了地址对应的页目录条目（page directory entry，pe），右边列展示了页表条目（page table entry，pte）：</p><pre><code> kd&gt; !pte 12f980    VA 0012f980 PDE at   C0300000PTE at C00004BC contains 0BA58067  contains 09DE9067 pfn ba58 ---DA--UWVpfn 9de9 ---DA--UWV</code></pre></li><li><p>查看右边列的最后一行。符号”pfn 9de9”出现了。pte的页框号（page frame number，pfn）是0x9de9.页框号乘以0x1000（例如，左移12位）。结果0x09DE9000就是内存也的起始物理地址；</p></li><li><p>在页的开始出加上地址的字节索引：0x09DE9000 + 0x980 &#x3D; 0x09DE9980。这就是目标物理地址；</p></li></ol><p>与之前的方法得到了相同的结果。</p><p>#3 手动进行地址转换</p><p>尽管!ptov和pte指令提供了将虚拟地址转换为物理地址的最快方式，但是也可以人工完成这一转换过程。对该过程的描述将阐明虚拟内存体系结构的一些细节。</p><p>内存结构因其处理器和硬件配置的不同而会在大小方面发生变化。例子来源于一个没有启用物理地址扩展（physical address extension，pae）功能的x86系统。</p><p>使用0x0012F980作为虚拟地址，首先需要将该地址转换为2进制，可以手动转换，也可以使用.formats（dhow number formats，展示数字格式）指令实现：</p><pre><code>kd&gt; .formats 12f980Evaluate expression:  Hex:     0012f980  Decimal: 1243520  Octal:   00004574600  Binary:  00000000 00010010 11111001 10000000  Chars:   ....  Time:    Thu Jan 15 01:25:20 1970  Float:   low 1.74254e-039 high 0  Double:  6.14381e-318</code></pre><p>虚拟地址有3个字段组成。第0位到第11位是字节索引。第12位到第21位是页表索引。第22位到第31位是页目录索引。将对应字段进行拆分，实现如下：</p><pre><code>0x0012F980  =  0y  00000000 00   010010 1111   1001 10000000</code></pre><p>导出虚拟地址的3个字段：</p><ul><li>页目录索引&#x3D;0y0000000000&#x3D;0x0</li><li>页表索引&#x3D;0y0100101111&#x3D;0x12F</li><li>字节索引&#x3D;0y100110000000&#x3D;0x980</li></ul><p>之后系统需要3个额外的信息：</p><ul><li>每一个pte的大小。在非pae x86系统中是4个字节。</li><li>页大小。是0x1000字节。</li><li>PTE_BASE虚拟地址。在非pae系统中，是0xC0000000.</li></ul><p>使用这些数据，可以计算pte自身的地址：</p><pre><code>PTE address   =   PTE_BASE                  + (page directory index) * PAGE_SIZE                + (page table index) * sizeof(MMPTE)    =   0xc0000000                + 0x0   * 0x1000                + 0x12F * 4              =   0xC00004BC</code></pre><p>这就是pte的地址。pte是一个32位的双字变量。其内容如下：</p><pre><code>kd&gt; dd 0xc00004bc L1c00004bc  09de9067</code></pre><p>pte数值是0x09DE9067。其由两个字段组成。</p><ul><li>pte的低12位是状态标志（status flags）。在这种情况下，这些标志位等于0x067–或者二进制的0y000001100111.对于状态标志位的解释，可以查看!pte指令参考页。</li><li>pte的高20位等于pte的页框号pfn。在这种情况下，pfn是0x09DE9.</li></ul><p>物理页上的第一个物理地址是pfn乘以0x1000（即左移12位）。字节索引就是页上的偏移。因此，查找的物理地址就是0x09DE9000+0x980&#x3D;0x09DE9980。与之前的计算方式获取的结果一致。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大多数调试器命令都是用虚拟地址而非物理地址作为输出及输出参数。然而，也同时存在物理地址起作用的场景。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="windbg官方文档翻译" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/windbg%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="windbg" scheme="https://bbbccvbvv.github.io/tags/windbg/"/>
    
    <category term="convert virtual address to physical address" scheme="https://bbbccvbvv.github.io/tags/convert-virtual-address-to-physical-address/"/>
    
  </entry>
  
  <entry>
    <title>windbg标准调试技巧-读写内存（4）：访问局部变量</title>
    <link href="https://bbbccvbvv.github.io/2023/08/07/windbg_debug_technique_reading_and_writing_memory_4/"/>
    <id>https://bbbccvbvv.github.io/2023/08/07/windbg_debug_technique_reading_and_writing_memory_4/</id>
    <published>2023-08-07T10:20:00.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>与全局变量相同，局部变量也存储于符号文件中。更加一致的是，调试器也将局部变量的名称解释为地址。可以安装与全局变量相同的方式进行读写操作。但是，如果需要向命令指定某个符号是本地符号，请在符号前面添加美元符号($)和感叹号(!)，例如$!var。</p><span id="more"></span><p>Visual Studio和WinDbg提供了使用者可以使用（附加到命令上）的用户接口元素查看和编辑全局变量。可以参考《在Visual Studio查看和编辑内存及寄存器》和《在WinDbg查看和编辑全局变量》两章。</p><p>除此之外，也可以使用如下的方式展示、修改及使用局部变量：</p><ul><li>dv（展示局部变量display local variable）命令展示了全部局部变量的名称和数值。</li><li>!for_each_local扩展使得使用者可以重复运行一条指令，每一个针对一个局部变量。</li></ul><p>然而，在局部变量与全局变量之间还存在着一个主要的不同之处。应用程序运行时，局部变量的含义依赖于程序计数器的位置，因为局部变量的作用于仅仅局限于被定义的函数内部。</p><p>调试器依据局部上下文（local context）环境解释局部变量。默认情况下，该上下文与程序计数器的位置相匹配。但是调试器也可以改变上下文。想获取更多与局部上下文相关的信息可以参考《局部上下文》章节。</p><p>当局部上下文环境改变后，局部窗口（local window）立即更新以反应局部变量的新集合。dv命令也展示了新的变量。所有的这些变量名称通过之前描述的内存指令被正确解释。用户可以读写这些变量。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;与全局变量相同，局部变量也存储于符号文件中。更加一致的是，调试器也将局部变量的名称解释为地址。可以安装与全局变量相同的方式进行读写操作。但是，如果需要向命令指定某个符号是本地符号，请在符号前面添加美元符号($)和感叹号(!)，例如$!var。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="windbg官方文档翻译" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/windbg%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="windbg" scheme="https://bbbccvbvv.github.io/tags/windbg/"/>
    
    <category term="access local variables" scheme="https://bbbccvbvv.github.io/tags/access-local-variables/"/>
    
  </entry>
  
  <entry>
    <title>windbg标准调试技巧-读写内存（3）：访问全局变量</title>
    <link href="https://bbbccvbvv.github.io/2023/08/04/windbg_debug_technique_reading_and_writing_memory_3/"/>
    <id>https://bbbccvbvv.github.io/2023/08/04/windbg_debug_technique_reading_and_writing_memory_3/</id>
    <published>2023-08-04T11:30:00.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>全局变量的名称存储在应用程序编译时创建的符号文件中。调试器将全局变量的名称解释为一个虚拟地址。任何接受地址作为参数的命令都可以接受变量名称作为参数。因此，可以使用在之前的《通过虚拟地址访问内存》章节中描述的全部指令读写全局变量。</p><span id="more"></span><p>除此之外，也可以使用?（计算表达式evaluate expression）指令展示与符号相关的地址。</p><p>Visual Studio和WinDbg提供了使用者可以使用（附加到命令上）的用户接口元素查看和编辑全局变量。可以参考《在Visual Studio查看和编辑内存及寄存器》和《在WinDbg查看和编辑全局变量》两章。</p><p>思考下面的例子。假设用户想要检查一个32位整数类型的全局变量MyCounter，同时假设默认进制是10进制。</p><p>也可以获取变量地址并展示如下：</p><pre><code> 0:000&gt; ? MyCounter Evaluate expression: 1244892 = 0012fedc0:000&gt; dd 0x0012fedc L1 0012fedc  00000052</code></pre><p>第一条命令输出告诉使用者MyCounter的地址是0x0012FEDC。也可以使用d*（展示内存display memory）命令在这个地址上展示一个双字（也可以使用1244892，即该地址的十进制版本，然而，多数c语言程序员更倾向于使用0x0012FEDC）。第二条指令告诉使用者MyCounter的数值是0x52（即十进制下的82）.</p><p>也可以使用如下指令实现上述过程</p><pre><code>0:000&gt; dd MyCounter L1 0012fedc  00000052</code></pre><p>可使用如下指令将MyCounter的数值改为十进制的83.</p><pre><code>0:000&gt; ed MyCounter 83 </code></pre><p>这个示例使用了十进制输入，因为十进制格式对于一个整数来说更加自然。<br>然而，d*命令的输出仍然是以16进制格式展示的。</p><pre><code>0:000&gt; dd MyCounter L1 0012fedc  00000053</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;全局变量的名称存储在应用程序编译时创建的符号文件中。调试器将全局变量的名称解释为一个虚拟地址。任何接受地址作为参数的命令都可以接受变量名称作为参数。因此，可以使用在之前的《通过虚拟地址访问内存》章节中描述的全部指令读写全局变量。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="windbg官方文档翻译" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/windbg%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="windbg" scheme="https://bbbccvbvv.github.io/tags/windbg/"/>
    
    <category term="access global variables" scheme="https://bbbccvbvv.github.io/tags/access-global-variables/"/>
    
  </entry>
  
  <entry>
    <title>windbg标准调试技巧-读写内存（2）：通过物理地址访问内存</title>
    <link href="https://bbbccvbvv.github.io/2023/08/03/windbg_debug_technique_reading_and_writing_memory_2/"/>
    <id>https://bbbccvbvv.github.io/2023/08/03/windbg_debug_technique_reading_and_writing_memory_2/</id>
    <published>2023-08-03T12:30:00.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>为了从物理地址中读取参数，可以使用!db、!dc、!dd、!dp、!du和!dw等扩展命令。</p><p>向物理地址中写入数据，可以使用!eb和!ed扩展命令。</p><p>fp（fill physical memory填充物理内存）指令向物理内存范围内写入了模板值，不停重复，知道内存被完全填充。</p><p>当在内核模式中使用windbg时，可以在windbg的内存窗口中直接进行物理内存的读写操作。</p><p>要在物理内存中搜索一段数据或一系列数据，请使用 !search 扩展命令。</p><p>想要查看更多与物理地址相关的信息，可以查看转换虚拟地址到物理地址这一章节。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为了从物理地址中读取参数，可以使用!db、!dc、!dd、!dp、!du和!dw等扩展命令。&lt;/p&gt;
&lt;p&gt;向物理地址中写入数据，可以使用!eb和!ed扩展命令。&lt;/p&gt;
&lt;p&gt;fp（fill physical memory填充物理内存）指令向物理内存范围内写入了模板值，不</summary>
      
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="windbg官方文档翻译" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/windbg%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="windows" scheme="https://bbbccvbvv.github.io/tags/windows/"/>
    
    <category term="windbg" scheme="https://bbbccvbvv.github.io/tags/windbg/"/>
    
    <category term="standard debugging techniques" scheme="https://bbbccvbvv.github.io/tags/standard-debugging-techniques/"/>
    
    <category term="reading and writng memory" scheme="https://bbbccvbvv.github.io/tags/reading-and-writng-memory/"/>
    
    <category term="physical address" scheme="https://bbbccvbvv.github.io/tags/physical-address/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】OpenSSL环境变量OPENSSL_ia32cap详解</title>
    <link href="https://bbbccvbvv.github.io/2023/07/24/openssl_env_variable_openssl_ia32cap/"/>
    <id>https://bbbccvbvv.github.io/2023/07/24/openssl_env_variable_openssl_ia32cap/</id>
    <published>2023-07-24T03:30:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-名称"><a href="#1-名称" class="headerlink" title="1 名称"></a>1 名称</h1><p>OPENSSL_ia32cap：x86[_64]架构处理器能力向量（processor capabilities vector）</p><span id="more"></span><h1 id="2-概要"><a href="#2-概要" class="headerlink" title="2 概要"></a>2 概要</h1><pre><code>env OPENSSL_ia32cap=... &lt;application&gt;</code></pre><h1 id="3-描述"><a href="#3-描述" class="headerlink" title="3 描述"></a>3 描述</h1><p>OpenSSL支持一系列的x86[_64]指令集扩展。在以EAX&#x3D;1作为输入值运行CPUID指令之后，这些扩展由处理器返回的位于EDX:ECX寄存器对能力向量的各个位表示（详情可参考Intel Application Note #241618）。这些向量在工具包初始化时被复制到内存中，被用来选择不同的代码路径以在一系列处理器之间提供最佳性能。在撰写本文时，以下位很重要：</p><ul><li>第4位：表示时间戳计数器（Time-Stamp Counter）的存在；</li><li>第19位：表示CLFLUSH（flush cache line缓存线清除操作码指令）指令可用；</li><li>第20位：由Intel保留，用于在RC4代码路径中进行选择；</li><li>第23位：表示MMX（Multi Media eXtension，多媒体扩展指令集）支持；</li><li>第24位：FXSR（FidelityFX™ Super Resolution）位，表示支持XMM寄存器；</li><li>第25位：表示支持SSE（streaming simd extensions流式单指令多数据扩展）；</li><li>第26位：表示支持SSE2；</li><li>第28位：支持超线程（Hyperthreading），用于区分具有共享缓存的核心；</li><li>第30位：由 Intel 保留，特指 Intel CPU；</li><li>第33位：表明可以使用PCLMULQDQ（Carry-Less Multiplication Quadword，是对两个GF(2^128)域上的多项式相乘）指令；</li><li>第41位：表明支持SSSE3和补充SSE3；</li><li>第43位：表明支持AMD XOP（非AMD cpu上强制设置为0）；</li><li>第54位：表明支持MOVBE（复制源操作数的数据，交换字节后，移动数据）指令；</li><li>第57位：表明支持AES-NI指令集（高级加密标准指令集，或称英特尔高级加密标准新指令，目的是改进应用程序使用高级加密标准（AES）执行加密和解密的速度）扩展；</li><li>第58位：XSAVE位，缺少该位与MOVBE结合用于识别Atom Silvermont 核心；</li><li>第59位：OSXSAVE位，表明支持YMM寄存器；</li><li>第60位：表明支持AVX（X86指令集的SSE延伸架构）扩展；</li><li>第62位：表明支持RDRAND（用于从芯片上的硬件随机数生成器中获取随机数）指令；</li></ul><p>例如，在32位应用程序上下文环境中将第26位清0，则在运行时会禁用crypto库里的高性能SSE2代码，将第24位清0将会禁用SSE2代码操作128位MMX寄存器组。如果目标OpenSSL应用程序运行在SSE2兼容的cpu上，但是操作系统却没有启用XMM寄存器，则必须执行后者将第24位清0。一般情况下，功能向量的地址通过OPENSSL_ia32cap_loc()函数暴露给应用程序，但并非全部情况下都是如此。现在唯一可以影响功能检测的方法就是在目标程序启动前，设置OPENSSL_ia32cap环境变量。例如，在Intel P4处理器中，设置env OPENSSL_ia32cap&#x3D;0x16980010 apps&#x2F;openssl，或者设置env OPENSSL_ia32cap&#x3D;~0x1000000 apps&#x2F;openssl都可以取得预期的效果。也可以重新配置no-sse2选项，并重新编译工具包。</p><p>不太直观的就是将第28位清零，或者在环境变量中设置为~0x10000000。事实是，它不是从CPUID输出逐字复制的，而是经过调整以反映数据缓存是否实际上在逻辑核心之间共享。这反过来又会影响是否应用针对缓存定时攻击的昂贵对策的决定，尤其是在AES汇编器模块中。</p><p>通过以EAX&#x3D;7和ECX&#x3D;0作为输入值获取CPUID返回的EBX数值，功能向量可以进一步扩展。下面的位很重要：</p><ul><li>第64+3位：表明支持BMI1（Bit Manipulation Instructions位操作指令）指令，例如ANDN（第一源操作数取反后与第二源操作数按位与操作，结果保存在目标操作数中）；</li><li>第64+5位：表明支持AVX2指令；</li><li>第64+8位：表明支持BMI2指令，如MULX和RORX；</li><li>第64+16位：表明支持AVX512F扩展；</li><li>第64+17位：表明支持AVX512DQ扩展；</li><li>第64+18位：表明支持RDSEED指令；</li><li>第64+19位：表明支持ADCX和ADOX指令；</li><li>第64+21位：表明支持VPMADD52[LH]UQ指令，又名AVX512IFMA扩展；</li><li>第64+29位：表明支持SHA扩展；</li><li>第64+30位：表明支持AVX512BW扩展；</li><li>第64+31位：表明支持AVX512VL扩展；</li><li>第64+41位：表明支持VAES扩展；</li><li>第64+42位：表明支持VPCLMULQDQ扩展；</li></ul><p>要控制此扩展功能，请在设置OPENSSL_ia32cap环境变量时使用:作为分隔符。例如，分配:~0x20将禁用AVX2代码路径，而:0-禁用所有后AVX扩展。</p><h1 id="4-返回值"><a href="#4-返回值" class="headerlink" title="4 返回值"></a>4 返回值</h1><p>不可用</p><p>原文地址：<a href="https://www.openssl.org/docs/man3.1/man3/OPENSSL_ia32cap.html" title="OPENSSL_ia32cap">https://www.openssl.org/docs/man3.1/man3/OPENSSL_ia32cap.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-名称&quot;&gt;&lt;a href=&quot;#1-名称&quot; class=&quot;headerlink&quot; title=&quot;1 名称&quot;&gt;&lt;/a&gt;1 名称&lt;/h1&gt;&lt;p&gt;OPENSSL_ia32cap：x86[_64]架构处理器能力向量（processor capabilities vector）&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="OpenSSL" scheme="https://bbbccvbvv.github.io/tags/OpenSSL/"/>
    
    <category term="OPENSSL_ia32cap" scheme="https://bbbccvbvv.github.io/tags/OPENSSL-ia32cap/"/>
    
  </entry>
  
  <entry>
    <title>windbg标准调试技巧-读写内存（1）：通过虚拟地址访问内存</title>
    <link href="https://bbbccvbvv.github.io/2023/07/19/windbg_debug_technique_reading_and_writing_memory_1/"/>
    <id>https://bbbccvbvv.github.io/2023/07/19/windbg_debug_technique_reading_and_writing_memory_1/</id>
    <published>2023-07-19T11:30:00.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>在调试过程中可以通过使用多个指令来访问内存或内存区域。visual studio和windbg提供命令行命令时，也提供了用户图形界面，用户可以用图形界面来查看和编辑内存。详情可以参考windbg帮助文档中的在visual studio中查看和编辑内存和寄存器，以及在windbg中查看和编辑内存两个章节。</p><span id="more"></span><p>以下命令可以读取与写入多种格式的内存。这些屙屎包含了16字节、字格式（单字、双字、四字、八字格式）、整数格式（short、long、quad、unsigned格式）、浮点数格式（10字节、16字节、32字节、64字节实数格式）以及ascii字符格式。</p><ul><li>d*（展示内存display memory）指令会展示特定内存或内驱区域的内容。</li><li>e*（输入数值enter values）指令向特定的内存地址写入数值。</li></ul><p>也可以使用如下指令处理更加特定的数据类型：</p><ul><li>dt（展示类型display type）指令会检索多种数据类型并展示被当前正在调试的应用程序锁创建出来的数据结构。改名了用途广泛并拥有多种变体及可选配置项。</li><li>ds（展示字符串display string）指令展示了STRING、ANSI_STRING和UNICODE_STRING数据结构。</li><li>dl（展示链表display linked list）指令追踪并展示链表。</li><li>d*s（展示字格式和符号display words and symbols）指令检索可能包含符号信息的双字或四字结构，之后展示对应的数据及符号信息。</li><li>!address扩展指令展示位于特定地址的内存属性信息。</li></ul><p>可以使用如下指令来进行内存范围操作：</p><ul><li>m（移动内存move memory）指令将一个内存范围的内容移到另外一个中。</li><li>f（填充内存fill mempry）指令向内存范围中写入指定的样式，后续重复该操作直到内存范围被全部填满。</li><li>c（比较内存compare memory）指令比较两个内存范围的内容；</li><li>s（搜索内存search memory）指令在一个内存范围内搜索指定格式的内容、或者搜索内存范围内的任一ascii或unicode编码；</li><li>.holdmem（保存并比较内存hold and compare memory）指令将一个内存范围与另外一个进行比较。</li></ul><p>在大多数场景下，这些命令以当前的进制解释其参数。因此，如果当前的进制不是16，那么需要在16进制地址前增加0x表示其为16进制。然而，命令的展示输出通常是16进制的，不按照当前进制进行展示。内存窗口以10进制展示了整数与实数以16进制展示其他类型的参数。</p><p>可使用n（设置数字基数set number base）指令改变默认的进制。为快速将数字由一个进制转换为另外一个进制，可使用？（计算表达式evaluate expression）指令或者.format（展示数字格式show number formats）指令。</p><p>当进行用户模式调试时，虚拟地址的含义是当前进程决定的。当你进行内核模式调试时，虚拟地址的含义可以被调试器控制。更多内容，可参考进程上下文（process context）章节。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在调试过程中可以通过使用多个指令来访问内存或内存区域。visual studio和windbg提供命令行命令时，也提供了用户图形界面，用户可以用图形界面来查看和编辑内存。详情可以参考windbg帮助文档中的在visual studio中查看和编辑内存和寄存器，以及在windbg中查看和编辑内存两个章节。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="windbg官方文档翻译" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/windbg%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="windows" scheme="https://bbbccvbvv.github.io/tags/windows/"/>
    
    <category term="windbg" scheme="https://bbbccvbvv.github.io/tags/windbg/"/>
    
    <category term="standard debugging techniques" scheme="https://bbbccvbvv.github.io/tags/standard-debugging-techniques/"/>
    
    <category term="reading and writng memory" scheme="https://bbbccvbvv.github.io/tags/reading-and-writng-memory/"/>
    
    <category term="virtual address" scheme="https://bbbccvbvv.github.io/tags/virtual-address/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】libvirt虚拟机xml配置文件格式（9）CPU model and topology</title>
    <link href="https://bbbccvbvv.github.io/2022/11/15/domain_xml_format9_cpu_model_topology/"/>
    <id>https://bbbccvbvv.github.io/2022/11/15/domain_xml_format9_cpu_model_topology/</id>
    <published>2022-11-15T10:10:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>原文网址：<a href="https://libvirt.org/formatdomain.html#id8" title="Domain XML format">https://libvirt.org/formatdomain.html#id8</a></p><span id="more"></span><h1 id="NUMA-Node-Tuning"><a href="#NUMA-Node-Tuning" class="headerlink" title="NUMA Node Tuning"></a>NUMA Node Tuning</h1><pre><code>&lt;domain&gt;  ...  &lt;numatune&gt;    &lt;memory mode=&quot;strict&quot; nodeset=&quot;1-4,^3&quot;/&gt;    &lt;memnode cellid=&quot;0&quot; mode=&quot;strict&quot; nodeset=&quot;1&quot;/&gt;    &lt;memnode cellid=&quot;2&quot; mode=&quot;preferred&quot; nodeset=&quot;2&quot;/&gt;  &lt;/numatune&gt;  ...&lt;/domain&gt;</code></pre><h2 id="numatune"><a href="#numatune" class="headerlink" title="numatune"></a>numatune</h2><p>可选元素项numatune提供了如何通过控制虚拟机进程的NUMA策略对NUMA主机的性能进行调度。注意，仅支持QEMU。自0.9.3起。</p><h2 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h2><p>可选元素项memory指明了如何对NUMA主机的虚拟机进程进行内存分配。其包含多个可选属性项。属性项mode的可用值包含interleave、strict、preferred和restrictive，默认设置为strict。restrictive指明使用系统默认策略，仅有cgroups被用来限制内存节点，在memnode元素中将mode设置为restrictive。属性项nodeset指明了numa节点，其与vcpu元素项的cpuset属性项使用相同的语法。属性项placement（自0.9.12起）可被用来表明虚拟机进程的内存放置模式，其值可以为static或auto，是vcpu的placement的默认值，如果指定了nodeset则默认值为static。auto表明虚拟机进程只会从查询numad返回的咨询节点中集中分配内存，属性nodeset的值在指定auto的情况下将会被忽略。如果vcpu的placement设置为auto，且numatune未指定，则numatune的placement设置为auto，mode设置为strict。自0.9.3起。参阅 virDomainSetNumaParameters获取该元素的更多信息。</p><h2 id="memnode"><a href="#memnode" class="headerlink" title="memnode"></a>memnode</h2><p>可选元素项memnode可以为每个虚拟机的numa节点指定内存分配策略。对于没有memnode元素的哪些节点，memory元素的默认值将会被使用。属性项cellid寻址应用设置的虚拟机NUMA节点。属性项mode和nodeset与memory元素中的对应值具有相同的含义和语法。设置与自动placement不兼容。qemu自1.2.7起。</p><h1 id="Block-I-x2F-O-Tuning"><a href="#Block-I-x2F-O-Tuning" class="headerlink" title="Block I&#x2F;O Tuning"></a>Block I&#x2F;O Tuning</h1><pre><code>&lt;domain&gt;  ...  &lt;blkiotune&gt;    &lt;weight&gt;800&lt;/weight&gt;    &lt;device&gt;      &lt;path&gt;/dev/sda&lt;/path&gt;      &lt;weight&gt;1000&lt;/weight&gt;    &lt;/device&gt;    &lt;device&gt;      &lt;path&gt;/dev/sdb&lt;/path&gt;      &lt;weight&gt;500&lt;/weight&gt;      &lt;read_bytes_sec&gt;10000&lt;/read_bytes_sec&gt;      &lt;write_bytes_sec&gt;10000&lt;/write_bytes_sec&gt;      &lt;read_iops_sec&gt;20000&lt;/read_iops_sec&gt;      &lt;write_iops_sec&gt;20000&lt;/write_iops_sec&gt;    &lt;/device&gt;  &lt;/blkiotune&gt;  ...&lt;/domain&gt;</code></pre><h2 id="blkiotune"><a href="#blkiotune" class="headerlink" title="blkiotune"></a>blkiotune</h2><p>可选元素项blkiotune为虚拟机提供了调节Blkio cgroup可调参数的能力。如果忽略该设置项，则其默认由操作系统提供。自0.8.8起。</p><h2 id="weight"><a href="#weight" class="headerlink" title="weight"></a>weight</h2><p>可选元素项weight是虚拟机的全部i&#x2F;o负载。该值的范围是100-1000.在2.6.39内核后，该值的范围是10-1000.</p><h2 id="device"><a href="#device" class="headerlink" title="device"></a>device</h2><p>虚拟机可能又有多个device元素项，以便深入调节虚拟机正在使用的每一个主机块设备的权重。注意多个磁盘（可参阅Hard drives, floppy disks, CDROMs章节）可能共享同一个主机块设备，如果他们被相同的主机文件系统中的文件备份，这也是为什么使用全局作用域的调节参数而非相关的每一个虚拟机磁盘设备的原因（与磁盘定义中的iotune元素项相反（可参阅Hard drives, floppy disks, CDROMs章节），而iotune元素项适用于单个独立的磁盘）。每一个device元素项有两个强制的子元素项，path描述了设备的绝对路径，而weight给出了设备的相对权重，权重范围是100-1000.在2.6.39版本内核之后，该值的范围变为10-1000.自0.9.8起。除此之外，也可使用如下的可选子元素项：</p><h3 id="read-bytes-sec"><a href="#read-bytes-sec" class="headerlink" title="read_bytes_sec"></a>read_bytes_sec</h3><p>以字节为单位的每秒可读吞吐量。自1.2.2起。</p><h3 id="write-bytes-sec"><a href="#write-bytes-sec" class="headerlink" title="write_bytes_sec"></a>write_bytes_sec</h3><p>以字节为单位的每秒可写吞吐量。自1.2.2起。</p><h3 id="read-iops-sec"><a href="#read-iops-sec" class="headerlink" title="read_iops_sec"></a>read_iops_sec</h3><p>每秒i&#x2F;o读操作限制。自1.2.2起。</p><h3 id="write-iops-sec"><a href="#write-iops-sec" class="headerlink" title="write_iops_sec"></a>write_iops_sec</h3><p>每秒i&#x2F;o写操作限制。自1.2.2起。</p><h1 id="Resource-partitioning"><a href="#Resource-partitioning" class="headerlink" title="Resource partitioning"></a>Resource partitioning</h1><p>虚拟机管理程序可能允许将虚拟机放入资源分区，也可能嵌套所述分区。resource元素将与资源分区相关的配置项组织在一起。当前其支持partition子元素项，该子元素项的内容定义了放置虚拟机的资源分区的绝对路径。如果没有列出任何分区，虚拟机将会被放到默认分区中。应用程序或管理员有责任确保分区在虚拟机启动之前就已存在。只有默认分区（适用于特定虚拟机管理程序）可以默认假定已经存在。</p><pre><code>...&lt;resource&gt;  &lt;partition&gt;/virtualmachines/production&lt;/partition&gt;&lt;/resource&gt;...</code></pre><p>资源分区当前在qemu和lxc中受到支持，在所有已安装的控制器中将分区路径映射到cgroups目录。自1.0.5起。</p><h1 id="Fibre-Channel-VMID"><a href="#Fibre-Channel-VMID" class="headerlink" title="Fibre Channel VMID"></a>Fibre Channel VMID</h1><p>FC SAN可以提供多个依赖于VMID的QoS等级和访问控制功能。它还可以收集每个虚拟机的遥测数据，这些数据可用于增强虚拟机的IO性能。可以通过fibrechannel元素项的appid属性项进行配置。该属性项包含了简单的字符串（最大128字节），内核可使用该属性项创建VMID。</p><pre><code>...&lt;resource&gt;  &lt;fibrechannel appid=&#39;userProvidedID&#39;/&gt;&lt;/resource&gt;...</code></pre><p>使用该特征项要求支持光纤通道的硬件，内核编译时配置有 CONFIG_BLK_CGROUP_FC_APPID选项，且nvme_fc内核模块已加载。自7.7.0起。</p><p>本章节描述了用来代表作用域的xml文件格式，根据运行的作用于种类的格式变化，有一些可选配置项用来加载文件。对于特定虚拟机的细节可以查看<br><a href="https://libvirt.org/drivers.html">相关文件</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文网址：&lt;a href=&quot;https://libvirt.org/formatdomain.html#id8&quot; title=&quot;Domain XML format&quot;&gt;https://libvirt.org/formatdomain.html#id8&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="虚拟化" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="kvm" scheme="https://bbbccvbvv.github.io/tags/kvm/"/>
    
    <category term="libvirt" scheme="https://bbbccvbvv.github.io/tags/libvirt/"/>
    
    <category term="虚拟机xml配置文件" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BAxml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
    <category term="翻译" scheme="https://bbbccvbvv.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="CPU model and topology" scheme="https://bbbccvbvv.github.io/tags/CPU-model-and-topology/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】libvirt虚拟机xml配置文件格式（8）NUMA Node Tuning、Block I/O Tuning、Resource partitioning、Fibre Channel VMID</title>
    <link href="https://bbbccvbvv.github.io/2022/11/14/domain_xml_format8_block_io_tuning_resource_partitioning_fibre_channel_vmid/"/>
    <id>https://bbbccvbvv.github.io/2022/11/14/domain_xml_format8_block_io_tuning_resource_partitioning_fibre_channel_vmid/</id>
    <published>2022-11-14T08:10:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>原文网址：<a href="https://libvirt.org/formatdomain.html#id8" title="Domain XML format">https://libvirt.org/formatdomain.html#id8</a></p><span id="more"></span><h1 id="NUMA-Node-Tuning"><a href="#NUMA-Node-Tuning" class="headerlink" title="NUMA Node Tuning"></a>NUMA Node Tuning</h1><pre><code>&lt;domain&gt;  ...  &lt;numatune&gt;    &lt;memory mode=&quot;strict&quot; nodeset=&quot;1-4,^3&quot;/&gt;    &lt;memnode cellid=&quot;0&quot; mode=&quot;strict&quot; nodeset=&quot;1&quot;/&gt;    &lt;memnode cellid=&quot;2&quot; mode=&quot;preferred&quot; nodeset=&quot;2&quot;/&gt;  &lt;/numatune&gt;  ...&lt;/domain&gt;</code></pre><h2 id="numatune"><a href="#numatune" class="headerlink" title="numatune"></a>numatune</h2><p>可选元素项numatune提供了如何通过控制虚拟机进程的NUMA策略对NUMA主机的性能进行调度。注意，仅支持QEMU。自0.9.3起。</p><h2 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h2><p>可选元素项memory指明了如何对NUMA主机的虚拟机进程进行内存分配。其包含多个可选属性项。属性项mode的可用值包含interleave、strict、preferred和restrictive，默认设置为strict。restrictive指明使用系统默认策略，仅有cgroups被用来限制内存节点，在memnode元素中将mode设置为restrictive。属性项nodeset指明了numa节点，其与vcpu元素项的cpuset属性项使用相同的语法。属性项placement（自0.9.12起）可被用来表明虚拟机进程的内存放置模式，其值可以为static或auto，是vcpu的placement的默认值，如果指定了nodeset则默认值为static。auto表明虚拟机进程只会从查询numad返回的咨询节点中集中分配内存，属性nodeset的值在指定auto的情况下将会被忽略。如果vcpu的placement设置为auto，且numatune未指定，则numatune的placement设置为auto，mode设置为strict。自0.9.3起。参阅 virDomainSetNumaParameters获取该元素的更多信息。</p><h2 id="memnode"><a href="#memnode" class="headerlink" title="memnode"></a>memnode</h2><p>可选元素项memnode可以为每个虚拟机的numa节点指定内存分配策略。对于没有memnode元素的哪些节点，memory元素的默认值将会被使用。属性项cellid寻址应用设置的虚拟机NUMA节点。属性项mode和nodeset与memory元素中的对应值具有相同的含义和语法。设置与自动placement不兼容。qemu自1.2.7起。</p><h1 id="Block-I-x2F-O-Tuning"><a href="#Block-I-x2F-O-Tuning" class="headerlink" title="Block I&#x2F;O Tuning"></a>Block I&#x2F;O Tuning</h1><pre><code>&lt;domain&gt;  ...  &lt;blkiotune&gt;    &lt;weight&gt;800&lt;/weight&gt;    &lt;device&gt;      &lt;path&gt;/dev/sda&lt;/path&gt;      &lt;weight&gt;1000&lt;/weight&gt;    &lt;/device&gt;    &lt;device&gt;      &lt;path&gt;/dev/sdb&lt;/path&gt;      &lt;weight&gt;500&lt;/weight&gt;      &lt;read_bytes_sec&gt;10000&lt;/read_bytes_sec&gt;      &lt;write_bytes_sec&gt;10000&lt;/write_bytes_sec&gt;      &lt;read_iops_sec&gt;20000&lt;/read_iops_sec&gt;      &lt;write_iops_sec&gt;20000&lt;/write_iops_sec&gt;    &lt;/device&gt;  &lt;/blkiotune&gt;  ...&lt;/domain&gt;</code></pre><h2 id="blkiotune"><a href="#blkiotune" class="headerlink" title="blkiotune"></a>blkiotune</h2><p>可选元素项blkiotune为虚拟机提供了调节Blkio cgroup可调参数的能力。如果忽略该设置项，则其默认由操作系统提供。自0.8.8起。</p><h2 id="weight"><a href="#weight" class="headerlink" title="weight"></a>weight</h2><p>可选元素项weight是虚拟机的全部i&#x2F;o负载。该值的范围是100-1000.在2.6.39内核后，该值的范围是10-1000.</p><h2 id="device"><a href="#device" class="headerlink" title="device"></a>device</h2><p>虚拟机可能又有多个device元素项，以便深入调节虚拟机正在使用的每一个主机块设备的权重。注意多个磁盘（可参阅Hard drives, floppy disks, CDROMs章节）可能共享同一个主机块设备，如果他们被相同的主机文件系统中的文件备份，这也是为什么使用全局作用域的调节参数而非相关的每一个虚拟机磁盘设备的原因（与磁盘定义中的iotune元素项相反（可参阅Hard drives, floppy disks, CDROMs章节），而iotune元素项适用于单个独立的磁盘）。每一个device元素项有两个强制的子元素项，path描述了设备的绝对路径，而weight给出了设备的相对权重，权重范围是100-1000.在2.6.39版本内核之后，该值的范围变为10-1000.自0.9.8起。除此之外，也可使用如下的可选子元素项：</p><h3 id="read-bytes-sec"><a href="#read-bytes-sec" class="headerlink" title="read_bytes_sec"></a>read_bytes_sec</h3><p>以字节为单位的每秒可读吞吐量。自1.2.2起。</p><h3 id="write-bytes-sec"><a href="#write-bytes-sec" class="headerlink" title="write_bytes_sec"></a>write_bytes_sec</h3><p>以字节为单位的每秒可写吞吐量。自1.2.2起。</p><h3 id="read-iops-sec"><a href="#read-iops-sec" class="headerlink" title="read_iops_sec"></a>read_iops_sec</h3><p>每秒i&#x2F;o读操作限制。自1.2.2起。</p><h3 id="write-iops-sec"><a href="#write-iops-sec" class="headerlink" title="write_iops_sec"></a>write_iops_sec</h3><p>每秒i&#x2F;o写操作限制。自1.2.2起。</p><h1 id="Resource-partitioning"><a href="#Resource-partitioning" class="headerlink" title="Resource partitioning"></a>Resource partitioning</h1><p>虚拟机管理程序可能允许将虚拟机放入资源分区，也可能嵌套所述分区。resource元素将与资源分区相关的配置项组织在一起。当前其支持partition子元素项，该子元素项的内容定义了放置虚拟机的资源分区的绝对路径。如果没有列出任何分区，虚拟机将会被放到默认分区中。应用程序或管理员有责任确保分区在虚拟机启动之前就已存在。只有默认分区（适用于特定虚拟机管理程序）可以默认假定已经存在。</p><pre><code>...&lt;resource&gt;  &lt;partition&gt;/virtualmachines/production&lt;/partition&gt;&lt;/resource&gt;...</code></pre><p>资源分区当前在qemu和lxc中受到支持，在所有已安装的控制器中将分区路径映射到cgroups目录。自1.0.5起。</p><h1 id="Fibre-Channel-VMID"><a href="#Fibre-Channel-VMID" class="headerlink" title="Fibre Channel VMID"></a>Fibre Channel VMID</h1><p>FC SAN可以提供多个依赖于VMID的QoS等级和访问控制功能。它还可以收集每个虚拟机的遥测数据，这些数据可用于增强虚拟机的IO性能。可以通过fibrechannel元素项的appid属性项进行配置。该属性项包含了简单的字符串（最大128字节），内核可使用该属性项创建VMID。</p><pre><code>...&lt;resource&gt;  &lt;fibrechannel appid=&#39;userProvidedID&#39;/&gt;&lt;/resource&gt;...</code></pre><p>使用该特征项要求支持光纤通道的硬件，内核编译时配置有 CONFIG_BLK_CGROUP_FC_APPID选项，且nvme_fc内核模块已加载。自7.7.0起。</p><p>本章节描述了用来代表作用域的xml文件格式，根据运行的作用于种类的格式变化，有一些可选配置项用来加载文件。对于特定虚拟机的细节可以查看<br><a href="https://libvirt.org/drivers.html">相关文件</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文网址：&lt;a href=&quot;https://libvirt.org/formatdomain.html#id8&quot; title=&quot;Domain XML format&quot;&gt;https://libvirt.org/formatdomain.html#id8&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="虚拟化" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="kvm" scheme="https://bbbccvbvv.github.io/tags/kvm/"/>
    
    <category term="libvirt" scheme="https://bbbccvbvv.github.io/tags/libvirt/"/>
    
    <category term="虚拟机xml配置文件" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BAxml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
    <category term="翻译" scheme="https://bbbccvbvv.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="NUMA Node Tuning" scheme="https://bbbccvbvv.github.io/tags/NUMA-Node-Tuning/"/>
    
    <category term="Block I/O Tuning" scheme="https://bbbccvbvv.github.io/tags/Block-I-O-Tuning/"/>
    
    <category term="Resource partitioning" scheme="https://bbbccvbvv.github.io/tags/Resource-partitioning/"/>
    
    <category term="Fibre Channel VMID" scheme="https://bbbccvbvv.github.io/tags/Fibre-Channel-VMID/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】libvirt虚拟机xml配置文件格式（7）Memory Allocation、Memory Backing和Memory Tuning</title>
    <link href="https://bbbccvbvv.github.io/2022/11/10/domain_xml_format7_memory_allocation/"/>
    <id>https://bbbccvbvv.github.io/2022/11/10/domain_xml_format7_memory_allocation/</id>
    <published>2022-11-10T03:56:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>原文网址：<a href="https://libvirt.org/formatdomain.html#id8" title="Domain XML format">https://libvirt.org/formatdomain.html#id8</a></p><span id="more"></span><h1 id="Memory-Allocation"><a href="#Memory-Allocation" class="headerlink" title="Memory Allocation"></a>Memory Allocation</h1><pre><code>&lt;domain&gt;  ...  &lt;maxMemory slots=&#39;16&#39; unit=&#39;KiB&#39;&gt;1524288&lt;/maxMemory&gt;  &lt;memory unit=&#39;KiB&#39;&gt;524288&lt;/memory&gt;  &lt;currentMemory unit=&#39;KiB&#39;&gt;524288&lt;/currentMemory&gt;  ...&lt;/domain&gt;</code></pre><h2 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h2><p>boot时虚拟机的最大分配内存。内存分配包含了在启动时或在之后热插拔的全部可能的额外内存设备。该值的单位由可选属性项unit设置，默认以KiB为单位（kibibytes，2^10或1024字节块）。有效的单位还有b或byte代表字节，KB代表kilobytes（10^3或1000字节），k或KiB代表kibibytes（1024字节）。MB代表megabytes（10^6或1000000字节），M或MiB代表 mebibytes（2^20或1048576字节），GB代表gigabytes（10^9或1000000000字节），T或TiB代表tebibytes（2^40或1099511627776字节）.然而，该值会被libvirt四舍五入到最近的kibibytes，也可能进一步四舍五入到虚拟机管理程序支持的粒度。一些虚拟机管理程序也会强制设置一个最小值，例如4000KiB。这种情况下，虚拟机配置的numa的memory元素会被忽略。如果发生crash，可选属性项dumpCore可用来控制是否将虚拟机内存包含在生成的coredump文件中（属性值为on和off）。unit自0.9.11起，dumpCore自0.10.2起（仅限于qemu）。</p><h2 id="maxMemory"><a href="#maxMemory" class="headerlink" title="maxMemory"></a>maxMemory</h2><p>运行时虚拟机的最大内存分配。被numa的memory元素或者numa cell大小配置的初始内存可通过内存热插拔方式增长到该元素限制的最大内存大小。unit属性项与memory中的同名属性项表现完全一致。slots属性项指定了将内存添加到虚拟机时可用slot的数量。数量上下限与虚拟机管理程序有关。注意由于内存对齐的限制，通过内存条热插拔所获得的完整内存大小可能无法达到该元素的设置值。自1.2.14起在qemu中支持。</p><h2 id="currentMemory"><a href="#currentMemory" class="headerlink" title="currentMemory"></a>currentMemory</h2><p>虚拟机真实分配的内存。该值小于最大分配数值，允许动态扩充虚拟机内存。如果未设置该项，则默认与memory元素具有同样的数值设置。unit属性项与memory中的unit作用一致。</p><h1 id="Memory-Backing"><a href="#Memory-Backing" class="headerlink" title="Memory Backing"></a>Memory Backing</h1><pre><code>&lt;domain&gt;  ...  &lt;memoryBacking&gt;    &lt;hugepages&gt;      &lt;page size=&quot;1&quot; unit=&quot;G&quot; nodeset=&quot;0-3,5&quot;/&gt;      &lt;page size=&quot;2&quot; unit=&quot;M&quot; nodeset=&quot;4&quot;/&gt;    &lt;/hugepages&gt;    &lt;nosharepages/&gt;    &lt;locked/&gt;    &lt;source type=&quot;file|anonymous|memfd&quot;/&gt;    &lt;access mode=&quot;shared|private&quot;/&gt;    &lt;allocation mode=&quot;immediate|ondemand&quot; threads=&#39;8&#39;/&gt;    &lt;discard/&gt;  &lt;/memoryBacking&gt;  ...&lt;/domain&gt;</code></pre><p>可选元素项memoryBacking包含多个影响主机内存页备份虚拟内存的元素项。</p><h2 id="hugepages"><a href="#hugepages" class="headerlink" title="hugepages"></a>hugepages</h2><p>该元素项告知虚拟机管理程序虚拟机使用大页而非通常的主机内存页大小进行内存分配。自1.2.5起。可以为每个numa节点详尽的设置大页。page元素项被引入。其包含一个强制属性项size用于指定具体使用哪些大页（在支持不同大小大页的系统中尤其有用）。size属性项的默认单位是kilobytes（1024的整数倍）。如果想要使用不同的单位，可使用可选属性项unit。对于numa系统，可选的nodeset属性可能会派上用场，因为它将给定虚拟机的NUMA节点与某些大页大小相关联。在某些例子中，除了4#节点之外的其他numa节点都使用了1G大小的大页。相关语法可以查看NUMA Node Tuning章节。</p><h2 id="nosharepages"><a href="#nosharepages" class="headerlink" title="nosharepages"></a>nosharepages</h2><p>告知虚拟机管理程序虚拟机禁用共享内存页（内存合并，ksm）。自1.0.6起。</p><h2 id="locked"><a href="#locked" class="headerlink" title="locked"></a>locked</h2><p>当虚拟机管理程序支持并设置相关数值后，虚拟机内存页将会在主机内存中锁定，而且主机也不会将其换出，这在某些工况下如实时场景中是十分必要的。对于QEMU&#x2F;KVM虚拟机，qemu进程自身使用的内存也会被锁定；与虚拟机内存不同，libvirt无法提前获取相应内存的数量，所以必须移除对于锁定内存的限制。因此，启用该可选元素项存在潜在的安全风险；当主机内存耗尽时主机无法从虚拟机回复内存，这就意味着大量的虚拟机将会造成大量内存被锁定，主机上会遭受到拒绝服务攻击。因为该原因，除非确实需要否则不建议使用该元素项；即便如此，强烈推荐为特定环境的内存分配设置 hard_limit属性项（参阅Memory Tuning章节），这可以有效的缓解上述描述的风险的发生。自1.0.6起。</p><h2 id="source"><a href="#source" class="headerlink" title="source"></a>source</h2><p>使用type属性项，可提供“file”以利用文件内存备份或保持默认的”anonymous”。自4.10.0起，也可选择memfd备份。（仅限于QEMU&#x2F;KVM）</p><h2 id="access"><a href="#access" class="headerlink" title="access"></a>access</h2><p>使用mode属性项，指明内存是shared还是private。该元素会被每个numa节点的memAccess元素覆盖。</p><h2 id="allocation"><a href="#allocation" class="headerlink" title="allocation"></a>allocation</h2><p>使用可选属性项mode，通过提供”immediate”或”ondemand”参数指明何时进行内存分配。自8.2.0起。也可以通过threads属性设置虚拟机管理程序用来进行内存分配的线程数量。</p><h2 id="discard"><a href="#discard" class="headerlink" title="discard"></a>discard</h2><p>当虚拟机管理程序支持并设置该元素时，在虚拟机关机之前（或当DIMM模块被拔出时）内存内容被丢弃。注意这仅仅只是一个优化项，并不保证在所有场景下都会起作用（例如虚拟机管理程序crash时）。自4.4.0起（仅限于QEMU&#x2F;KVM）。</p><h1 id="Memory-Tuning"><a href="#Memory-Tuning" class="headerlink" title="Memory Tuning"></a>Memory Tuning</h1><pre><code>&lt;domain&gt;  ...  &lt;memtune&gt;    &lt;hard_limit unit=&#39;G&#39;&gt;1&lt;/hard_limit&gt;    &lt;soft_limit unit=&#39;M&#39;&gt;128&lt;/soft_limit&gt;    &lt;swap_hard_limit unit=&#39;G&#39;&gt;2&lt;/swap_hard_limit&gt;    &lt;min_guarantee unit=&#39;bytes&#39;&gt;67108864&lt;/min_guarantee&gt;  &lt;/memtune&gt;  ...&lt;/domain&gt;</code></pre><h2 id="memtune"><a href="#memtune" class="headerlink" title="memtune"></a>memtune</h2><p>可选元素项memtune提供与虚拟机内存调度参数相关的细节描述。如果忽略该项设置，则默认由操作系统提供默认值。对于QEMU&#x2F;KVM，应用于qemu进程的参数被看做一个整体。因此，对其进行计数时，需要加上虚拟机ram、虚拟机显卡ram和qemu自身的一些内存。最后一点很难确定具体数值，因此需要猜想与尝试。对于每个可调参数，可以使用与memory相同的值来指定输入时数字所使用的单位。为了向后兼容，输出始终以KiB为单位。unit自0.9.11起。全部*_limit参数的可能值在0到VIR_DOMAIN_MEMORY_PARAM_UNLIMITED的范围内。</p><h2 id="hard-limit"><a href="#hard-limit" class="headerlink" title="hard_limit"></a>hard_limit</h2><p>可选元素项hard_limit是虚拟机可使用的最大内存。该值的单位是kibibytes（1024字节的块）。qemu和kvm的使用者清冽建议不要设置相关限制项，因为如果虚拟机运行过少则虚拟机可能被内核关闭，决定进程运行所需的内存是一个无法决定的问题；也就是说，如果因工况需要已在 Memory Backing中设置了locked属性，您必须考虑部署的具体细节，并确定一个足够大的hard_limit值，以支持您的虚拟机的内存需求，但是该值足够小也可以保护主机以避免虚拟机锁定全部的内存。</p><h2 id="soft-limit"><a href="#soft-limit" class="headerlink" title="soft_limit"></a>soft_limit</h2><p>可选元素项soft_limit就是内存争用期间强制设置的内存限制。该值的单位是kibibytes（1024字节块）。</p><h2 id="swap-hard-limit"><a href="#swap-hard-limit" class="headerlink" title="swap_hard_limit"></a>swap_hard_limit</h2><p>可选元素项swap_hard_limit就是加上交互内存swap后虚拟机可食用的最大内存。该值的单位是kibibytes（1024字节块）。该值应大于hard_limit的设置值。</p><h2 id="min-guarantee"><a href="#min-guarantee" class="headerlink" title="min_guarantee"></a>min_guarantee</h2><p>可选元素项min_guarantee就是应保证的虚拟机最小分配内存。该值的单位是kibibytes（1024字节块）。该元素仅被VMware ESX和OpenVZ支持。</p><p>本章节描述了用来代表作用域的xml文件格式，根据运行的作用于种类的格式变化，有一些可选配置项用来加载文件。对于特定虚拟机的细节可以查看<br><a href="https://libvirt.org/drivers.html">相关文件</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文网址：&lt;a href=&quot;https://libvirt.org/formatdomain.html#id8&quot; title=&quot;Domain XML format&quot;&gt;https://libvirt.org/formatdomain.html#id8&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="虚拟化" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="kvm" scheme="https://bbbccvbvv.github.io/tags/kvm/"/>
    
    <category term="libvirt" scheme="https://bbbccvbvv.github.io/tags/libvirt/"/>
    
    <category term="虚拟机xml配置文件" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BAxml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
    <category term="翻译" scheme="https://bbbccvbvv.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="Memory Allocation" scheme="https://bbbccvbvv.github.io/tags/Memory-Allocation/"/>
    
    <category term="Memory Backing" scheme="https://bbbccvbvv.github.io/tags/Memory-Backing/"/>
    
    <category term="Memory Tuning" scheme="https://bbbccvbvv.github.io/tags/Memory-Tuning/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】libvirt虚拟机xml配置文件格式（6）CPU Tuning</title>
    <link href="https://bbbccvbvv.github.io/2022/11/04/domain_xml_format_CPU-tuning/"/>
    <id>https://bbbccvbvv.github.io/2022/11/04/domain_xml_format_CPU-tuning/</id>
    <published>2022-11-04T06:35:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>原文网址：<a href="https://libvirt.org/formatdomain.html#id8" title="Domain XML format">https://libvirt.org/formatdomain.html#id8</a></p><span id="more"></span><pre><code>&lt;domain&gt;  ...  &lt;cputune&gt;    &lt;vcpupin vcpu=&quot;0&quot; cpuset=&quot;1-4,^2&quot;/&gt;    &lt;vcpupin vcpu=&quot;1&quot; cpuset=&quot;0,1&quot;/&gt;    &lt;vcpupin vcpu=&quot;2&quot; cpuset=&quot;2,3&quot;/&gt;    &lt;vcpupin vcpu=&quot;3&quot; cpuset=&quot;0,4&quot;/&gt;    &lt;emulatorpin cpuset=&quot;1-3&quot;/&gt;    &lt;iothreadpin iothread=&quot;1&quot; cpuset=&quot;5,6&quot;/&gt;    &lt;iothreadpin iothread=&quot;2&quot; cpuset=&quot;7,8&quot;/&gt;    &lt;shares&gt;2048&lt;/shares&gt;    &lt;period&gt;1000000&lt;/period&gt;    &lt;quota&gt;-1&lt;/quota&gt;    &lt;global_period&gt;1000000&lt;/global_period&gt;    &lt;global_quota&gt;-1&lt;/global_quota&gt;    &lt;emulator_period&gt;1000000&lt;/emulator_period&gt;    &lt;emulator_quota&gt;-1&lt;/emulator_quota&gt;    &lt;iothread_period&gt;1000000&lt;/iothread_period&gt;    &lt;iothread_quota&gt;-1&lt;/iothread_quota&gt;    &lt;vcpusched vcpus=&#39;0-4,^3&#39; scheduler=&#39;fifo&#39; priority=&#39;1&#39;/&gt;    &lt;iothreadsched iothreads=&#39;2&#39; scheduler=&#39;batch&#39;/&gt;    &lt;cachetune vcpus=&#39;0-3&#39;&gt;      &lt;cache id=&#39;0&#39; level=&#39;3&#39; type=&#39;both&#39; size=&#39;3&#39; unit=&#39;MiB&#39;/&gt;      &lt;cache id=&#39;1&#39; level=&#39;3&#39; type=&#39;both&#39; size=&#39;3&#39; unit=&#39;MiB&#39;/&gt;      &lt;monitor level=&#39;3&#39; vcpus=&#39;1&#39;/&gt;      &lt;monitor level=&#39;3&#39; vcpus=&#39;0-3&#39;/&gt;    &lt;/cachetune&gt;    &lt;cachetune vcpus=&#39;4-5&#39;&gt;      &lt;monitor level=&#39;3&#39; vcpus=&#39;4&#39;/&gt;      &lt;monitor level=&#39;3&#39; vcpus=&#39;5&#39;/&gt;    &lt;/cachetune&gt;    &lt;memorytune vcpus=&#39;0-3&#39;&gt;      &lt;node id=&#39;0&#39; bandwidth=&#39;60&#39;/&gt;    &lt;/memorytune&gt;  &lt;/cputune&gt;  ...&lt;/domain&gt;</code></pre><h1 id="cputune"><a href="#cputune" class="headerlink" title="cputune"></a>cputune</h1><p>可选元素项cputune为虚拟机提供与cpu可调参数相关的细节设置。注意：对于qemu驱动而言，可选的vcpupin和emulatorpin绑定设置需要考虑模拟器启动和NUMA限制后再进行设置。这就意味着主机的其他物理cpu在这段时间内会被虚拟机使用，这也可以从virsh cpu-stats的输出中反映出来。自0.9.0起。</p><h1 id="vcpupin"><a href="#vcpupin" class="headerlink" title="vcpupin"></a>vcpupin</h1><p>可选元素项vcpupin指明了虚拟机的vCPU将会被绑定到主机的哪一个物理CPU上。如果忽略该设置项，vcpu元素的cpuset属性项也没有设置，则vcpu会默认绑定到全部的物理cpu上。其包含两个所需的属性项，属性项vcpu指明了vcpu id，属性项cpuset与vcpu元素的cpuset属性项是完全一致的。qemu自0.9.0起被支持，xen自0.9.1起被支持。</p><h1 id="emulatorpin"><a href="#emulatorpin" class="headerlink" title="emulatorpin"></a>emulatorpin</h1><p>可选元素项emulatorpin元素指明了主机的拿个物理cpu是模拟器，这是不包含虚拟机的vcpu和iothreads绑定的cpu的子集。如果忽略该项设置，也没有设置vcpu的cpuset属性项，模拟器将会默认绑定到全部的物理cpu上。emulatorpin包含了一个必须的属性项cpuset用于指明要绑定到哪一个物理cpu中。</p><h1 id="iothreadpin"><a href="#iothreadpin" class="headerlink" title="iothreadpin"></a>iothreadpin</h1><p>可选元素项iothreadpin指明了IOThreads将会被绑定到哪一个物理cpu上。如果忽略该设置，且vcpu元素项的cpuset属性项也没有设置，IOThreads将会默认绑定到全部的物理cpu上。这里存在两个必须的属性项，属性项iothread指明了IOThread ID，属性项cpuset指明了绑定的物理cpu。可查看IOThreads Allocation章节查看iothread的有效值。自1.2.9起。</p><h1 id="shares"><a href="#shares" class="headerlink" title="shares"></a>shares</h1><p>可选元素项shares指明了虚拟机的比例加权份额。如果忽略该项设置，默认使用操作系统提供的默认值。注意，这个值没有单位，是建立在其他虚拟机设置上的相对量度。一个设置为2048的虚拟机将会相对另一个设置为1024的虚拟机得到两倍长的cpu时间。这个值得范围是2-262144.自0.9.0起。</p><h1 id="period"><a href="#period" class="headerlink" title="period"></a>period</h1><p>可选元素项period指明了执行间隔（单位：毫秒）。在该元素项内，虚拟机的每一个vcpu都不允许消耗超过配额的运行时间。该值的范围是1000-1000000.设置为0则意味着未设置数值。qemu自0.9.4起支持，lxc自0.9.10起支持。</p><h1 id="quota"><a href="#quota" class="headerlink" title="quota"></a>quota</h1><p>可选元素项quota指定了最大允许带宽（单位：毫秒）。quota设置为负值的虚拟机表明对于其vcpu线程具有无限制的带宽，即其不受带宽控制。该值的范围是1000-17592186044415或小于0.quota为0意味着未设置数值。可使用该特征确保所有的vcpu以相同速度运行。qemu自0.9.4起支持，lxc自0.9.10起支持。</p><h1 id="global-period"><a href="#global-period" class="headerlink" title="global_period"></a>global_period</h1><p>可选元素项global_period指定整个虚拟机的强制CFS调度程序间隔（单位：微秒），与强制每个vCPU间隔的period形成对比。该值的范围是1000-1000000.global_period设置为0意味着未设置数值。qemu自1.3.3起支持。</p><h1 id="global-quota"><a href="#global-quota" class="headerlink" title="global_quota"></a>global_quota</h1><p>可选元素项global_quota指明了全虚拟机在周期时间内的最大允许带宽（单位：毫秒）。global_quota设置为负值的虚拟机表明虚拟机具有无限制的带宽，即其不受带宽控制。该值的范围是1000-17592186044415或小于0.global_quota为0意味着未设置数值。qemu自1.3.3起支持。</p><h1 id="emulator-period"><a href="#emulator-period" class="headerlink" title="emulator_period"></a>emulator_period</h1><p>可选元素项emulator_period指明了强制间隔（单位：毫秒）。使用emulator_period设置，则虚拟机的模拟器线程（包括vcpu）不允许消耗超过emulator_quota的运行时间。该值的范围是1000-1000000.为0意味着未设置数值。qemu自0.10.0起支持.</p><h1 id="emulator-quota"><a href="#emulator-quota" class="headerlink" title="emulator_quota"></a>emulator_quota</h1><p>可选元素项emulator_quota指明了虚拟机模拟器线程（包括vcpu）最大允许带宽（单位：毫秒）。带有负值emulator_quota设置的虚拟机的模拟器线程（包括vcpu）拥有无限带宽，即其不受带宽控制。值范围是1000-17592186044415或小于0.quota设置为0意味着未设置值。qemu自0.10.0起支持.</p><h1 id="iothread-period"><a href="#iothread-period" class="headerlink" title="iothread_period"></a>iothread_period</h1><p>可选元素项iothread_period指明了IOThreads的强制间隔（单位：毫秒）。使用iothread_period，虚拟机的每一个IOThreads不允许消耗超过iothread_quota设置的运行时间。该值的范围是1000-1000000.设置为0意味着未设置该值。自2.1.0起支持qemu。</p><h1 id="iothread-quota"><a href="#iothread-quota" class="headerlink" title="iothread_quota"></a>iothread_quota</h1><p>可选元素项iothread_quota指明了IOThreads的最大允许带宽（单位：毫秒）。iothread_quota为负值的虚拟机表明虚拟机IOThreads具有无限带宽，即其不受带宽控制。该值的范围是1000-17592186044415或小于0.设置为0意味着未设置该值。可使用该特征确保全部IOThreads以相同速度运行。自2.1.0起支持qemu。</p><h1 id="vcpusched-x2F-iothreadsched-x2F-emulatorsched"><a href="#vcpusched-x2F-iothreadsched-x2F-emulatorsched" class="headerlink" title="vcpusched&#x2F;iothreadsched&#x2F;emulatorsched"></a>vcpusched&#x2F;iothreadsched&#x2F;emulatorsched</h1><p>可选元素项vcpusched、iothreadsched和emulatorsched分别指明了特定vcpu、iothread和模拟器线程的调度类型（值为batch、idle、fifo和rr）。对于vcpusched和iothreadsched，属性项vcpus和iothreads选择了该设置适用于哪些vCPUs&#x2F;IOThreads，其余的设置为默认值。元素项emulatorsched不具有该属性。vcpus的有效值为0到虚拟机中设置的vcpu数量减一。iothreads的有效值在IOThreads Allocation章节中有过描述。如果未定义iothreadids，然后libvirt将IOThreads编号从1到虚拟机可用的iothreads进行计数。对于实时调度（fifo、rr），也需指定优先级（非实时调度可忽略）。优先级的范围依赖于主机内核（通常为1-99）。自1.2.13起。emulatorsched自5.3.0起。</p><h1 id="cachetune（自4-1-0起）"><a href="#cachetune（自4-1-0起）" class="headerlink" title="cachetune（自4.1.0起）"></a>cachetune（自4.1.0起）</h1><p>可选元素项cachetune使用主机上的restctrl控制cpu缓存分配。是否支持此功能可以从一些限制（如最小尺寸和所需粒度）的功能中获取。必需的属性项vcpus指定了本次分配适用于哪一个vcpu。一个vcpu只能是一个cachetune元素分配项的成员。cachetune指定的vCPU可以与memorytune 中的vCPU相同，但不允许重复指定。可选的、仅输出的id属性唯一标识缓存。支持以下子元素：</p><h2 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h2><p>该可选元素项控制cpu缓存分配并具有以下属性项：</p><h3 id="level"><a href="#level" class="headerlink" title="level"></a>level</h3><p>用于分配的主机缓存等级。</p><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>用于分配的主机缓存id。</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>分配的类型。code代表指令，data代表数据。both则同时代表两者。当前分配类型只能与主机支持的类型保持一致，意味着不能在启用cdp（指令、数据优先级）的主机上使用both类型。</p><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>分配区域大小。默认值以字节为单位，但是unit属性项可用来缩放该值。</p><h3 id="unit-可选"><a href="#unit-可选" class="headerlink" title="unit(可选)"></a>unit(可选)</h3><p>如果unit设置为KiB、MiB、GiB或TiB（在Memory Allocation中的memory元素中描述），则size的默认值为字节。</p><h2 id="monitor（自4-10-0起）"><a href="#monitor（自4-10-0起）" class="headerlink" title="monitor（自4.10.0起）"></a>monitor（自4.10.0起）</h2><p>可选元素项monitor为当前缓存分配创建缓存管理器并拥有如下所需属性：</p><h3 id="level-1"><a href="#level-1" class="headerlink" title="level"></a>level</h3><p>monitor所属的主机缓存等级。</p><h3 id="vcpus"><a href="#vcpus" class="headerlink" title="vcpus"></a>vcpus</h3><p>vcpu列出了monitor的适用范围。一个monitor的vcpu列表只能是相关分配的vcpu列表的一部分。默认的管理器与相关的分配具有相同的vcpu列表。对于非默认monitor，不允许重复定义vcpu。</p><h1 id="memorytune（自4-7-0起）"><a href="#memorytune（自4-7-0起）" class="headerlink" title="memorytune（自4.7.0起）"></a>memorytune（自4.7.0起）</h1><p>可选元素项memorytune可使用主机上的resctrl控制内存带宽分配。是否支持此功能可以从一些限制（如最小尺寸和所需粒度）功能中获取。必需的属性项vcpus指定了本次分配适用于哪一个vcpu。一个vcpu只能是一个memorytune元素分配项的成员。memorytune指定的vCPU可以与cachetune中的vCPU相同，但不允许重复指定。支持以下子元素：</p><h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><p>该元素控制cpu内存带宽分配，拥有以下属性。</p><h3 id="id-1"><a href="#id-1" class="headerlink" title="id"></a>id</h3><p>分配内存带宽的主机节点id。</p><h3 id="bandwidth"><a href="#bandwidth" class="headerlink" title="bandwidth"></a>bandwidth</h3><p>节点中用于分配的内存带宽。该值默认以百分比为单位。</p><p>本章节描述了用来代表作用域的xml文件格式，根据运行的作用于种类的格式变化，有一些可选配置项用来加载文件。对于特定虚拟机的细节可以查看<br><a href="https://libvirt.org/drivers.html">相关文件</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文网址：&lt;a href=&quot;https://libvirt.org/formatdomain.html#id8&quot; title=&quot;Domain XML format&quot;&gt;https://libvirt.org/formatdomain.html#id8&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="虚拟化" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="kvm" scheme="https://bbbccvbvv.github.io/tags/kvm/"/>
    
    <category term="libvirt" scheme="https://bbbccvbvv.github.io/tags/libvirt/"/>
    
    <category term="虚拟机xml配置文件" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BAxml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
    <category term="翻译" scheme="https://bbbccvbvv.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="CPU Tuning" scheme="https://bbbccvbvv.github.io/tags/CPU-Tuning/"/>
    
  </entry>
  
  <entry>
    <title>_access函数32bit和64bit编译差异</title>
    <link href="https://bbbccvbvv.github.io/2022/10/20/access_usage/"/>
    <id>https://bbbccvbvv.github.io/2022/10/20/access_usage/</id>
    <published>2022-10-20T07:00:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近，在进行软件开发工作中遇到了一个问题，觉得比较有趣，在此进行以下记录。</p><p>问题比较简单，需要检查windows系统下的C:\Windows\System32路径下是否存在特定的用户文件（dll格式）。在这里使用_access函数（C运行库函数）对文件进行检查，该函数主要用于检查文件或目录是否存在及其对应的读写权限。但是开发完成后，在自检过程中却发现使用_access函数无法达到预期，主要表现为文件已存在，但是函数返回结果却表明文件不存在。如果换用win32 API函数PathFileExistsA却正常，文件存在于对应目录。本文即对_access函数的异常进行分析。</p><span id="more"></span><h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><p>win32函数访问没问题，而使用C语言库函数存在问题，即系统调用没问题，主要问题应该出现在C语言库上。而最简单的修改项就是编译环境修改，之前为了兼容性考虑，代码选择的编译环境为32位，因此将编译环境改为64位。此时，_access函数正常执行，返回了符合预期的结果。</p><p>因此，针对这一点进行分析，最终在微软官网上找到相关说明，链接如下：<a href="https://learn.microsoft.com/en-us/windows/win32/winprog64/file-system-redirector?from_wecom=1" title="【Microsoft】文件系统重定向">https://learn.microsoft.com/en-us/windows/win32/winprog64/file-system-redirector?from_wecom&#x3D;1</a>；</p><p>微软在64位操作系统上，为64位应用程序保留了%windir%\System32（通常就是C:\Windows\System32）路径。因为通常情况下，32位dll和64位dll的文件名称完全相同，因此64位dll也保存在System32路径下，而32位dll则被保存在其他路径。这就使得64位操作系统下的32位应用程序访问对应dll时，直接访问%windir%\System32路径是错误的，因此微软为64位系统下的32位程序通过访问%windir%\System32路径做了重定向。而32位要想真正访问%windir%\System32路径，就可以使用%windir%\Sysnative路径替代，也可以使用Wow64DisableWow64FsRedirection函数禁用文件重定向功能。</p><p>示例程序：</p><pre><code>#include  &lt;io.h&gt;#include  &lt;stdio.h&gt;#include  &lt;stdlib.h&gt;#include &lt;Windows.h&gt;#include &lt;iostream&gt;#include &quot;Shlwapi.h&quot;#include &lt;errhandlingapi.h &gt;int main( void )&#123;    char *file_path = &quot;C:\\Windows\\System32\\test.dll&quot;;    char *file_path1 = &quot;C:\\Windows\\Sysnative\\test.dll&quot;;    // Check for existence.    printf_s( &quot;1.access system32.\n&quot;);    if( (_access( file_path, 0 )) != -1 )    &#123;        printf_s( &quot;File %s is exists.\n&quot;, file_path);    &#125;    else    &#123;        printf_s( &quot;File %s isn&#39;t exists.\n&quot;, file_path);    &#125;    printf_s( &quot;2.access sysnative.\n&quot;);    if( (_access( file_path1, 0 )) != -1 )    &#123;        printf_s( &quot;File %s is exists.\n&quot;, file_path1);    &#125;    else    &#123;        printf_s( &quot;File %s isn&#39;t exists.\n&quot;, file_path1);    &#125;    PVOID OldValue = NULL;    //  Disable redirection immediately prior to the native API function call.    printf_s( &quot;3.Disable Redirection.\n&quot;);    bool flag = Wow64DisableWow64FsRedirection(&amp;OldValue);    printf(&quot;Wow64DisableWow64FsRedirection return value is %d.\n&quot;, flag);    if (!flag)    &#123;        DWORD dw = GetLastError();        printf(&quot;Errorcode is %d.\n&quot;, dw);    &#125;    if( (_access( file_path, 0 )) != -1 )    &#123;        printf_s( &quot;File %s is exists.\n&quot;, file_path);    &#125;    else    &#123;        printf_s( &quot;File %s isn&#39;t exists.\n&quot;, file_path);    &#125;    return 0;&#125;</code></pre><p>在32位编译环境下输出如下：</p><pre><code>1.access system32.File C:\Windows\System32\test.dll isn&#39;t exists.2.access sysnative.File C:\Windows\Sysnative\test.dll is exists.3.Disable Redirection.Wow64DisableWow64FsRedirection return value is 1.File C:\Windows\System32\test.dll is exists.</code></pre><p>（1）C:\Windows\System32路径无法直接访问；</p><p>（2）C:\Windows\Sysnative路径会被重定位到C:\Windows\System32；</p><p>（3）Wow64DisableWow64FsRedirection函数返回1代表函数正常运行，此后再使用C:\Windows\System32路径，则无重定向操作，获取到了正确的结果；</p><p>在64位编译环境下输出如下：</p><pre><code>1.access system32.File C:\Windows\System32\test.dll is exists.2.access sysnative.File C:\Windows\Sysnative\test.dll isn&#39;t exists.3.Disable Redirection.Wow64DisableWow64FsRedirection return value is 0.Errorcode is 1.File C:\Windows\System32\test.dll is exists.</code></pre><p>（1）C:\Windows\System32路径可以直接访问；</p><p>（2）C:\Windows\Sysnative路径不会被重定位到C:\Windows\System32；</p><p>（3）Wow64DisableWow64FsRedirection函数返回0代表函数异常运行，但不影响后续使用C:\Windows\System32路径获取正确的结果；</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>_access函数在32bit和64bit编译环境下输出结果存在差异，主要原因即为64位windows操作系统下，%windir%\System32被保留给了对应的64位应用程序，而32位应用程序访问%windir%\System32路径时就会被重定向到系统指定的其他路径上。而使用32bit编译环境最终生成的是32位应用程序，因此对应路径被重定向，直接访问%windir%\System32路径下的文件时就会出现异常。</p><p>因此建议在64位操作系统中使用64位的应用程序，而非32位的应用程序，虽然64位操作系统兼容32位应用程序，而32位操作系统不兼容64位应用程序，因此32位具有更广泛的兼容性。</p><p>如果不确定目标程序运行环境或程序存在运行于两种系统的使用场景，则在使用文件访问相关函数时：</p><p>（1）直接使用win32函数PathFileExistsA；</p><p>（2）使用_access函数前，先使用Wow64DisableWow64FsRedirection函数禁用文件重定向功能；</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>（1）<a href="https://learn.microsoft.com/en-us/windows/win32/winprog64/file-system-redirector?from_wecom=1" title="【Microsoft】文件系统重定向">https://learn.microsoft.com/en-us/windows/win32/winprog64/file-system-redirector?from_wecom&#x3D;1</a>；<br>（2）<a href="https://learn.microsoft.com/en-us/windows/win32/api/wow64apiset/nf-wow64apiset-wow64disablewow64fsredirection?from_wecom=1" title="【Microsoft】Wow64DisableWow64FsRedirection函数">https://learn.microsoft.com/en-us/windows/win32/api/wow64apiset/nf-wow64apiset-wow64disablewow64fsredirection?from_wecom&#x3D;1</a>；<br>（3）<a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/access-waccess?view=msvc-170&from_wecom=1" title="【Microsoft】_access函数">https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/access-waccess?view=msvc-170&from_wecom&#x3D;1</a>；<br>（4）<a href="https://learn.microsoft.com/en-us/windows/win32/api/shlwapi/nf-shlwapi-pathfileexistsa?from_wecom=1" title="【Microsoft】PathFileExistsA函数">https://learn.microsoft.com/en-us/windows/win32/api/shlwapi/nf-shlwapi-pathfileexistsa?from_wecom&#x3D;1</a>；</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近，在进行软件开发工作中遇到了一个问题，觉得比较有趣，在此进行以下记录。&lt;/p&gt;
&lt;p&gt;问题比较简单，需要检查windows系统下的C:\Windows\System32路径下是否存在特定的用户文件（dll格式）。在这里使用_access函数（C运行库函数）对文件进行检查，该函数主要用于检查文件或目录是否存在及其对应的读写权限。但是开发完成后，在自检过程中却发现使用_access函数无法达到预期，主要表现为文件已存在，但是函数返回结果却表明文件不存在。如果换用win32 API函数PathFileExistsA却正常，文件存在于对应目录。本文即对_access函数的异常进行分析。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="C语言" scheme="https://bbbccvbvv.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="_access函数" scheme="https://bbbccvbvv.github.io/tags/access%E5%87%BD%E6%95%B0/"/>
    
    <category term="编译环境" scheme="https://bbbccvbvv.github.io/tags/%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/"/>
    
    <category term="文件检查" scheme="https://bbbccvbvv.github.io/tags/%E6%96%87%E4%BB%B6%E6%A3%80%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】libvirt虚拟机xml配置文件格式（5）IOThreads Allocation</title>
    <link href="https://bbbccvbvv.github.io/2022/10/19/domain_xml_format_IOThreads-Allocation/"/>
    <id>https://bbbccvbvv.github.io/2022/10/19/domain_xml_format_IOThreads-Allocation/</id>
    <published>2022-10-19T09:36:10.000Z</published>
    <updated>2023-12-29T02:38:41.453Z</updated>
    
    <content type="html"><![CDATA[<p>原文网址：<a href="https://libvirt.org/formatdomain.html#id8" title="Domain XML format">https://libvirt.org/formatdomain.html#id8</a></p><p>IOThreads是支持磁盘设备的专用事件循环线程，用于执行块I&#x2F;O请求，以提高可伸缩性，尤其是在具有许多LUN的SMP主机&#x2F;客户机上。自1.2.8起（仅限于QEMU）。</p><span id="more"></span><pre><code>&lt;domain&gt;  ...  &lt;iothreads&gt;4&lt;/iothreads&gt;  ...&lt;/domain&gt;&lt;domain&gt;  ...  &lt;iothreadids&gt;    &lt;iothread id=&quot;2&quot;/&gt;    &lt;iothread id=&quot;4&quot;/&gt;    &lt;iothread id=&quot;6&quot;/&gt;    &lt;iothread id=&quot;8&quot; thread_pool_min=&quot;2&quot; thread_pool_max=&quot;32&quot;/&gt;  &lt;/iothreadids&gt;  &lt;defaultiothread thread_pool_min=&quot;8&quot; thread_pool_max=&quot;16&quot;/&gt;  ...&lt;/domain&gt;</code></pre><h1 id="iothreads"><a href="#iothreads" class="headerlink" title="iothreads"></a>iothreads</h1><p>此可选元素的内容定义要分配给虚拟机以供支持的目标存储设备使用的 IOThread数量。每一个主机CPU只有1个或2个IOThread。可能有多个受支持的设备分配给每个IOThread。自1.2.8起。</p><h1 id="iothreadids"><a href="#iothreadids" class="headerlink" title="iothreadids"></a>iothreadids</h1><p>可选的iothreadids元素提供了为虚拟机专门定义IOThread ID的能力。默认情况下，IOThread ID 是从1到为虚拟机定义的iothreads的数量顺序编号的。id属性项用于定义IOThread ID。id属性项必须是一个大于0的正整数。如果定义的iothreadids少于为虚拟机定义的iothreads，则libvirt将从1开始按顺序填充iothreadids，避免任何预定义的id。如果iothreadids大于为虚拟机定义的iothreads，iothreads的值将会相应调整。自1.2.15起。该元素有两个可选属性项thread_pool_min和thread_pool_max用于定义给定IOThread工作线程的上下限。前者可能是0，后者绝不会为0.自8.5.0起。</p><h1 id="defaultiothread"><a href="#defaultiothread" class="headerlink" title="defaultiothread"></a>defaultiothread</h1><p>该元素代表了虚拟机管理程序内部的默认事件循环，为指定特定IOThread的I&#x2F;O请求会被该循环处理。该元素可设置thread_pool_min和thread_pool_max属性项，指定了默认事件循环工作线程的上下限数量。模拟器可能是多线程的并按需生成所谓的工作线程。通常两个属性项都不会去设置（使得模拟器使用其自身的默认值），除非模拟器在实时工作负载中运行，因此无法承受生成新工作线程所需时间的不可预测性。自8.5.0起。</p><p>本章节描述了用来代表作用域的xml文件格式，根据运行的作用于种类的格式变化，有一些可选配置项用来加载文件。对于特定虚拟机的细节可以查看<br><a href="https://libvirt.org/drivers.html">相关文件</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文网址：&lt;a href=&quot;https://libvirt.org/formatdomain.html#id8&quot; title=&quot;Domain XML format&quot;&gt;https://libvirt.org/formatdomain.html#id8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;IOThreads是支持磁盘设备的专用事件循环线程，用于执行块I&amp;#x2F;O请求，以提高可伸缩性，尤其是在具有许多LUN的SMP主机&amp;#x2F;客户机上。自1.2.8起（仅限于QEMU）。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学" scheme="https://bbbccvbvv.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="虚拟化" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="kvm" scheme="https://bbbccvbvv.github.io/tags/kvm/"/>
    
    <category term="libvirt" scheme="https://bbbccvbvv.github.io/tags/libvirt/"/>
    
    <category term="虚拟机xml配置文件" scheme="https://bbbccvbvv.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BAxml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
    <category term="翻译" scheme="https://bbbccvbvv.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="IOThreads Allocation" scheme="https://bbbccvbvv.github.io/tags/IOThreads-Allocation/"/>
    
  </entry>
  
</feed>
